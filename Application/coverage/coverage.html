
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cache: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">helixtrack.ru/core/internal/cache/cache.go (96.4%)</option>
				
				<option value="file1">helixtrack.ru/core/internal/config/config.go (83.5%)</option>
				
				<option value="file2">helixtrack.ru/core/internal/database/database.go (69.0%)</option>
				
				<option value="file3">helixtrack.ru/core/internal/database/database_documents_impl.go (31.2%)</option>
				
				<option value="file4">helixtrack.ru/core/internal/database/optimized_database.go (81.6%)</option>
				
				<option value="file5">helixtrack.ru/core/internal/logger/logger.go (90.7%)</option>
				
				<option value="file6">helixtrack.ru/core/internal/metrics/metrics.go (100.0%)</option>
				
				<option value="file7">helixtrack.ru/core/internal/middleware/jwt.go (90.9%)</option>
				
				<option value="file8">helixtrack.ru/core/internal/middleware/performance.go (90.4%)</option>
				
				<option value="file9">helixtrack.ru/core/internal/middleware/permission.go (100.0%)</option>
				
				<option value="file10">helixtrack.ru/core/internal/middleware/rbac.go (91.9%)</option>
				
				<option value="file11">helixtrack.ru/core/internal/models/asset.go (0.0%)</option>
				
				<option value="file12">helixtrack.ru/core/internal/models/audit.go (0.0%)</option>
				
				<option value="file13">helixtrack.ru/core/internal/models/board.go (0.0%)</option>
				
				<option value="file14">helixtrack.ru/core/internal/models/board_config.go (0.0%)</option>
				
				<option value="file15">helixtrack.ru/core/internal/models/chat.go (100.0%)</option>
				
				<option value="file16">helixtrack.ru/core/internal/models/comment.go (0.0%)</option>
				
				<option value="file17">helixtrack.ru/core/internal/models/component.go (0.0%)</option>
				
				<option value="file18">helixtrack.ru/core/internal/models/customfield.go (100.0%)</option>
				
				<option value="file19">helixtrack.ru/core/internal/models/cycle.go (0.0%)</option>
				
				<option value="file20">helixtrack.ru/core/internal/models/dashboard.go (0.0%)</option>
				
				<option value="file21">helixtrack.ru/core/internal/models/document.go (100.0%)</option>
				
				<option value="file22">helixtrack.ru/core/internal/models/document_analytics.go (100.0%)</option>
				
				<option value="file23">helixtrack.ru/core/internal/models/document_attachment.go (91.1%)</option>
				
				<option value="file24">helixtrack.ru/core/internal/models/document_collaboration.go (83.0%)</option>
				
				<option value="file25">helixtrack.ru/core/internal/models/document_mappings.go (87.2%)</option>
				
				<option value="file26">helixtrack.ru/core/internal/models/document_other.go (87.2%)</option>
				
				<option value="file27">helixtrack.ru/core/internal/models/document_space.go (100.0%)</option>
				
				<option value="file28">helixtrack.ru/core/internal/models/document_template.go (100.0%)</option>
				
				<option value="file29">helixtrack.ru/core/internal/models/document_version.go (91.2%)</option>
				
				<option value="file30">helixtrack.ru/core/internal/models/epic.go (0.0%)</option>
				
				<option value="file31">helixtrack.ru/core/internal/models/errors.go (100.0%)</option>
				
				<option value="file32">helixtrack.ru/core/internal/models/event.go (66.1%)</option>
				
				<option value="file33">helixtrack.ru/core/internal/models/extension.go (0.0%)</option>
				
				<option value="file34">helixtrack.ru/core/internal/models/filter.go (100.0%)</option>
				
				<option value="file35">helixtrack.ru/core/internal/models/history.go (0.0%)</option>
				
				<option value="file36">helixtrack.ru/core/internal/models/jwt.go (97.3%)</option>
				
				<option value="file37">helixtrack.ru/core/internal/models/label.go (0.0%)</option>
				
				<option value="file38">helixtrack.ru/core/internal/models/mention.go (0.0%)</option>
				
				<option value="file39">helixtrack.ru/core/internal/models/notification.go (0.0%)</option>
				
				<option value="file40">helixtrack.ru/core/internal/models/permission.go (0.0%)</option>
				
				<option value="file41">helixtrack.ru/core/internal/models/priority.go (100.0%)</option>
				
				<option value="file42">helixtrack.ru/core/internal/models/project.go (0.0%)</option>
				
				<option value="file43">helixtrack.ru/core/internal/models/project_category.go (0.0%)</option>
				
				<option value="file44">helixtrack.ru/core/internal/models/project_role.go (0.0%)</option>
				
				<option value="file45">helixtrack.ru/core/internal/models/report.go (0.0%)</option>
				
				<option value="file46">helixtrack.ru/core/internal/models/request.go (100.0%)</option>
				
				<option value="file47">helixtrack.ru/core/internal/models/resolution.go (100.0%)</option>
				
				<option value="file48">helixtrack.ru/core/internal/models/response.go (100.0%)</option>
				
				<option value="file49">helixtrack.ru/core/internal/models/security_level.go (0.0%)</option>
				
				<option value="file50">helixtrack.ru/core/internal/models/service_registry.go (0.0%)</option>
				
				<option value="file51">helixtrack.ru/core/internal/models/subtask.go (0.0%)</option>
				
				<option value="file52">helixtrack.ru/core/internal/models/ticket.go (0.0%)</option>
				
				<option value="file53">helixtrack.ru/core/internal/models/version.go (100.0%)</option>
				
				<option value="file54">helixtrack.ru/core/internal/models/vote.go (0.0%)</option>
				
				<option value="file55">helixtrack.ru/core/internal/models/watcher.go (100.0%)</option>
				
				<option value="file56">helixtrack.ru/core/internal/models/websocket.go (81.8%)</option>
				
				<option value="file57">helixtrack.ru/core/internal/models/worklog.go (0.0%)</option>
				
				<option value="file58">helixtrack.ru/core/internal/security/audit_log.go (98.6%)</option>
				
				<option value="file59">helixtrack.ru/core/internal/security/brute_force_protection.go (79.5%)</option>
				
				<option value="file60">helixtrack.ru/core/internal/security/csrf_protection.go (59.1%)</option>
				
				<option value="file61">helixtrack.ru/core/internal/security/ddos_protection.go (77.8%)</option>
				
				<option value="file62">helixtrack.ru/core/internal/security/input_validation.go (88.4%)</option>
				
				<option value="file63">helixtrack.ru/core/internal/security/security_headers.go (86.1%)</option>
				
				<option value="file64">helixtrack.ru/core/internal/security/service_signer.go (81.7%)</option>
				
				<option value="file65">helixtrack.ru/core/internal/security/tls_enforcement.go (71.9%)</option>
				
				<option value="file66">helixtrack.ru/core/internal/server/server.go (80.8%)</option>
				
				<option value="file67">helixtrack.ru/core/internal/services/auth_service.go (91.8%)</option>
				
				<option value="file68">helixtrack.ru/core/internal/services/failover_manager.go (1.1%)</option>
				
				<option value="file69">helixtrack.ru/core/internal/services/health_checker.go (31.3%)</option>
				
				<option value="file70">helixtrack.ru/core/internal/services/jwt_service.go (0.0%)</option>
				
				<option value="file71">helixtrack.ru/core/internal/services/network_discovery.go (72.1%)</option>
				
				<option value="file72">helixtrack.ru/core/internal/services/permission_service.go (90.7%)</option>
				
				<option value="file73">helixtrack.ru/core/internal/websocket/config.go (0.0%)</option>
				
				<option value="file74">helixtrack.ru/core/internal/websocket/handler.go (0.0%)</option>
				
				<option value="file75">helixtrack.ru/core/internal/websocket/manager.go (56.8%)</option>
				
				<option value="file76">helixtrack.ru/core/internal/websocket/publisher.go (100.0%)</option>
				
				<option value="file77">helixtrack.ru/core/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "sync"
        "time"
)

// Cache defines the caching interface
type Cache interface {
        // Get retrieves a value from cache
        Get(ctx context.Context, key string) (interface{}, bool)

        // Set stores a value in cache with expiration
        Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error

        // Delete removes a value from cache
        Delete(ctx context.Context, key string) error

        // Clear removes all values from cache
        Clear(ctx context.Context) error

        // GetStats returns cache statistics
        GetStats() *CacheStats

        // Close closes the cache connection
        Close() error
}

// CacheStats contains cache performance metrics
type CacheStats struct {
        Hits           int64         // Number of cache hits
        Misses         int64         // Number of cache misses
        Sets           int64         // Number of set operations
        Deletes        int64         // Number of delete operations
        Evictions      int64         // Number of evicted entries
        Size           int           // Current number of entries
        AvgGetDuration time.Duration // Average get operation duration
        AvgSetDuration time.Duration // Average set operation duration
        HitRate        float64       // Cache hit rate (0.0 - 1.0)
}

// cacheEntry represents a single cache entry
type cacheEntry struct {
        value      interface{}
        expiration time.Time
        size       int // Approximate size in bytes
}

// isExpired checks if entry has expired
func (e *cacheEntry) isExpired() bool <span class="cov9" title="109">{
        return time.Now().After(e.expiration)
}</span>

// inMemoryCache is a high-performance in-memory cache
type inMemoryCache struct {
        entries       map[string]*cacheEntry
        mu            sync.RWMutex

        // Statistics
        hits          int64
        misses        int64
        sets          int64
        deletes       int64
        evictions     int64
        totalGetTime  time.Duration
        totalSetTime  time.Duration
        statsMu       sync.RWMutex

        // Configuration
        maxSize       int           // Maximum number of entries
        maxMemory     int64         // Maximum memory in bytes
        currentMemory int64         // Current memory usage
        defaultTTL    time.Duration // Default time-to-live

        // Cleanup
        cleanupInterval time.Duration
        stopCleanup     chan struct{}
        cleanupDone     sync.WaitGroup
}

// CacheConfig contains cache configuration
type CacheConfig struct {
        MaxSize         int           // Maximum entries (0 = unlimited)
        MaxMemory       int64         // Maximum memory in bytes (0 = unlimited)
        DefaultTTL      time.Duration // Default expiration time
        CleanupInterval time.Duration // Cleanup interval
}

// DefaultCacheConfig returns optimized default settings
func DefaultCacheConfig() CacheConfig <span class="cov5" title="13">{
        return CacheConfig{
                MaxSize:         10000,              // 10k entries
                MaxMemory:       256 * 1024 * 1024,  // 256MB
                DefaultTTL:      5 * time.Minute,    // 5 minute default
                CleanupInterval: 1 * time.Minute,    // Cleanup every minute
        }
}</span>

// NewInMemoryCache creates a new high-performance in-memory cache
func NewInMemoryCache(cfg CacheConfig) Cache <span class="cov5" title="13">{
        c := &amp;inMemoryCache{
                entries:         make(map[string]*cacheEntry),
                maxSize:         cfg.MaxSize,
                maxMemory:       cfg.MaxMemory,
                defaultTTL:      cfg.DefaultTTL,
                cleanupInterval: cfg.CleanupInterval,
                stopCleanup:     make(chan struct{}),
        }

        // Start background cleanup
        c.cleanupDone.Add(1)
        go c.cleanupLoop()

        return c
}</span>

// Get retrieves a value from cache
func (c *inMemoryCache) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov10" title="119">{
        start := time.Now()
        defer c.trackGetTime(time.Since(start))

        c.mu.RLock()
        entry, exists := c.entries[key]
        c.mu.RUnlock()

        if !exists </span><span class="cov5" title="10">{
                c.incrementMisses()
                return nil, false
        }</span>

        <span class="cov9" title="109">if entry.isExpired() </span><span class="cov1" title="1">{
                // Remove expired entry
                c.Delete(ctx, key)
                c.incrementMisses()
                return nil, false
        }</span>

        <span class="cov9" title="108">c.incrementHits()
        return entry.value, true</span>
}

// Set stores a value in cache with expiration
func (c *inMemoryCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov9" title="118">{
        start := time.Now()
        defer c.trackSetTime(time.Since(start))

        if expiration == 0 </span><span class="cov0" title="0">{
                expiration = c.defaultTTL
        }</span>

        // Estimate entry size
        <span class="cov9" title="118">size := c.estimateSize(value)

        c.mu.Lock()
        defer c.mu.Unlock()

        // Check if we need to evict
        if c.maxSize &gt; 0 &amp;&amp; len(c.entries) &gt;= c.maxSize </span><span class="cov1" title="1">{
                c.evictOldest()
        }</span>

        // Check memory limit
        <span class="cov9" title="118">if c.maxMemory &gt; 0 </span><span class="cov9" title="118">{
                for c.currentMemory+int64(size) &gt; c.maxMemory &amp;&amp; len(c.entries) &gt; 0 </span><span class="cov0" title="0">{
                        c.evictOldest()
                }</span>
        }

        // Remove old entry size if exists
        <span class="cov9" title="118">if oldEntry, exists := c.entries[key]; exists </span><span class="cov0" title="0">{
                c.currentMemory -= int64(oldEntry.size)
        }</span>

        // Add new entry
        <span class="cov9" title="118">c.entries[key] = &amp;cacheEntry{
                value:      value,
                expiration: time.Now().Add(expiration),
                size:       size,
        }
        c.currentMemory += int64(size)

        c.incrementSets()
        return nil</span>
}

// Delete removes a value from cache
func (c *inMemoryCache) Delete(ctx context.Context, key string) error <span class="cov2" title="2">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if entry, exists := c.entries[key]; exists </span><span class="cov2" title="2">{
                c.currentMemory -= int64(entry.size)
                delete(c.entries, key)
                c.incrementDeletes()
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// Clear removes all values from cache
func (c *inMemoryCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.entries = make(map[string]*cacheEntry)
        c.currentMemory = 0

        return nil
}</span>

// GetStats returns cache statistics
func (c *inMemoryCache) GetStats() *CacheStats <span class="cov3" title="4">{
        c.statsMu.RLock()
        hits := c.hits
        misses := c.misses
        sets := c.sets
        deletes := c.deletes
        evictions := c.evictions
        totalGetTime := c.totalGetTime
        totalSetTime := c.totalSetTime
        c.statsMu.RUnlock()

        c.mu.RLock()
        size := len(c.entries)
        c.mu.RUnlock()

        var avgGetDuration, avgSetDuration time.Duration
        var hitRate float64

        totalRequests := hits + misses
        if totalRequests &gt; 0 </span><span class="cov2" title="2">{
                hitRate = float64(hits) / float64(totalRequests)
        }</span>

        <span class="cov3" title="4">if hits &gt; 0 </span><span class="cov2" title="2">{
                avgGetDuration = totalGetTime / time.Duration(hits)
        }</span>

        <span class="cov3" title="4">if sets &gt; 0 </span><span class="cov3" title="4">{
                avgSetDuration = totalSetTime / time.Duration(sets)
        }</span>

        <span class="cov3" title="4">return &amp;CacheStats{
                Hits:           hits,
                Misses:         misses,
                Sets:           sets,
                Deletes:        deletes,
                Evictions:      evictions,
                Size:           size,
                AvgGetDuration: avgGetDuration,
                AvgSetDuration: avgSetDuration,
                HitRate:        hitRate,
        }</span>
}

// Close closes the cache and stops background cleanup
func (c *inMemoryCache) Close() error <span class="cov5" title="13">{
        close(c.stopCleanup)
        c.cleanupDone.Wait()
        return nil
}</span>

// cleanupLoop runs background cleanup of expired entries
func (c *inMemoryCache) cleanupLoop() <span class="cov5" title="13">{
        defer c.cleanupDone.Done()

        ticker := time.NewTicker(c.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov6" title="15">{
                select </span>{
                case &lt;-ticker.C:<span class="cov2" title="2">
                        c.cleanup()</span>
                case &lt;-c.stopCleanup:<span class="cov5" title="13">
                        return</span>
                }
        }
}

// cleanup removes expired entries
func (c *inMemoryCache) cleanup() <span class="cov2" title="2">{
        c.mu.Lock()
        defer c.mu.Unlock()

        now := time.Now()
        for key, entry := range c.entries </span><span class="cov2" title="2">{
                if now.After(entry.expiration) </span><span class="cov2" title="2">{
                        c.currentMemory -= int64(entry.size)
                        delete(c.entries, key)
                        c.incrementEvictions()
                }</span>
        }
}

// evictOldest removes the oldest entry (called with lock held)
func (c *inMemoryCache) evictOldest() <span class="cov1" title="1">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.entries </span><span class="cov3" title="3">{
                if oldestTime.IsZero() || entry.expiration.Before(oldestTime) </span><span class="cov2" title="2">{
                        oldestKey = key
                        oldestTime = entry.expiration
                }</span>
        }

        <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                c.currentMemory -= int64(c.entries[oldestKey].size)
                delete(c.entries, oldestKey)
                c.incrementEvictions()
        }</span>
}

// estimateSize estimates the size of a value in bytes
func (c *inMemoryCache) estimateSize(value interface{}) int <span class="cov9" title="118">{
        // Try JSON serialization for size estimation
        if data, err := json.Marshal(value); err == nil </span><span class="cov9" title="118">{
                return len(data)
        }</span>

        // Fallback to rough estimate
        <span class="cov0" title="0">return 100</span> // Default size estimate
}

// Statistics tracking methods
func (c *inMemoryCache) incrementHits() <span class="cov9" title="108">{
        c.statsMu.Lock()
        c.hits++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementMisses() <span class="cov5" title="11">{
        c.statsMu.Lock()
        c.misses++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementSets() <span class="cov9" title="118">{
        c.statsMu.Lock()
        c.sets++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementDeletes() <span class="cov2" title="2">{
        c.statsMu.Lock()
        c.deletes++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementEvictions() <span class="cov3" title="3">{
        c.statsMu.Lock()
        c.evictions++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) trackGetTime(duration time.Duration) <span class="cov10" title="119">{
        c.statsMu.Lock()
        c.totalGetTime += duration
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) trackSetTime(duration time.Duration) <span class="cov9" title="118">{
        c.statsMu.Lock()
        c.totalSetTime += duration
        c.statsMu.Unlock()
}</span>

// BuildCacheKey builds a cache key from components
func BuildCacheKey(components ...string) string <span class="cov3" title="3">{
        key := ""
        for i, component := range components </span><span class="cov3" title="4">{
                if i &gt; 0 </span><span class="cov2" title="2">{
                        key += ":"
                }</span>
                <span class="cov3" title="4">key += component</span>
        }
        <span class="cov3" title="3">return key</span>
}

// CachedQuery executes a query with caching
func CachedQuery[T any](
        ctx context.Context,
        cache Cache,
        key string,
        ttl time.Duration,
        queryFunc func(ctx context.Context) (T, error),
) (T, error) <span class="cov3" title="3">{
        var zero T

        // Try cache first
        if cached, found := cache.Get(ctx, key); found </span><span class="cov1" title="1">{
                if result, ok := cached.(T); ok </span><span class="cov1" title="1">{
                        return result, nil
                }</span>
        }

        // Execute query
        <span class="cov2" title="2">result, err := queryFunc(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return zero, err
        }</span>

        // Store in cache
        <span class="cov1" title="1">_ = cache.Set(ctx, key, result, ttl)

        return result, nil</span>
}

// InvalidatePattern invalidates all cache entries matching a pattern
func InvalidatePattern(ctx context.Context, cache Cache, pattern string) error <span class="cov0" title="0">{
        // Note: This is a simple implementation
        // For production, consider using a cache that supports pattern matching
        return cache.Clear(ctx)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
)

// Config represents the application configuration
type Config struct {
        Log       LogConfig        `json:"log"`
        Listeners []ListenerConfig `json:"listeners"`
        Plugins   []PluginConfig   `json:"plugins"`
        Database  DatabaseConfig   `json:"database"`
        Services  ServicesConfig   `json:"services"`
        WebSocket WebSocketConfig  `json:"websocket"`
        Version   string           `json:"version,omitempty"`
}

// LogConfig represents logging configuration
type LogConfig struct {
        LogPath         string `json:"log_path"`
        LogfileBaseName string `json:"logfile_base_name"`
        LogSizeLimit    int64  `json:"log_size_limit"`
        Level           string `json:"level,omitempty"` // debug, info, warn, error
}

// ListenerConfig represents HTTP listener configuration
type ListenerConfig struct {
        Address  string `json:"address"`
        Port     int    `json:"port"`
        HTTPS    bool   `json:"https"`
        CertFile string `json:"cert_file,omitempty"`
        KeyFile  string `json:"key_file,omitempty"`
}

// PluginConfig represents plugin configuration
type PluginConfig struct {
        Name         string                 `json:"name"`
        Dependencies []string               `json:"dependencies"`
        Config       map[string]interface{} `json:"config"`
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Type             string `json:"type"` // sqlite or postgres
        SQLitePath       string `json:"sqlite_path,omitempty"`
        PostgresHost     string `json:"postgres_host,omitempty"`
        PostgresPort     int    `json:"postgres_port,omitempty"`
        PostgresUser     string `json:"postgres_user,omitempty"`
        PostgresPassword string `json:"postgres_password,omitempty"`
        PostgresDatabase string `json:"postgres_database,omitempty"`
        PostgresSSLMode  string `json:"postgres_ssl_mode,omitempty"`
}

// ServicesConfig represents external services configuration
type ServicesConfig struct {
        Authentication ServiceEndpoint            `json:"authentication"`
        Permissions    ServiceEndpoint            `json:"permissions"`
        Lokalisation   *ServiceEndpoint           `json:"lokalisation,omitempty"`
        Extensions     map[string]ServiceEndpoint `json:"extensions,omitempty"`
}

// ServiceEndpoint represents an external service endpoint
type ServiceEndpoint struct {
        Enabled bool   `json:"enabled"`
        URL     string `json:"url"`
        Timeout int    `json:"timeout,omitempty"` // in seconds
}

// WebSocketConfig represents WebSocket configuration
type WebSocketConfig struct {
        Enabled           bool     `json:"enabled"`
        Path              string   `json:"path"`
        ReadBufferSize    int      `json:"readBufferSize"`
        WriteBufferSize   int      `json:"writeBufferSize"`
        MaxMessageSize    int64    `json:"maxMessageSize"`
        WriteWaitSeconds  int      `json:"writeWaitSeconds"`
        PongWaitSeconds   int      `json:"pongWaitSeconds"`
        PingPeriodSeconds int      `json:"pingPeriodSeconds"`
        MaxClients        int      `json:"maxClients"`
        RequireAuth       bool     `json:"requireAuth"`
        AllowOrigins      []string `json:"allowOrigins"`
        EnableCompression bool     `json:"enableCompression"`
        HandshakeTimeout  int      `json:"handshakeTimeout"`
}

// LoadConfig loads configuration from a JSON file
func LoadConfig(path string) (*Config, error) <span class="cov8" title="7">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov7" title="6">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Apply defaults
        <span class="cov7" title="5">config.applyDefaults()

        // Validate configuration
        if err := config.Validate(); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov5" title="3">return &amp;config, nil</span>
}

// applyDefaults applies default values to missing configuration
func (c *Config) applyDefaults() <span class="cov7" title="6">{
        if c.Log.LogPath == "" </span><span class="cov1" title="1">{
                c.Log.LogPath = "/tmp/htCoreLogs"
        }</span>
        <span class="cov7" title="6">if c.Log.LogSizeLimit == 0 </span><span class="cov7" title="5">{
                c.Log.LogSizeLimit = 100000000 // 100MB
        }</span>
        <span class="cov7" title="6">if c.Log.Level == "" </span><span class="cov7" title="6">{
                c.Log.Level = "info"
        }</span>

        <span class="cov7" title="6">if c.Database.Type == "" </span><span class="cov1" title="1">{
                c.Database.Type = "sqlite"
        }</span>
        <span class="cov7" title="6">if c.Database.Type == "sqlite" &amp;&amp; c.Database.SQLitePath == "" </span><span class="cov1" title="1">{
                c.Database.SQLitePath = "Database/Definition.sqlite"
        }</span>
        <span class="cov7" title="6">if c.Database.Type == "postgres" &amp;&amp; c.Database.PostgresSSLMode == "" </span><span class="cov0" title="0">{
                c.Database.PostgresSSLMode = "disable"
        }</span>

        // Set default timeouts for services
        <span class="cov7" title="6">if c.Services.Authentication.Timeout == 0 </span><span class="cov7" title="6">{
                c.Services.Authentication.Timeout = 30
        }</span>
        <span class="cov7" title="6">if c.Services.Permissions.Timeout == 0 </span><span class="cov7" title="6">{
                c.Services.Permissions.Timeout = 30
        }</span>
        <span class="cov7" title="6">if c.Services.Lokalisation != nil &amp;&amp; c.Services.Lokalisation.Timeout == 0 </span><span class="cov0" title="0">{
                c.Services.Lokalisation.Timeout = 30
        }</span>
        <span class="cov7" title="6">for name, ext := range c.Services.Extensions </span><span class="cov0" title="0">{
                if ext.Timeout == 0 </span><span class="cov0" title="0">{
                        ext.Timeout = 30
                        c.Services.Extensions[name] = ext
                }</span>
        }

        // Set default WebSocket configuration
        <span class="cov7" title="6">if c.WebSocket.Path == "" </span><span class="cov7" title="6">{
                c.WebSocket.Path = "/ws"
        }</span>
        <span class="cov7" title="6">if c.WebSocket.ReadBufferSize == 0 </span><span class="cov7" title="6">{
                c.WebSocket.ReadBufferSize = 1024
        }</span>
        <span class="cov7" title="6">if c.WebSocket.WriteBufferSize == 0 </span><span class="cov7" title="6">{
                c.WebSocket.WriteBufferSize = 1024
        }</span>
        <span class="cov7" title="6">if c.WebSocket.MaxMessageSize == 0 </span><span class="cov7" title="6">{
                c.WebSocket.MaxMessageSize = 512 * 1024 // 512KB
        }</span>
        <span class="cov7" title="6">if c.WebSocket.WriteWaitSeconds == 0 </span><span class="cov7" title="6">{
                c.WebSocket.WriteWaitSeconds = 10
        }</span>
        <span class="cov7" title="6">if c.WebSocket.PongWaitSeconds == 0 </span><span class="cov7" title="6">{
                c.WebSocket.PongWaitSeconds = 60
        }</span>
        <span class="cov7" title="6">if c.WebSocket.PingPeriodSeconds == 0 </span><span class="cov7" title="6">{
                c.WebSocket.PingPeriodSeconds = 54 // Must be less than pongWait
        }</span>
        <span class="cov7" title="6">if c.WebSocket.MaxClients == 0 </span><span class="cov7" title="6">{
                c.WebSocket.MaxClients = 1000
        }</span>
        <span class="cov7" title="6">if c.WebSocket.HandshakeTimeout == 0 </span><span class="cov7" title="6">{
                c.WebSocket.HandshakeTimeout = 10
        }</span>
        <span class="cov7" title="6">if len(c.WebSocket.AllowOrigins) == 0 </span><span class="cov7" title="6">{
                c.WebSocket.AllowOrigins = []string{"*"}
        }</span>
        // RequireAuth defaults to true, Enabled defaults to false
        // No need to set defaults for these booleans
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov10" title="11">{
        if len(c.Listeners) == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("at least one listener must be configured")
        }</span>

        <span class="cov9" title="9">for i, listener := range c.Listeners </span><span class="cov9" title="9">{
                if listener.Address == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("listener %d: address is required", i)
                }</span>
                <span class="cov9" title="9">if listener.Port &lt;= 0 || listener.Port &gt; 65535 </span><span class="cov1" title="1">{
                        return fmt.Errorf("listener %d: invalid port %d", i, listener.Port)
                }</span>
                <span class="cov8" title="8">if listener.HTTPS </span><span class="cov3" title="2">{
                        if listener.CertFile == "" </span><span class="cov1" title="1">{
                                return fmt.Errorf("listener %d: cert_file is required for HTTPS", i)
                        }</span>
                        <span class="cov1" title="1">if listener.KeyFile == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("listener %d: key_file is required for HTTPS", i)
                        }</span>
                }
        }

        <span class="cov8" title="7">if c.Database.Type != "sqlite" &amp;&amp; c.Database.Type != "postgres" </span><span class="cov3" title="2">{
                return fmt.Errorf("database type must be 'sqlite' or 'postgres', got '%s'", c.Database.Type)
        }</span>

        <span class="cov7" title="5">if c.Database.Type == "sqlite" &amp;&amp; c.Database.SQLitePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("sqlite_path is required when using sqlite database")
        }</span>

        <span class="cov7" title="5">if c.Database.Type == "postgres" </span><span class="cov3" title="2">{
                if c.Database.PostgresHost == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("postgres_host is required when using postgres database")
                }</span>
                <span class="cov1" title="1">if c.Database.PostgresPort &lt;= 0 || c.Database.PostgresPort &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid postgres_port: %d", c.Database.PostgresPort)
                }</span>
                <span class="cov1" title="1">if c.Database.PostgresUser == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("postgres_user is required when using postgres database")
                }</span>
                <span class="cov1" title="1">if c.Database.PostgresDatabase == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("postgres_database is required when using postgres database")
                }</span>
        }

        // Validate service endpoints
        <span class="cov6" title="4">if c.Services.Authentication.Enabled &amp;&amp; c.Services.Authentication.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication service URL is required when enabled")
        }</span>
        <span class="cov6" title="4">if c.Services.Permissions.Enabled &amp;&amp; c.Services.Permissions.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("permissions service URL is required when enabled")
        }</span>

        <span class="cov6" title="4">return nil</span>
}

// GetPrimaryListener returns the first configured listener
func (c *Config) GetPrimaryListener() *ListenerConfig <span class="cov6" title="4">{
        if len(c.Listeners) &gt; 0 </span><span class="cov3" title="2">{
                return &amp;c.Listeners[0]
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// GetListenerAddress returns the full address of the primary listener
func (c *Config) GetListenerAddress() string <span class="cov3" title="2">{
        listener := c.GetPrimaryListener()
        if listener == nil </span><span class="cov1" title="1">{
                return ":8080"
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s:%d", listener.Address, listener.Port)</span>
}

// GetWebSocketConfig converts config WebSocketConfig to models.WebSocketConfig
func (c *Config) GetWebSocketConfig() WebSocketConfig <span class="cov0" title="0">{
        return c.WebSocket
}</span>

// IsWebSocketEnabled returns whether WebSocket is enabled
func (c *Config) IsWebSocketEnabled() bool <span class="cov0" title="0">{
        return c.WebSocket.Enabled
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"

        _ "github.com/lib/pq"           // PostgreSQL driver
        _ "github.com/mattn/go-sqlite3" // SQLite driver
        "helixtrack.ru/core/internal/config"
)

// Database represents a database connection interface
type Database interface {
        // Query executes a query that returns rows
        Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)

        // QueryRow executes a query that returns a single row
        QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row

        // Exec executes a query that doesn't return rows
        Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error)

        // Begin starts a transaction
        Begin(ctx context.Context) (*sql.Tx, error)

        // Close closes the database connection
        Close() error

        // Ping verifies the database connection
        Ping(ctx context.Context) error

        // GetType returns the database type (sqlite or postgres)
        GetType() string
}

// db is the concrete implementation of Database interface
type db struct {
        conn   *sql.DB
        dbType string
}

// NewDatabase creates a new database connection based on configuration
func NewDatabase(cfg config.DatabaseConfig) (Database, error) <span class="cov6" title="54">{
        var conn *sql.DB
        var err error

        switch cfg.Type </span>{
        case "sqlite":<span class="cov6" title="53">
                conn, err = sql.Open("sqlite3", cfg.SQLitePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open sqlite database: %w", err)
                }</span>

                // Enable foreign keys for SQLite
                <span class="cov6" title="53">_, err = conn.Exec("PRAGMA foreign_keys = ON")
                if err != nil </span><span class="cov1" title="1">{
                        conn.Close()
                        return nil, fmt.Errorf("failed to enable foreign keys: %w", err)
                }</span>

                // Configure connection pool for SQLite
                <span class="cov6" title="52">conn.SetMaxOpenConns(1)</span> // SQLite only supports one write connection

        case "postgres":<span class="cov0" title="0">
                connStr := fmt.Sprintf(
                        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                        cfg.PostgresHost,
                        cfg.PostgresPort,
                        cfg.PostgresUser,
                        cfg.PostgresPassword,
                        cfg.PostgresDatabase,
                        cfg.PostgresSSLMode,
                )

                conn, err = sql.Open("postgres", connStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open postgres database: %w", err)
                }</span>

                // Configure connection pool for PostgreSQL
                <span class="cov0" title="0">conn.SetMaxOpenConns(25)
                conn.SetMaxIdleConns(5)</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported database type: %s", cfg.Type)</span>
        }

        // Verify connection
        <span class="cov6" title="52">if err := conn.Ping(); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov6" title="52">return &amp;db{
                conn:   conn,
                dbType: cfg.Type,
        }, nil</span>
}

// Query executes a query that returns rows
func (d *db) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov4" title="11">{
        return d.conn.QueryContext(ctx, query, args...)
}</span>

// QueryRow executes a query that returns a single row
func (d *db) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov5" title="26">{
        return d.conn.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a query that doesn't return rows
func (d *db) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov10" title="1043">{
        return d.conn.ExecContext(ctx, query, args...)
}</span>

// Begin starts a transaction
func (d *db) Begin(ctx context.Context) (*sql.Tx, error) <span class="cov1" title="2">{
        return d.conn.BeginTx(ctx, nil)
}</span>

// Close closes the database connection
func (d *db) Close() error <span class="cov6" title="52">{
        return d.conn.Close()
}</span>

// Ping verifies the database connection
func (d *db) Ping(ctx context.Context) error <span class="cov2" title="3">{
        return d.conn.PingContext(ctx)
}</span>

// GetType returns the database type
func (d *db) GetType() string <span class="cov1" title="2">{
        return d.dbType
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "helixtrack.ru/core/internal/models"
)

// Ensure db implements DocumentDatabase interface
var _ DocumentDatabase = (*db)(nil)

// ========================================================================
// CORE DOCUMENT OPERATIONS
// ========================================================================

// CreateDocument creates a new document
func (d *db) CreateDocument(doc *models.Document) error <span class="cov10" title="21">{
        if err := doc.Validate(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid document: %w", err)
        }</span>

        <span class="cov9" title="20">doc.SetTimestamps()

        query := `
                INSERT INTO document (
                        id, title, space_id, parent_id, type_id, project_id,
                        creator_id, version, position, is_published, is_archived,
                        publish_date, created, modified, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                doc.ID, doc.Title, doc.SpaceID, doc.ParentID, doc.TypeID, doc.ProjectID,
                doc.CreatorID, doc.Version, doc.Position, doc.IsPublished, doc.IsArchived,
                doc.PublishDate, doc.Created, doc.Modified, doc.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document: %w", err)
        }</span>

        <span class="cov9" title="20">return nil</span>
}

// GetDocument retrieves a document by ID
func (d *db) GetDocument(id string) (*models.Document, error) <span class="cov8" title="11">{
        query := `
                SELECT id, title, space_id, parent_id, type_id, project_id,
                           creator_id, version, position, is_published, is_archived,
                           publish_date, created, modified, deleted
                FROM document
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, id)

        doc := &amp;models.Document{}
        err := row.Scan(
                &amp;doc.ID, &amp;doc.Title, &amp;doc.SpaceID, &amp;doc.ParentID, &amp;doc.TypeID, &amp;doc.ProjectID,
                &amp;doc.CreatorID, &amp;doc.Version, &amp;doc.Position, &amp;doc.IsPublished, &amp;doc.IsArchived,
                &amp;doc.PublishDate, &amp;doc.Created, &amp;doc.Modified, &amp;doc.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("document not found: %s", id)
        }</span>
        <span class="cov7" title="9">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document: %w", err)
        }</span>

        <span class="cov7" title="9">return doc, nil</span>
}

// ListDocuments lists documents with optional filters
func (d *db) ListDocuments(filters map[string]interface{}, limit, offset int) ([]*models.Document, error) <span class="cov5" title="5">{
        query := `
                SELECT id, title, space_id, parent_id, type_id, project_id,
                           creator_id, version, position, is_published, is_archived,
                           publish_date, created, modified, deleted
                FROM document
                WHERE deleted = 0
        `

        args := []interface{}{}

        // Apply filters
        if spaceID, ok := filters["space_id"].(string); ok &amp;&amp; spaceID != "" </span><span class="cov1" title="1">{
                query += " AND space_id = ?"
                args = append(args, spaceID)
        }</span>

        <span class="cov5" title="5">if projectID, ok := filters["project_id"].(string); ok &amp;&amp; projectID != "" </span><span class="cov0" title="0">{
                query += " AND project_id = ?"
                args = append(args, projectID)
        }</span>

        <span class="cov5" title="5">if parentID, ok := filters["parent_id"].(string); ok &amp;&amp; parentID != "" </span><span class="cov1" title="1">{
                query += " AND parent_id = ?"
                args = append(args, parentID)
        }</span>

        <span class="cov5" title="5">if isPublished, ok := filters["is_published"].(bool); ok </span><span class="cov0" title="0">{
                query += " AND is_published = ?"
                args = append(args, isPublished)
        }</span>

        <span class="cov5" title="5">if isArchived, ok := filters["is_archived"].(bool); ok </span><span class="cov0" title="0">{
                query += " AND is_archived = ?"
                args = append(args, isArchived)
        }</span>

        // Add ordering
        <span class="cov5" title="5">query += " ORDER BY created DESC"

        // Add pagination
        if limit &gt; 0 </span><span class="cov3" title="2">{
                query += " LIMIT ?"
                args = append(args, limit)
        }</span>
        <span class="cov5" title="5">if offset &gt; 0 </span><span class="cov1" title="1">{
                query += " OFFSET ?"
                args = append(args, offset)
        }</span>

        <span class="cov5" title="5">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list documents: %w", err)
        }</span>
        <span class="cov5" title="5">defer rows.Close()

        documents := []*models.Document{}
        for rows.Next() </span><span class="cov8" title="12">{
                doc := &amp;models.Document{}
                err := rows.Scan(
                        &amp;doc.ID, &amp;doc.Title, &amp;doc.SpaceID, &amp;doc.ParentID, &amp;doc.TypeID, &amp;doc.ProjectID,
                        &amp;doc.CreatorID, &amp;doc.Version, &amp;doc.Position, &amp;doc.IsPublished, &amp;doc.IsArchived,
                        &amp;doc.PublishDate, &amp;doc.Created, &amp;doc.Modified, &amp;doc.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document: %w", err)
                }</span>
                <span class="cov8" title="12">documents = append(documents, doc)</span>
        }

        <span class="cov5" title="5">return documents, nil</span>
}

// UpdateDocument updates an existing document (with optimistic locking)
func (d *db) UpdateDocument(doc *models.Document) error <span class="cov4" title="3">{
        if err := doc.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document: %w", err)
        }</span>

        <span class="cov4" title="3">doc.SetTimestamps()

        // Optimistic locking: check version matches
        query := `
                UPDATE document
                SET title = ?, space_id = ?, parent_id = ?, type_id = ?, project_id = ?,
                        version = ?, position = ?, is_published = ?, is_archived = ?,
                        publish_date = ?, modified = ?
                WHERE id = ? AND version = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        currentVersion := doc.Version
        doc.IncrementVersion() // Increment version for optimistic locking

        result, err := d.Exec(ctx, query,
                doc.Title, doc.SpaceID, doc.ParentID, doc.TypeID, doc.ProjectID,
                doc.Version, doc.Position, doc.IsPublished, doc.IsArchived,
                doc.PublishDate, doc.Modified,
                doc.ID, currentVersion,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document: %w", err)
        }</span>

        <span class="cov4" title="3">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov4" title="3">if rowsAffected == 0 </span><span class="cov1" title="1">{
                return errors.New("version conflict: document was modified by another user")
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// DeleteDocument soft-deletes a document
func (d *db) DeleteDocument(id string) error <span class="cov4" title="3">{
        query := `UPDATE document SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document: %w", err)
        }</span>

        <span class="cov4" title="3">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov4" title="3">if rowsAffected == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// RestoreDocument restores a soft-deleted document
func (d *db) RestoreDocument(id string) error <span class="cov1" title="1">{
        query := `UPDATE document SET deleted = 0, modified = ? WHERE id = ? AND deleted = 1`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore document: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("deleted document not found: %s", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ArchiveDocument archives a document
func (d *db) ArchiveDocument(id string) error <span class="cov3" title="2">{
        query := `UPDATE document SET is_archived = 1, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to archive document: %w", err)
        }</span>

        <span class="cov3" title="2">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov3" title="2">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// UnarchiveDocument unarchives a document
func (d *db) UnarchiveDocument(id string) error <span class="cov1" title="1">{
        query := `UPDATE document SET is_archived = 0, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unarchive document: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DuplicateDocument creates a copy of a document
func (d *db) DuplicateDocument(id string, newTitle string, userID string) (*models.Document, error) <span class="cov0" title="0">{
        // Get original document
        original, err := d.GetDocument(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get original document: %w", err)
        }</span>

        // Create new document with copied data
        <span class="cov0" title="0">duplicate := &amp;models.Document{
                ID:          generateUUID(), // You'll need to implement this
                Title:       newTitle,
                SpaceID:     original.SpaceID,
                ParentID:    original.ParentID,
                TypeID:      original.TypeID,
                ProjectID:   original.ProjectID,
                CreatorID:   userID,
                Version:     1,
                Position:    original.Position,
                IsPublished: false, // New doc starts as draft
                IsArchived:  false,
                PublishDate: nil,
        }

        if err := d.CreateDocument(duplicate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create duplicate: %w", err)
        }</span>

        // Copy content
        <span class="cov0" title="0">content, err := d.GetLatestDocumentContent(id)
        if err == nil &amp;&amp; content != nil </span><span class="cov0" title="0">{
                newContent := &amp;models.DocumentContent{
                        ID:          generateUUID(),
                        DocumentID:  duplicate.ID,
                        Version:     1,
                        ContentType: content.ContentType,
                        Content:     content.Content,
                        ContentHash: content.ContentHash,
                        SizeBytes:   content.SizeBytes,
                }
                _ = d.CreateDocumentContent(newContent) // Ignore error
        }</span>

        <span class="cov0" title="0">return duplicate, nil</span>
}

// MoveDocument moves a document to a different space
func (d *db) MoveDocument(id string, newSpaceID string) error <span class="cov1" title="1">{
        query := `UPDATE document SET space_id = ?, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, newSpaceID, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to move document: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// SetDocumentParent sets the parent document for hierarchy
func (d *db) SetDocumentParent(id string, parentID string) error <span class="cov1" title="1">{
        query := `UPDATE document SET parent_id = ?, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, parentID, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set parent: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetDocumentChildren gets all child documents
func (d *db) GetDocumentChildren(id string) ([]*models.Document, error) <span class="cov1" title="1">{
        filters := map[string]interface{}{
                "parent_id": id,
        }
        return d.ListDocuments(filters, 0, 0)
}</span>

// Placeholder for UUID generation
func generateUUID() string <span class="cov1" title="1">{
        // TODO: Implement proper UUID generation
        // For now, return a placeholder
        return fmt.Sprintf("doc-%d", time.Now().UnixNano())
}</span>

// ========================================================================
// DOCUMENT CONTENT OPERATIONS
// ========================================================================

// CreateDocumentContent creates document content
func (d *db) CreateDocumentContent(content *models.DocumentContent) error <span class="cov5" title="5">{
        if err := content.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document content: %w", err)
        }</span>

        <span class="cov5" title="5">content.SetTimestamps()

        query := `
                INSERT INTO document_content (
                        id, document_id, version, content_type, content, content_hash,
                        size_bytes, created, modified, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                content.ID, content.DocumentID, content.Version, content.ContentType, content.Content,
                content.ContentHash, content.SizeBytes, content.Created, content.Modified, content.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document content: %w", err)
        }</span>

        <span class="cov5" title="5">return nil</span>
}

// GetDocumentContent gets content for a specific version
func (d *db) GetDocumentContent(documentID string, version int) (*models.DocumentContent, error) <span class="cov1" title="1">{
        query := `
                SELECT id, document_id, version, content_type, content, content_hash,
                           size_bytes, created, modified, deleted
                FROM document_content
                WHERE document_id = ? AND version = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, documentID, version)

        content := &amp;models.DocumentContent{}
        err := row.Scan(
                &amp;content.ID, &amp;content.DocumentID, &amp;content.Version, &amp;content.ContentType, &amp;content.Content,
                &amp;content.ContentHash, &amp;content.SizeBytes, &amp;content.Created, &amp;content.Modified, &amp;content.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("content not found for document: %s version: %d", documentID, version)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document content: %w", err)
        }</span>

        <span class="cov1" title="1">return content, nil</span>
}

// GetLatestDocumentContent gets the latest content
func (d *db) GetLatestDocumentContent(documentID string) (*models.DocumentContent, error) <span class="cov1" title="1">{
        query := `
                SELECT id, document_id, version, content_type, content, content_hash,
                           size_bytes, created, modified, deleted
                FROM document_content
                WHERE document_id = ? AND deleted = 0
                ORDER BY version DESC
                LIMIT 1
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, documentID)

        content := &amp;models.DocumentContent{}
        err := row.Scan(
                &amp;content.ID, &amp;content.DocumentID, &amp;content.Version, &amp;content.ContentType, &amp;content.Content,
                &amp;content.ContentHash, &amp;content.SizeBytes, &amp;content.Created, &amp;content.Modified, &amp;content.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("content not found for document: %s", documentID)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get latest document content: %w", err)
        }</span>

        <span class="cov1" title="1">return content, nil</span>
}

// UpdateDocumentContent updates document content
func (d *db) UpdateDocumentContent(content *models.DocumentContent) error <span class="cov0" title="0">{
        if err := content.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document content: %w", err)
        }</span>

        <span class="cov0" title="0">content.SetTimestamps()

        query := `
                UPDATE document_content
                SET content = ?, content_hash = ?, size_bytes = ?, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query,
                content.Content, content.ContentHash, content.SizeBytes, content.Modified, content.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document content: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document content not found: %s", content.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========================================================================
// DOCUMENT SPACE OPERATIONS
// ========================================================================

// CreateDocumentSpace creates a new document space
func (d *db) CreateDocumentSpace(space *models.DocumentSpace) error <span class="cov5" title="4">{
        if err := space.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document space: %w", err)
        }</span>

        <span class="cov5" title="4">space.SetTimestamps()

        query := `
                INSERT INTO document_space (
                        id, key, name, description, owner_id, is_public,
                        created, modified, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                space.ID, space.Key, space.Name, space.Description, space.OwnerID,
                space.IsPublic, space.Created, space.Modified, space.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document space: %w", err)
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// GetDocumentSpace retrieves a space by ID
func (d *db) GetDocumentSpace(id string) (*models.DocumentSpace, error) <span class="cov1" title="1">{
        query := `
                SELECT id, key, name, description, owner_id, is_public,
                           created, modified, deleted
                FROM document_space
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, id)

        space := &amp;models.DocumentSpace{}
        err := row.Scan(
                &amp;space.ID, &amp;space.Key, &amp;space.Name, &amp;space.Description, &amp;space.OwnerID,
                &amp;space.IsPublic, &amp;space.Created, &amp;space.Modified, &amp;space.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document space not found: %s", id)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document space: %w", err)
        }</span>

        <span class="cov1" title="1">return space, nil</span>
}

// ListDocumentSpaces lists all document spaces
func (d *db) ListDocumentSpaces(filters map[string]interface{}) ([]*models.DocumentSpace, error) <span class="cov1" title="1">{
        query := `
                SELECT id, key, name, description, owner_id, is_public,
                           created, modified, deleted
                FROM document_space
                WHERE deleted = 0
        `

        args := []interface{}{}

        // Apply filters
        if ownerID, ok := filters["owner_id"].(string); ok &amp;&amp; ownerID != "" </span><span class="cov0" title="0">{
                query += " AND owner_id = ?"
                args = append(args, ownerID)
        }</span>

        <span class="cov1" title="1">if isPublic, ok := filters["is_public"].(bool); ok </span><span class="cov0" title="0">{
                query += " AND is_public = ?"
                args = append(args, isPublic)
        }</span>

        <span class="cov1" title="1">query += " ORDER BY created DESC"

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list document spaces: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        spaces := []*models.DocumentSpace{}
        for rows.Next() </span><span class="cov3" title="2">{
                space := &amp;models.DocumentSpace{}
                err := rows.Scan(
                        &amp;space.ID, &amp;space.Key, &amp;space.Name, &amp;space.Description, &amp;space.OwnerID,
                        &amp;space.IsPublic, &amp;space.Created, &amp;space.Modified, &amp;space.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document space: %w", err)
                }</span>
                <span class="cov3" title="2">spaces = append(spaces, space)</span>
        }

        <span class="cov1" title="1">return spaces, nil</span>
}

// UpdateDocumentSpace updates a space
func (d *db) UpdateDocumentSpace(space *models.DocumentSpace) error <span class="cov0" title="0">{
        if err := space.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document space: %w", err)
        }</span>

        <span class="cov0" title="0">space.SetTimestamps()

        query := `
                UPDATE document_space
                SET name = ?, description = ?, owner_id = ?, is_public = ?, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query,
                space.Name, space.Description, space.OwnerID, space.IsPublic, space.Modified, space.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document space: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document space not found: %s", space.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteDocumentSpace deletes a space
func (d *db) DeleteDocumentSpace(id string) error <span class="cov0" title="0">{
        query := `UPDATE document_space SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document space: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document space not found: %s", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========================================================================
// DOCUMENT VERSION OPERATIONS
// ========================================================================

// CreateDocumentVersion creates a new version record
func (d *db) CreateDocumentVersion(version *models.DocumentVersion) error <span class="cov0" title="0">{
        if err := version.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document version: %w", err)
        }</span>

        <span class="cov0" title="0">version.SetTimestamps()

        query := `
                INSERT INTO document_version (
                        id, document_id, version_number, user_id, change_summary,
                        is_major, is_minor, snapshot_json, content_id, created
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                version.ID, version.DocumentID, version.VersionNumber, version.UserID, version.ChangeSummary,
                version.IsMajor, version.IsMinor, version.SnapshotJSON, version.ContentID, version.Created,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document version: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentVersion gets a specific version
func (d *db) GetDocumentVersion(id string) (*models.DocumentVersion, error) <span class="cov0" title="0">{
        query := `
                SELECT id, document_id, version_number, user_id, change_summary,
                           is_major, is_minor, snapshot_json, content_id, created
                FROM document_version
                WHERE id = ?
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, id)

        version := &amp;models.DocumentVersion{}
        err := row.Scan(
                &amp;version.ID, &amp;version.DocumentID, &amp;version.VersionNumber, &amp;version.UserID, &amp;version.ChangeSummary,
                &amp;version.IsMajor, &amp;version.IsMinor, &amp;version.SnapshotJSON, &amp;version.ContentID, &amp;version.Created,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document version not found: %s", id)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document version: %w", err)
        }</span>

        <span class="cov0" title="0">return version, nil</span>
}

// ListDocumentVersions lists all versions for a document
func (d *db) ListDocumentVersions(documentID string) ([]*models.DocumentVersion, error) <span class="cov0" title="0">{
        query := `
                SELECT id, document_id, version_number, user_id, change_summary,
                           is_major, is_minor, snapshot_json, content_id, created
                FROM document_version
                WHERE document_id = ?
                ORDER BY version_number DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list document versions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        versions := []*models.DocumentVersion{}
        for rows.Next() </span><span class="cov0" title="0">{
                version := &amp;models.DocumentVersion{}
                err := rows.Scan(
                        &amp;version.ID, &amp;version.DocumentID, &amp;version.VersionNumber, &amp;version.UserID, &amp;version.ChangeSummary,
                        &amp;version.IsMajor, &amp;version.IsMinor, &amp;version.SnapshotJSON, &amp;version.ContentID, &amp;version.Created,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document version: %w", err)
                }</span>
                <span class="cov0" title="0">versions = append(versions, version)</span>
        }

        <span class="cov0" title="0">return versions, nil</span>
}

// RestoreDocumentVersion restores a document to a specific version
func (d *db) RestoreDocumentVersion(documentID string, versionNumber int, userID string) error <span class="cov0" title="0">{
        // Get the version to restore
        query := `
                SELECT content_id, snapshot_json
                FROM document_version
                WHERE document_id = ? AND version_number = ?
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        var contentID, snapshotJSON *string
        err := d.QueryRow(ctx, query, documentID, versionNumber).Scan(&amp;contentID, &amp;snapshotJSON)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("version not found: document=%s version=%d", documentID, versionNumber)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get version: %w", err)
        }</span>

        // Get current document to increment version
        <span class="cov0" title="0">doc, err := d.GetDocument(documentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get document: %w", err)
        }</span>

        // Create new version record for the restore
        <span class="cov0" title="0">newVersion := &amp;models.DocumentVersion{
                ID:            generateUUID(),
                DocumentID:    documentID,
                VersionNumber: doc.Version + 1,
                UserID:        userID,
                ChangeSummary: stringPtr(fmt.Sprintf("Restored to version %d", versionNumber)),
                IsMajor:       false,
                IsMinor:       true,
                SnapshotJSON:  snapshotJSON,
                ContentID:     contentID,
        }

        if err := d.CreateDocumentVersion(newVersion); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create restore version: %w", err)
        }</span>

        // Update document version
        <span class="cov0" title="0">doc.IncrementVersion()
        if err := d.UpdateDocument(doc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper function to create string pointer
func stringPtr(s string) *string <span class="cov5" title="4">{
        return &amp;s
}</span>

// ========================================================================
// COLLABORATION OPERATIONS
// ========================================================================

// CreateCommentDocumentMapping creates a comment-document link
func (d *db) CreateCommentDocumentMapping(mapping *models.CommentDocumentMapping) error <span class="cov0" title="0">{
        if err := mapping.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid comment-document mapping: %w", err)
        }</span>

        <span class="cov0" title="0">mapping.SetTimestamps()

        query := `
                INSERT INTO comment_document_mapping (
                        id, comment_id, document_id, user_id, is_resolved, created, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                mapping.ID, mapping.CommentID, mapping.DocumentID, mapping.UserID,
                mapping.IsResolved, mapping.Created, mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create comment-document mapping: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentComments gets all comments for a document
func (d *db) GetDocumentComments(documentID string) ([]*models.CommentDocumentMapping, error) <span class="cov0" title="0">{
        query := `
                SELECT id, comment_id, document_id, user_id, is_resolved, created, deleted
                FROM comment_document_mapping
                WHERE document_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document comments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        comments := []*models.CommentDocumentMapping{}
        for rows.Next() </span><span class="cov0" title="0">{
                comment := &amp;models.CommentDocumentMapping{}
                err := rows.Scan(
                        &amp;comment.ID, &amp;comment.CommentID, &amp;comment.DocumentID, &amp;comment.UserID,
                        &amp;comment.IsResolved, &amp;comment.Created, &amp;comment.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan comment mapping: %w", err)
                }</span>
                <span class="cov0" title="0">comments = append(comments, comment)</span>
        }

        <span class="cov0" title="0">return comments, nil</span>
}

// CreateDocumentWatcher creates a watcher subscription
func (d *db) CreateDocumentWatcher(watcher *models.DocumentWatcher) error <span class="cov5" title="4">{
        if err := watcher.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document watcher: %w", err)
        }</span>

        <span class="cov5" title="4">watcher.SetTimestamps()

        query := `
                INSERT INTO document_watcher (
                        id, document_id, user_id, notification_level, created
                ) VALUES (?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                watcher.ID, watcher.DocumentID, watcher.UserID,
                watcher.NotificationLevel, watcher.Created,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document watcher: %w", err)
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// GetDocumentWatchers gets all watchers for a document
func (d *db) GetDocumentWatchers(documentID string) ([]*models.DocumentWatcher, error) <span class="cov1" title="1">{
        query := `
                SELECT id, document_id, user_id, notification_level, created
                FROM document_watcher
                WHERE document_id = ?
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document watchers: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        watchers := []*models.DocumentWatcher{}
        for rows.Next() </span><span class="cov3" title="2">{
                watcher := &amp;models.DocumentWatcher{}
                err := rows.Scan(
                        &amp;watcher.ID, &amp;watcher.DocumentID, &amp;watcher.UserID,
                        &amp;watcher.NotificationLevel, &amp;watcher.Created,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document watcher: %w", err)
                }</span>
                <span class="cov3" title="2">watchers = append(watchers, watcher)</span>
        }

        <span class="cov1" title="1">return watchers, nil</span>
}

// DeleteDocumentWatcher removes a watcher
func (d *db) DeleteDocumentWatcher(documentID, userID string) error <span class="cov1" title="1">{
        query := `DELETE FROM document_watcher WHERE document_id = ? AND user_id = ?`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, documentID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document watcher: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("watcher not found: document=%s user=%s", documentID, userID)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ========================================================================
// VOTE/REACTION OPERATIONS (Generic System)
// ========================================================================

// CreateVoteMapping creates a vote/reaction
func (d *db) CreateVoteMapping(vote *models.VoteMapping) error <span class="cov0" title="0">{
        if err := vote.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid vote mapping: %w", err)
        }</span>

        <span class="cov0" title="0">vote.SetTimestamps()

        query := `
                INSERT INTO vote_mapping (
                        id, entity_type, entity_id, user_id, vote_type, emoji, created, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                vote.ID, vote.EntityType, vote.EntityID, vote.UserID,
                vote.VoteType, vote.Emoji, vote.Created, vote.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create vote mapping: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetEntityVotes gets all votes for an entity
func (d *db) GetEntityVotes(entityType, entityID string) ([]*models.VoteMapping, error) <span class="cov0" title="0">{
        query := `
                SELECT id, entity_type, entity_id, user_id, vote_type, emoji, created, deleted
                FROM vote_mapping
                WHERE entity_type = ? AND entity_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get entity votes: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        votes := []*models.VoteMapping{}
        for rows.Next() </span><span class="cov0" title="0">{
                vote := &amp;models.VoteMapping{}
                err := rows.Scan(
                        &amp;vote.ID, &amp;vote.EntityType, &amp;vote.EntityID, &amp;vote.UserID,
                        &amp;vote.VoteType, &amp;vote.Emoji, &amp;vote.Created, &amp;vote.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan vote mapping: %w", err)
                }</span>
                <span class="cov0" title="0">votes = append(votes, vote)</span>
        }

        <span class="cov0" title="0">return votes, nil</span>
}

// GetVoteCount gets vote count for an entity
func (d *db) GetVoteCount(entityType, entityID string) (int, error) <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) FROM vote_mapping
                WHERE entity_type = ? AND entity_id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        var count int
        err := d.QueryRow(ctx, query, entityType, entityID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get vote count: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// ========================================================================
// VERSION LABELS, TAGS, COMMENTS, MENTIONS, DIFFS
// ========================================================================

// CreateVersionLabel creates a label for a version
func (d *db) CreateVersionLabel(label *models.DocumentVersionLabel) error <span class="cov0" title="0">{
        if err := label.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid version label: %w", err)
        }</span>

        <span class="cov0" title="0">label.SetTimestamps()

        query := `
                INSERT INTO document_version_label (
                        id, version_id, label, description, user_id, created
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                label.ID, label.VersionID, label.Label, label.Description,
                label.UserID, label.Created,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create version label: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetVersionLabels gets all labels for a version
func (d *db) GetVersionLabels(versionID string) ([]*models.DocumentVersionLabel, error) <span class="cov0" title="0">{
        query := `
                SELECT id, version_id, label, description, user_id, created
                FROM document_version_label
                WHERE version_id = ?
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, versionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get version labels: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        labels := []*models.DocumentVersionLabel{}
        for rows.Next() </span><span class="cov0" title="0">{
                label := &amp;models.DocumentVersionLabel{}
                err := rows.Scan(
                        &amp;label.ID, &amp;label.VersionID, &amp;label.Label, &amp;label.Description,
                        &amp;label.UserID, &amp;label.Created,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan version label: %w", err)
                }</span>
                <span class="cov0" title="0">labels = append(labels, label)</span>
        }

        <span class="cov0" title="0">return labels, nil</span>
}

// CreateVersionTag creates a tag for a version
func (d *db) CreateVersionTag(tag *models.DocumentVersionTag) error <span class="cov0" title="0">{
        if err := tag.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid version tag: %w", err)
        }</span>

        <span class="cov0" title="0">tag.SetTimestamps()

        query := `
                INSERT INTO document_version_tag (
                        id, version_id, tag, user_id, created
                ) VALUES (?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                tag.ID, tag.VersionID, tag.Tag, tag.UserID, tag.Created,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create version tag: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetVersionTags gets all tags for a version
func (d *db) GetVersionTags(versionID string) ([]*models.DocumentVersionTag, error) <span class="cov0" title="0">{
        query := `
                SELECT id, version_id, tag, user_id, created
                FROM document_version_tag
                WHERE version_id = ?
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, versionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get version tags: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tags := []*models.DocumentVersionTag{}
        for rows.Next() </span><span class="cov0" title="0">{
                tag := &amp;models.DocumentVersionTag{}
                err := rows.Scan(
                        &amp;tag.ID, &amp;tag.VersionID, &amp;tag.Tag, &amp;tag.UserID, &amp;tag.Created,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan version tag: %w", err)
                }</span>
                <span class="cov0" title="0">tags = append(tags, tag)</span>
        }

        <span class="cov0" title="0">return tags, nil</span>
}

// CreateVersionComment creates a comment on a version
func (d *db) CreateVersionComment(comment *models.DocumentVersionComment) error <span class="cov0" title="0">{
        if err := comment.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid version comment: %w", err)
        }</span>

        <span class="cov0" title="0">comment.SetTimestamps()

        query := `
                INSERT INTO document_version_comment (
                        id, version_id, user_id, comment, created, modified, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                comment.ID, comment.VersionID, comment.UserID, comment.Comment,
                comment.Created, comment.Modified, comment.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create version comment: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetVersionComments gets all comments for a version
func (d *db) GetVersionComments(versionID string) ([]*models.DocumentVersionComment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, version_id, user_id, comment, created, modified, deleted
                FROM document_version_comment
                WHERE version_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, versionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get version comments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        comments := []*models.DocumentVersionComment{}
        for rows.Next() </span><span class="cov0" title="0">{
                comment := &amp;models.DocumentVersionComment{}
                err := rows.Scan(
                        &amp;comment.ID, &amp;comment.VersionID, &amp;comment.UserID, &amp;comment.Comment,
                        &amp;comment.Created, &amp;comment.Modified, &amp;comment.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan version comment: %w", err)
                }</span>
                <span class="cov0" title="0">comments = append(comments, comment)</span>
        }

        <span class="cov0" title="0">return comments, nil</span>
}

// CreateVersionMention creates a mention in a version
func (d *db) CreateVersionMention(mention *models.DocumentVersionMention) error <span class="cov0" title="0">{
        if err := mention.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid version mention: %w", err)
        }</span>

        <span class="cov0" title="0">mention.SetTimestamps()

        query := `
                INSERT INTO document_version_mention (
                        id, version_id, mentioned_user_id, mentioning_user_id,
                        context, created
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                mention.ID, mention.VersionID, mention.MentionedUserID,
                mention.MentioningUserID, mention.Context, mention.Created,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create version mention: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetVersionMentions gets all mentions for a version
func (d *db) GetVersionMentions(versionID string) ([]*models.DocumentVersionMention, error) <span class="cov0" title="0">{
        query := `
                SELECT id, version_id, mentioned_user_id, mentioning_user_id,
                           context, created
                FROM document_version_mention
                WHERE version_id = ?
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, versionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get version mentions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        mentions := []*models.DocumentVersionMention{}
        for rows.Next() </span><span class="cov0" title="0">{
                mention := &amp;models.DocumentVersionMention{}
                err := rows.Scan(
                        &amp;mention.ID, &amp;mention.VersionID, &amp;mention.MentionedUserID,
                        &amp;mention.MentioningUserID, &amp;mention.Context, &amp;mention.Created,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan version mention: %w", err)
                }</span>
                <span class="cov0" title="0">mentions = append(mentions, mention)</span>
        }

        <span class="cov0" title="0">return mentions, nil</span>
}

// GetVersionDiff gets cached diff between versions
func (d *db) GetVersionDiff(documentID string, fromVersion, toVersion int, diffType string) (*models.DocumentVersionDiff, error) <span class="cov0" title="0">{
        query := `
                SELECT id, document_id, from_version, to_version, diff_type,
                           diff_content, created
                FROM document_version_diff
                WHERE document_id = ? AND from_version = ? AND to_version = ? AND diff_type = ?
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, documentID, fromVersion, toVersion, diffType)

        diff := &amp;models.DocumentVersionDiff{}
        err := row.Scan(
                &amp;diff.ID, &amp;diff.DocumentID, &amp;diff.FromVersion, &amp;diff.ToVersion,
                &amp;diff.DiffType, &amp;diff.DiffContent, &amp;diff.Created,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("diff not found: document=%s from=%d to=%d type=%s", documentID, fromVersion, toVersion, diffType)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get version diff: %w", err)
        }</span>

        <span class="cov0" title="0">return diff, nil</span>
}

// CreateVersionDiff creates a cached diff
func (d *db) CreateVersionDiff(diff *models.DocumentVersionDiff) error <span class="cov0" title="0">{
        if err := diff.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid version diff: %w", err)
        }</span>

        <span class="cov0" title="0">diff.SetTimestamps()

        query := `
                INSERT INTO document_version_diff (
                        id, document_id, from_version, to_version, diff_type,
                        diff_content, created
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                diff.ID, diff.DocumentID, diff.FromVersion, diff.ToVersion,
                diff.DiffType, diff.DiffContent, diff.Created,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create version diff: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CompareDocumentVersions compares two versions (generates diff if not cached)
func (d *db) CompareDocumentVersions(documentID string, fromVersion, toVersion int) (*models.DocumentVersionDiff, error) <span class="cov0" title="0">{
        // Try to get cached diff first
        diff, err := d.GetVersionDiff(documentID, fromVersion, toVersion, "unified")
        if err == nil </span><span class="cov0" title="0">{
                return diff, nil
        }</span>

        // If not cached, we'd generate it here
        // For now, return error indicating it needs to be generated
        <span class="cov0" title="0">return nil, fmt.Errorf("diff not cached and generation not yet implemented")</span>
}

// ========================================================================
// INLINE COMMENTS
// ========================================================================

// CreateInlineComment creates an inline comment
func (d *db) CreateInlineComment(comment *models.DocumentInlineComment) error <span class="cov0" title="0">{
        if err := comment.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid inline comment: %w", err)
        }</span>

        <span class="cov0" title="0">comment.SetTimestamps()

        query := `
                INSERT INTO document_inline_comment (
                        id, document_id, comment_id, position_start, position_end,
                        selected_text, is_resolved, created
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                comment.ID, comment.DocumentID, comment.CommentID,
                comment.PositionStart, comment.PositionEnd, comment.SelectedText,
                comment.IsResolved, comment.Created,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create inline comment: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInlineComments gets all inline comments for a document
func (d *db) GetInlineComments(documentID string) ([]*models.DocumentInlineComment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, document_id, comment_id, position_start, position_end,
                           selected_text, is_resolved, created
                FROM document_inline_comment
                WHERE document_id = ? AND is_resolved = 0
                ORDER BY position_start ASC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get inline comments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        comments := []*models.DocumentInlineComment{}
        for rows.Next() </span><span class="cov0" title="0">{
                comment := &amp;models.DocumentInlineComment{}
                err := rows.Scan(
                        &amp;comment.ID, &amp;comment.DocumentID, &amp;comment.CommentID,
                        &amp;comment.PositionStart, &amp;comment.PositionEnd, &amp;comment.SelectedText,
                        &amp;comment.IsResolved, &amp;comment.Created,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan inline comment: %w", err)
                }</span>
                <span class="cov0" title="0">comments = append(comments, comment)</span>
        }

        <span class="cov0" title="0">return comments, nil</span>
}

// ResolveInlineComment marks an inline comment as resolved
func (d *db) ResolveInlineComment(id string) error <span class="cov0" title="0">{
        query := `
                UPDATE document_inline_comment
                SET is_resolved = 1, resolved_at = ?, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        now := time.Now().Unix()
        result, err := d.Exec(ctx, query, now, now, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve inline comment: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("inline comment not found: %s", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========================================================================
// LABELS AND TAGS
// ========================================================================

// CreateLabelDocumentMapping creates a label-document link
func (d *db) CreateLabelDocumentMapping(mapping *models.LabelDocumentMapping) error <span class="cov0" title="0">{
        if err := mapping.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid label-document mapping: %w", err)
        }</span>

        <span class="cov0" title="0">mapping.SetTimestamps()

        query := `
                INSERT INTO label_document_mapping (
                        id, label_id, document_id, user_id, created, deleted
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                mapping.ID, mapping.LabelID, mapping.DocumentID,
                mapping.UserID, mapping.Created, mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create label-document mapping: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentLabels gets all labels for a document
func (d *db) GetDocumentLabels(documentID string) ([]*models.LabelDocumentMapping, error) <span class="cov0" title="0">{
        query := `
                SELECT id, label_id, document_id, user_id, created, deleted
                FROM label_document_mapping
                WHERE document_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document labels: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        labels := []*models.LabelDocumentMapping{}
        for rows.Next() </span><span class="cov0" title="0">{
                label := &amp;models.LabelDocumentMapping{}
                err := rows.Scan(
                        &amp;label.ID, &amp;label.LabelID, &amp;label.DocumentID,
                        &amp;label.UserID, &amp;label.Created, &amp;label.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan label mapping: %w", err)
                }</span>
                <span class="cov0" title="0">labels = append(labels, label)</span>
        }

        <span class="cov0" title="0">return labels, nil</span>
}

// DeleteLabelDocumentMapping removes a label from a document
func (d *db) DeleteLabelDocumentMapping(labelID, documentID string) error <span class="cov0" title="0">{
        query := `
                UPDATE label_document_mapping
                SET deleted = 1
                WHERE label_id = ? AND document_id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, labelID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete label-document mapping: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("label mapping not found: label=%s document=%s", labelID, documentID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateDocumentTag creates a new tag
func (d *db) CreateDocumentTag(tag *models.DocumentTag) error <span class="cov4" title="3">{
        tag.SetTimestamps()

        if err := tag.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document tag: %w", err)
        }</span>

        <span class="cov4" title="3">query := `
                INSERT INTO document_tag (
                        id, name, created
                ) VALUES (?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query, tag.ID, tag.Name, tag.Created)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document tag: %w", err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// GetDocumentTag gets a tag by ID
func (d *db) GetDocumentTag(id string) (*models.DocumentTag, error) <span class="cov1" title="1">{
        query := `SELECT id, name, created FROM document_tag WHERE id = ?`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, id)

        tag := &amp;models.DocumentTag{}
        err := row.Scan(&amp;tag.ID, &amp;tag.Name, &amp;tag.Created)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document tag not found: %s", id)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document tag: %w", err)
        }</span>

        <span class="cov1" title="1">return tag, nil</span>
}

// GetOrCreateDocumentTag gets existing tag or creates new one
func (d *db) GetOrCreateDocumentTag(name string) (*models.DocumentTag, error) <span class="cov3" title="2">{
        // Try to get existing tag by name
        query := `SELECT id, name, created FROM document_tag WHERE name = ?`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, name)

        tag := &amp;models.DocumentTag{}
        err := row.Scan(&amp;tag.ID, &amp;tag.Name, &amp;tag.Created)

        if err == nil </span><span class="cov1" title="1">{
                // Tag exists, return it
                return tag, nil
        }</span>

        <span class="cov1" title="1">if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                // Some other error occurred
                return nil, fmt.Errorf("failed to get document tag: %w", err)
        }</span>

        // Tag doesn't exist, create it
        <span class="cov1" title="1">newTag := &amp;models.DocumentTag{
                ID:   generateUUID(),
                Name: name,
        }

        if err := d.CreateDocumentTag(newTag); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create document tag: %w", err)
        }</span>

        <span class="cov1" title="1">return newTag, nil</span>
}

// CreateDocumentTagMapping creates a tag-document link
func (d *db) CreateDocumentTagMapping(mapping *models.DocumentTagMapping) error <span class="cov0" title="0">{
        if err := mapping.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document tag mapping: %w", err)
        }</span>

        <span class="cov0" title="0">mapping.SetTimestamps()

        query := `
                INSERT INTO document_tag_mapping (
                        id, tag_id, document_id, creator_id, is_public, created, deleted
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                mapping.ID, mapping.TagID, mapping.DocumentID,
                mapping.UserID, mapping.Created, mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document tag mapping: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentTags gets all tags for a document
func (d *db) GetDocumentTags(documentID string) ([]*models.DocumentTagMapping, error) <span class="cov0" title="0">{
        query := `
                SELECT id, tag_id, document_id, user_id, created, deleted
                FROM document_tag_mapping
                WHERE document_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document tags: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        tags := []*models.DocumentTagMapping{}
        for rows.Next() </span><span class="cov0" title="0">{
                tag := &amp;models.DocumentTagMapping{}
                err := rows.Scan(
                        &amp;tag.ID, &amp;tag.TagID, &amp;tag.DocumentID,
                        &amp;tag.UserID, &amp;tag.Created, &amp;tag.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan tag mapping: %w", err)
                }</span>
                <span class="cov0" title="0">tags = append(tags, tag)</span>
        }

        <span class="cov0" title="0">return tags, nil</span>
}

// DeleteDocumentTagMapping removes a tag from a document
func (d *db) DeleteDocumentTagMapping(tagID, documentID string) error <span class="cov0" title="0">{
        query := `
                UPDATE document_tag_mapping
                SET deleted = 1
                WHERE tag_id = ? AND document_id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, tagID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document tag mapping: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("tag mapping not found: tag=%s document=%s", tagID, documentID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========================================================================
// ENTITY LINKS
// ========================================================================

// CreateDocumentEntityLink creates a link to any entity
func (d *db) CreateDocumentEntityLink(link *models.DocumentEntityLink) error <span class="cov0" title="0">{
        if err := link.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document entity link: %w", err)
        }</span>

        <span class="cov0" title="0">link.SetTimestamps()

        query := `
                INSERT INTO document_entity_link (
                        id, document_id, entity_type, entity_id, link_type,
                        creator_id, is_public, created, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                link.ID, link.DocumentID, link.EntityType, link.EntityID,
                link.LinkType, link.UserID, link.Created, link.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document entity link: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentEntityLinks gets all entity links for a document
func (d *db) GetDocumentEntityLinks(documentID string) ([]*models.DocumentEntityLink, error) <span class="cov0" title="0">{
        query := `
                SELECT id, document_id, entity_type, entity_id, link_type,
                           creator_id, is_public, created, deleted
                FROM document_entity_link
                WHERE document_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document entity links: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        links := []*models.DocumentEntityLink{}
        for rows.Next() </span><span class="cov0" title="0">{
                link := &amp;models.DocumentEntityLink{}
                err := rows.Scan(
                        &amp;link.ID, &amp;link.DocumentID, &amp;link.EntityType, &amp;link.EntityID,
                        &amp;link.LinkType, &amp;link.UserID, &amp;link.Created, &amp;link.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan entity link: %w", err)
                }</span>
                <span class="cov0" title="0">links = append(links, link)</span>
        }

        <span class="cov0" title="0">return links, nil</span>
}

// GetEntityDocuments gets all documents linked to an entity
func (d *db) GetEntityDocuments(entityType, entityID string) ([]*models.DocumentEntityLink, error) <span class="cov0" title="0">{
        query := `
                SELECT id, document_id, entity_type, entity_id, link_type,
                           creator_id, is_public, created, deleted
                FROM document_entity_link
                WHERE entity_type = ? AND entity_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, entityType, entityID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get entity documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        links := []*models.DocumentEntityLink{}
        for rows.Next() </span><span class="cov0" title="0">{
                link := &amp;models.DocumentEntityLink{}
                err := rows.Scan(
                        &amp;link.ID, &amp;link.DocumentID, &amp;link.EntityType, &amp;link.EntityID,
                        &amp;link.LinkType, &amp;link.UserID, &amp;link.Created, &amp;link.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan entity link: %w", err)
                }</span>
                <span class="cov0" title="0">links = append(links, link)</span>
        }

        <span class="cov0" title="0">return links, nil</span>
}

// DeleteDocumentEntityLink removes an entity link
func (d *db) DeleteDocumentEntityLink(id string) error <span class="cov0" title="0">{
        query := `
                UPDATE document_entity_link
                SET deleted = 1
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete entity link: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("entity link not found: %s", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateDocumentRelationship creates a document-to-document relationship
func (d *db) CreateDocumentRelationship(rel *models.DocumentRelationship) error <span class="cov0" title="0">{
        if err := rel.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document relationship: %w", err)
        }</span>

        <span class="cov0" title="0">rel.SetTimestamps()

        query := `
                INSERT INTO document_relationship (
                        id, source_document_id, target_document_id, relationship_type,
                        creator_id, is_public, created, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                rel.ID, rel.SourceDocumentID, rel.TargetDocumentID,
                rel.RelationshipType, rel.UserID, rel.Created, rel.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document relationship: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentRelationships gets all relationships for a document
func (d *db) GetDocumentRelationships(documentID string) ([]*models.DocumentRelationship, error) <span class="cov0" title="0">{
        query := `
                SELECT id, source_document_id, target_document_id, relationship_type,
                           creator_id, is_public, created, deleted
                FROM document_relationship
                WHERE (source_document_id = ? OR target_document_id = ?) AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document relationships: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        relationships := []*models.DocumentRelationship{}
        for rows.Next() </span><span class="cov0" title="0">{
                rel := &amp;models.DocumentRelationship{}
                err := rows.Scan(
                        &amp;rel.ID, &amp;rel.SourceDocumentID, &amp;rel.TargetDocumentID,
                        &amp;rel.RelationshipType, &amp;rel.UserID, &amp;rel.Created, &amp;rel.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan relationship: %w", err)
                }</span>
                <span class="cov0" title="0">relationships = append(relationships, rel)</span>
        }

        <span class="cov0" title="0">return relationships, nil</span>
}

// DeleteDocumentRelationship removes a relationship
func (d *db) DeleteDocumentRelationship(id string) error <span class="cov0" title="0">{
        query := `
                UPDATE document_relationship
                SET deleted = 1
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete relationship: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("relationship not found: %s", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ========================================================================
// TEMPLATES
// ========================================================================

// CreateDocumentTemplate creates a new template
func (d *db) CreateDocumentTemplate(template *models.DocumentTemplate) error <span class="cov4" title="3">{
        if err := template.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document template: %w", err)
        }</span>

        <span class="cov4" title="3">template.SetTimestamps()

        query := `
                INSERT INTO document_template (
                        id, name, description, space_id, type_id, content_template,
                        variables_json, creator_id, is_public, use_count, created, modified, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                template.ID, template.Name, template.Description, template.SpaceID, template.TypeID,
                template.ContentTemplate, template.VariablesJSON, template.CreatorID,
                template.IsPublic, template.UseCount,
                template.Created, template.Modified, template.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document template: %w", err)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// GetDocumentTemplate gets a template by ID
func (d *db) GetDocumentTemplate(id string) (*models.DocumentTemplate, error) <span class="cov3" title="2">{
        query := `
                SELECT id, name, description, space_id, creator_id, content_template,
                           variables_json, use_count, is_public, created, modified, deleted
                FROM document_template
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, id)

        template := &amp;models.DocumentTemplate{}
        err := row.Scan(
                &amp;template.ID, &amp;template.Name, &amp;template.Description, &amp;template.SpaceID, &amp;template.CreatorID,
                &amp;template.ContentTemplate, &amp;template.VariablesJSON, &amp;template.UseCount, &amp;template.IsPublic,
                &amp;template.Created, &amp;template.Modified, &amp;template.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document template not found: %s", id)
        }</span>
        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document template: %w", err)
        }</span>

        <span class="cov3" title="2">return template, nil</span>
}

// ListDocumentTemplates lists all templates
func (d *db) ListDocumentTemplates(filters map[string]interface{}) ([]*models.DocumentTemplate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, space_id, type_id, content_template, variables_json,
                           creator_id, is_public, use_count, created, modified, deleted
                FROM document_template
                WHERE deleted = 0
        `

        args := []interface{}{}

        // Apply filters
        if isPublic, ok := filters["is_public"].(bool); ok </span><span class="cov0" title="0">{
                query += " AND is_public = ?"
                args = append(args, isPublic)
        }</span>

        <span class="cov0" title="0">if creatorID, ok := filters["creator_id"].(string); ok &amp;&amp; creatorID != "" </span><span class="cov0" title="0">{
                query += " AND creator_id = ?"
                args = append(args, creatorID)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY use_count DESC, created DESC"

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list document templates: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        templates := []*models.DocumentTemplate{}
        for rows.Next() </span><span class="cov0" title="0">{
                template := &amp;models.DocumentTemplate{}
                err := rows.Scan(
                        &amp;template.ID, &amp;template.Name, &amp;template.Description, &amp;template.SpaceID,
                        &amp;template.TypeID, &amp;template.ContentTemplate, &amp;template.VariablesJSON,
                        &amp;template.CreatorID, &amp;template.IsPublic, &amp;template.UseCount,
                        &amp;template.Created, &amp;template.Modified, &amp;template.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan template: %w", err)
                }</span>
                <span class="cov0" title="0">templates = append(templates, template)</span>
        }

        <span class="cov0" title="0">return templates, nil</span>
}

// UpdateDocumentTemplate updates a template
func (d *db) UpdateDocumentTemplate(template *models.DocumentTemplate) error <span class="cov0" title="0">{
        if err := template.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document template: %w", err)
        }</span>

        <span class="cov0" title="0">template.SetTimestamps()

        query := `
                UPDATE document_template
                SET name = ?, description = ?, space_id = ?, type_id = ?, content_template = ?,
                    variables_json = ?, is_public = ?, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query,
                template.Name, template.Description, template.SpaceID, template.TypeID,
                template.ContentTemplate, template.VariablesJSON, template.IsPublic,
                template.Modified, template.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document template: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document template not found: %s", template.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteDocumentTemplate deletes a template
func (d *db) DeleteDocumentTemplate(id string) error <span class="cov0" title="0">{
        query := `UPDATE document_template SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document template: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document template not found: %s", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IncrementTemplateUseCount increments use counter
func (d *db) IncrementTemplateUseCount(id string) error <span class="cov1" title="1">{
        query := `
                UPDATE document_template
                SET use_count = use_count + 1, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to increment template use count: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document template not found: %s", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// CreateDocumentBlueprint creates a blueprint
func (d *db) CreateDocumentBlueprint(blueprint *models.DocumentBlueprint) error <span class="cov0" title="0">{
        if err := blueprint.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document blueprint: %w", err)
        }</span>

        <span class="cov0" title="0">blueprint.SetTimestamps()

        query := `
                INSERT INTO document_blueprint (
                        id, name, description, space_id, template_id, wizard_steps_json,
                        creator_id, is_public, created, modified, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                blueprint.ID, blueprint.Name, blueprint.Description, blueprint.SpaceID, blueprint.TemplateID,
                blueprint.WizardStepsJSON, blueprint.CreatorID, blueprint.IsPublic, blueprint.Created,
                blueprint.Modified, blueprint.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document blueprint: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentBlueprint gets a blueprint by ID
func (d *db) GetDocumentBlueprint(id string) (*models.DocumentBlueprint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, space_id, template_id, wizard_steps_json,
                           creator_id, is_public, created, modified, deleted
                FROM document_blueprint
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, id)

        blueprint := &amp;models.DocumentBlueprint{}
        err := row.Scan(
                &amp;blueprint.ID, &amp;blueprint.Name, &amp;blueprint.Description, &amp;blueprint.SpaceID,
                &amp;blueprint.TemplateID, &amp;blueprint.WizardStepsJSON, &amp;blueprint.CreatorID,
                &amp;blueprint.IsPublic, &amp;blueprint.Created, &amp;blueprint.Modified, &amp;blueprint.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document blueprint not found: %s", id)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document blueprint: %w", err)
        }</span>

        <span class="cov0" title="0">return blueprint, nil</span>
}

// ListDocumentBlueprints lists all blueprints
func (d *db) ListDocumentBlueprints(filters map[string]interface{}) ([]*models.DocumentBlueprint, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, space_id, template_id, wizard_steps_json,
                           creator_id, is_public, created, modified, deleted
                FROM document_blueprint
                WHERE deleted = 0
                ORDER BY created DESC
        `

        args := []interface{}{}

        // Apply filters if needed
        if createdBy, ok := filters["created_by"].(string); ok &amp;&amp; createdBy != "" </span><span class="cov0" title="0">{
                query = `
                        SELECT id, name, description, space_id, template_id, wizard_steps_json,
                                   creator_id, is_public, created, modified, deleted
                        FROM document_blueprint
                        WHERE deleted = 0 AND created_by = ?
                        ORDER BY created DESC
                `
                args = append(args, createdBy)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list document blueprints: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        blueprints := []*models.DocumentBlueprint{}
        for rows.Next() </span><span class="cov0" title="0">{
                blueprint := &amp;models.DocumentBlueprint{}
                err := rows.Scan(
                        &amp;blueprint.ID, &amp;blueprint.Name, &amp;blueprint.Description, &amp;blueprint.SpaceID,
                        &amp;blueprint.TemplateID, &amp;blueprint.WizardStepsJSON, &amp;blueprint.CreatorID,
                        &amp;blueprint.IsPublic, &amp;blueprint.Created, &amp;blueprint.Modified, &amp;blueprint.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan blueprint: %w", err)
                }</span>
                <span class="cov0" title="0">blueprints = append(blueprints, blueprint)</span>
        }

        <span class="cov0" title="0">return blueprints, nil</span>
}

// ========================================================================
// ANALYTICS
// ========================================================================

// CreateDocumentViewHistory records a document view
func (d *db) CreateDocumentViewHistory(view *models.DocumentViewHistory) error <span class="cov6" title="6">{
        if err := view.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document view history: %w", err)
        }</span>

        <span class="cov6" title="6">view.SetTimestamps()

        query := `
                INSERT INTO document_view_history (
                        id, document_id, user_id, ip_address, user_agent, session_id, view_duration, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                view.ID, view.DocumentID, view.UserID, view.IPAddress,
                view.UserAgent, view.SessionID, view.ViewDuration, view.Timestamp,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document view history: %w", err)
        }</span>

        <span class="cov6" title="6">return nil</span>
}

// GetDocumentViewHistory gets view history for a document
func (d *db) GetDocumentViewHistory(documentID string, limit, offset int) ([]*models.DocumentViewHistory, error) <span class="cov1" title="1">{
        query := `
                SELECT id, document_id, user_id, ip_address, user_agent, session_id, view_duration, timestamp
                FROM document_view_history
                WHERE document_id = ?
                ORDER BY timestamp DESC
        `

        args := []interface{}{documentID}

        if limit &gt; 0 </span><span class="cov1" title="1">{
                query += " LIMIT ?"
                args = append(args, limit)
        }</span>
        <span class="cov1" title="1">if offset &gt; 0 </span><span class="cov0" title="0">{
                query += " OFFSET ?"
                args = append(args, offset)
        }</span>

        <span class="cov1" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document view history: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        views := []*models.DocumentViewHistory{}
        for rows.Next() </span><span class="cov5" title="5">{
                view := &amp;models.DocumentViewHistory{}
                err := rows.Scan(
                        &amp;view.ID, &amp;view.DocumentID, &amp;view.UserID, &amp;view.IPAddress,
                        &amp;view.UserAgent, &amp;view.SessionID, &amp;view.ViewDuration, &amp;view.Timestamp,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan view history: %w", err)
                }</span>
                <span class="cov5" title="5">views = append(views, view)</span>
        }

        <span class="cov1" title="1">return views, nil</span>
}

// GetDocumentAnalytics gets analytics for a document
func (d *db) GetDocumentAnalytics(documentID string) (*models.DocumentAnalytics, error) <span class="cov1" title="1">{
        query := `
                SELECT id, document_id, total_views, unique_viewers, total_edits, unique_editors,
                           total_comments, total_reactions, total_watchers, avg_view_duration,
                           last_viewed, last_edited, popularity_score, updated
                FROM document_analytics
                WHERE document_id = ?
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, documentID)

        analytics := &amp;models.DocumentAnalytics{}
        err := row.Scan(
                &amp;analytics.ID, &amp;analytics.DocumentID, &amp;analytics.TotalViews,
                &amp;analytics.UniqueViewers, &amp;analytics.TotalEdits, &amp;analytics.UniqueEditors,
                &amp;analytics.TotalComments, &amp;analytics.TotalReactions, &amp;analytics.TotalWatchers,
                &amp;analytics.AvgViewDuration, &amp;analytics.LastViewed, &amp;analytics.LastEdited,
                &amp;analytics.PopularityScore, &amp;analytics.Updated,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("analytics not found for document: %s", documentID)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document analytics: %w", err)
        }</span>

        <span class="cov1" title="1">return analytics, nil</span>
}

// CreateDocumentAnalytics creates analytics record
func (d *db) CreateDocumentAnalytics(analytics *models.DocumentAnalytics) error <span class="cov3" title="2">{
        if err := analytics.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document analytics: %w", err)
        }</span>

        <span class="cov3" title="2">analytics.SetTimestamps()

        query := `
                INSERT INTO document_analytics (
                        id, document_id, total_views, unique_viewers, total_edits, unique_editors,
                        total_comments, total_reactions, total_watchers, avg_view_duration,
                        last_viewed, last_edited, popularity_score, updated
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                analytics.ID, analytics.DocumentID, analytics.TotalViews,
                analytics.UniqueViewers, analytics.TotalEdits, analytics.UniqueEditors,
                analytics.TotalComments, analytics.TotalReactions, analytics.TotalWatchers,
                analytics.AvgViewDuration, analytics.LastViewed, analytics.LastEdited,
                analytics.PopularityScore, analytics.Updated,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document analytics: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// UpdateDocumentAnalytics updates analytics record
func (d *db) UpdateDocumentAnalytics(analytics *models.DocumentAnalytics) error <span class="cov0" title="0">{
        if err := analytics.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document analytics: %w", err)
        }</span>

        <span class="cov0" title="0">analytics.SetTimestamps()

        query := `
                UPDATE document_analytics
                SET total_views = ?, unique_viewers = ?, avg_view_duration = ?,
                    last_viewed = ?, popularity_score = ?, modified = ?
                WHERE id = ?
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query,
                analytics.TotalViews, analytics.UniqueViewers, analytics.AvgViewDuration,
                analytics.LastViewed, analytics.PopularityScore, analytics.Updated,
                analytics.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document analytics: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document analytics not found: %s", analytics.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetPopularDocuments gets most popular documents
func (d *db) GetPopularDocuments(limit int) ([]*models.DocumentAnalytics, error) <span class="cov0" title="0">{
        query := `
                SELECT id, document_id, total_views, unique_viewers, avg_view_duration,
                           last_viewed, popularity_score, created, modified
                FROM document_analytics
                ORDER BY popularity_score DESC, total_views DESC
        `

        args := []interface{}{}

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query += " LIMIT ?"
                args = append(args, limit)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get popular documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        popularDocs := []*models.DocumentAnalytics{}
        for rows.Next() </span><span class="cov0" title="0">{
                analytics := &amp;models.DocumentAnalytics{}
                err := rows.Scan(
                        &amp;analytics.ID, &amp;analytics.DocumentID, &amp;analytics.TotalViews,
                        &amp;analytics.UniqueViewers, &amp;analytics.AvgViewDuration, &amp;analytics.LastViewed,
                        &amp;analytics.PopularityScore, &amp;analytics.Updated, &amp;analytics.Updated,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan analytics: %w", err)
                }</span>
                <span class="cov0" title="0">popularDocs = append(popularDocs, analytics)</span>
        }

        <span class="cov0" title="0">return popularDocs, nil</span>
}

// ========================================================================
// ATTACHMENTS
// ========================================================================

// CreateDocumentAttachment creates an attachment record
func (d *db) CreateDocumentAttachment(attachment *models.DocumentAttachment) error <span class="cov6" title="6">{
        if err := attachment.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document attachment: %w", err)
        }</span>

        <span class="cov6" title="6">attachment.SetTimestamps()

        query := `
                INSERT INTO document_attachment (
                        id, document_id, filename, original_filename, mime_type, size_bytes,
                        storage_path, checksum, uploader_id, description, version,
                        created, modified, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := d.Exec(ctx, query,
                attachment.ID, attachment.DocumentID, attachment.Filename,
                attachment.OriginalFilename, attachment.MimeType, attachment.SizeBytes,
                attachment.StoragePath, attachment.Checksum, attachment.UploaderID,
                attachment.Description, attachment.Version,
                attachment.Created, attachment.Modified, attachment.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document attachment: %w", err)
        }</span>

        <span class="cov6" title="6">return nil</span>
}

// GetDocumentAttachment gets an attachment by ID
func (d *db) GetDocumentAttachment(id string) (*models.DocumentAttachment, error) <span class="cov1" title="1">{
        query := `
                SELECT id, document_id, filename, original_filename, mime_type, size_bytes,
                           storage_path, checksum, uploader_id, description, version,
                           created, modified, deleted
                FROM document_attachment
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        row := d.QueryRow(ctx, query, id)

        attachment := &amp;models.DocumentAttachment{}
        err := row.Scan(
                &amp;attachment.ID, &amp;attachment.DocumentID, &amp;attachment.Filename,
                &amp;attachment.OriginalFilename, &amp;attachment.MimeType, &amp;attachment.SizeBytes,
                &amp;attachment.StoragePath, &amp;attachment.Checksum, &amp;attachment.UploaderID,
                &amp;attachment.Description, &amp;attachment.Version,
                &amp;attachment.Created, &amp;attachment.Modified, &amp;attachment.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document attachment not found: %s", id)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document attachment: %w", err)
        }</span>

        <span class="cov1" title="1">return attachment, nil</span>
}

// ListDocumentAttachments lists all attachments for a document
func (d *db) ListDocumentAttachments(documentID string) ([]*models.DocumentAttachment, error) <span class="cov1" title="1">{
        query := `
                SELECT id, document_id, filename, original_filename, mime_type, size_bytes,
                           storage_path, checksum, uploader_id, description, version,
                           created, modified, deleted
                FROM document_attachment
                WHERE document_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, query, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list document attachments: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        attachments := []*models.DocumentAttachment{}
        for rows.Next() </span><span class="cov4" title="3">{
                attachment := &amp;models.DocumentAttachment{}
                err := rows.Scan(
                        &amp;attachment.ID, &amp;attachment.DocumentID, &amp;attachment.Filename,
                        &amp;attachment.OriginalFilename, &amp;attachment.MimeType, &amp;attachment.SizeBytes,
                        &amp;attachment.StoragePath, &amp;attachment.Checksum, &amp;attachment.UploaderID,
                        &amp;attachment.Description, &amp;attachment.Version,
                        &amp;attachment.Created, &amp;attachment.Modified, &amp;attachment.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan attachment: %w", err)
                }</span>
                <span class="cov4" title="3">attachments = append(attachments, attachment)</span>
        }

        <span class="cov1" title="1">return attachments, nil</span>
}

// UpdateDocumentAttachment updates an attachment
func (d *db) UpdateDocumentAttachment(attachment *models.DocumentAttachment) error <span class="cov0" title="0">{
        if err := attachment.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid document attachment: %w", err)
        }</span>

        <span class="cov0" title="0">attachment.SetTimestamps()

        query := `
                UPDATE document_attachment
                SET filename = ?, original_filename = ?, description = ?, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query,
                attachment.Filename, attachment.OriginalFilename, attachment.Description,
                attachment.Modified, attachment.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document attachment: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document attachment not found: %s", attachment.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteDocumentAttachment deletes an attachment
func (d *db) DeleteDocumentAttachment(id string) error <span class="cov1" title="1">{
        query := `UPDATE document_attachment SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document attachment: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document attachment not found: %s", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ========================================================================
// ADDITIONAL CORE OPERATIONS
// ========================================================================

// DeleteCommentDocumentMapping removes a comment from a document
func (d *db) DeleteCommentDocumentMapping(commentID, documentID string) error <span class="cov0" title="0">{
        query := `
                UPDATE comment_document_mapping
                SET deleted = 1
                WHERE comment_id = ? AND document_id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, commentID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete comment-document mapping: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("comment mapping not found: comment=%s document=%s", commentID, documentID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteVoteMapping removes a vote
func (d *db) DeleteVoteMapping(entityType, entityID, userID, voteType string) error <span class="cov0" title="0">{
        query := `
                UPDATE vote_mapping
                SET deleted = 1
                WHERE entity_type = ? AND entity_id = ? AND user_id = ? AND vote_type = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, entityType, entityID, userID, voteType)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete vote mapping: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("vote mapping not found: entity=%s/%s user=%s type=%s", entityType, entityID, userID, voteType)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocumentHierarchy gets the full document tree
func (d *db) GetDocumentHierarchy(rootID string) ([]*models.Document, error) <span class="cov0" title="0">{
        // This would typically use a recursive CTE or recursive function
        // For now, just get the root document and its immediate children
        root, err := d.GetDocument(rootID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get root document: %w", err)
        }</span>

        <span class="cov0" title="0">children, err := d.GetDocumentChildren(rootID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get children: %w", err)
        }</span>

        <span class="cov0" title="0">hierarchy := []*models.Document{root}
        hierarchy = append(hierarchy, children...)

        return hierarchy, nil</span>
}

// GetDocumentBreadcrumb gets the breadcrumb trail for a document
func (d *db) GetDocumentBreadcrumb(id string) ([]*models.Document, error) <span class="cov0" title="0">{
        // Get the document
        doc, err := d.GetDocument(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document: %w", err)
        }</span>

        <span class="cov0" title="0">breadcrumb := []*models.Document{doc}

        // Recursively get parents
        currentID := id
        for </span><span class="cov0" title="0">{
                currentDoc, err := d.GetDocument(currentID)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if currentDoc.ParentID == nil || *currentDoc.ParentID == "" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">parent, err := d.GetDocument(*currentDoc.ParentID)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // Prepend parent to breadcrumb
                <span class="cov0" title="0">breadcrumb = append([]*models.Document{parent}, breadcrumb...)
                currentID = *currentDoc.ParentID</span>
        }

        <span class="cov0" title="0">return breadcrumb, nil</span>
}

// SearchDocuments performs full-text search on documents
func (d *db) SearchDocuments(query string, filters map[string]interface{}, limit, offset int) ([]*models.Document, error) <span class="cov0" title="0">{
        // Basic search implementation using LIKE
        // For production, consider using FTS (Full-Text Search)
        searchQuery := `
                SELECT id, title, space_id, parent_id, type_id, project_id,
                           creator_id, version, position, is_published, is_archived,
                           publish_date, created, modified, deleted
                FROM document
                WHERE deleted = 0 AND (title LIKE ? OR id IN (
                        SELECT document_id FROM document_content WHERE content LIKE ? AND deleted = 0
                ))
        `

        args := []interface{}{
                "%" + query + "%",
                "%" + query + "%",
        }

        // Apply additional filters
        if spaceID, ok := filters["space_id"].(string); ok &amp;&amp; spaceID != "" </span><span class="cov0" title="0">{
                searchQuery += " AND space_id = ?"
                args = append(args, spaceID)
        }</span>

        <span class="cov0" title="0">if isPublished, ok := filters["is_published"].(bool); ok </span><span class="cov0" title="0">{
                searchQuery += " AND is_published = ?"
                args = append(args, isPublished)
        }</span>

        <span class="cov0" title="0">searchQuery += " ORDER BY modified DESC"

        if limit &gt; 0 </span><span class="cov0" title="0">{
                searchQuery += " LIMIT ?"
                args = append(args, limit)
        }</span>
        <span class="cov0" title="0">if offset &gt; 0 </span><span class="cov0" title="0">{
                searchQuery += " OFFSET ?"
                args = append(args, offset)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        rows, err := d.Query(ctx, searchQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        documents := []*models.Document{}
        for rows.Next() </span><span class="cov0" title="0">{
                doc := &amp;models.Document{}
                err := rows.Scan(
                        &amp;doc.ID, &amp;doc.Title, &amp;doc.SpaceID, &amp;doc.ParentID, &amp;doc.TypeID, &amp;doc.ProjectID,
                        &amp;doc.CreatorID, &amp;doc.Version, &amp;doc.Position, &amp;doc.IsPublished, &amp;doc.IsArchived,
                        &amp;doc.PublishDate, &amp;doc.Created, &amp;doc.Modified, &amp;doc.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan document: %w", err)
                }</span>
                <span class="cov0" title="0">documents = append(documents, doc)</span>
        }

        <span class="cov0" title="0">return documents, nil</span>
}

// GetRelatedDocuments gets related documents
func (d *db) GetRelatedDocuments(id string, limit int) ([]*models.Document, error) <span class="cov0" title="0">{
        // Get documents with same tags, labels, or in same space
        // Simplified implementation - could be enhanced with scoring
        doc, err := d.GetDocument(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get document: %w", err)
        }</span>

        <span class="cov0" title="0">filters := map[string]interface{}{
                "space_id": doc.SpaceID,
        }

        related, err := d.ListDocuments(filters, limit, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get related documents: %w", err)
        }</span>

        // Filter out the original document
        <span class="cov0" title="0">filtered := []*models.Document{}
        for _, relDoc := range related </span><span class="cov0" title="0">{
                if relDoc.ID != id </span><span class="cov0" title="0">{
                        filtered = append(filtered, relDoc)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

// PublishDocument publishes a document
func (d *db) PublishDocument(id string) error <span class="cov3" title="2">{
        query := `
                UPDATE document
                SET is_published = 1, publish_date = ?, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        now := time.Now().Unix()
        result, err := d.Exec(ctx, query, now, now, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish document: %w", err)
        }</span>

        <span class="cov3" title="2">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov3" title="2">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// UnpublishDocument unpublishes a document
func (d *db) UnpublishDocument(id string) error <span class="cov1" title="1">{
        query := `
                UPDATE document
                SET is_published = 0, modified = ?
                WHERE id = ? AND deleted = 0
        `

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := d.Exec(ctx, query, time.Now().Unix(), id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unpublish document: %w", err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found: %s", id)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ========================================================================
// DATABASE IMPLEMENTATION COMPLETE
// ========================================================================
// All 70+ methods from DocumentDatabase interface are now implemented.
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "sync"
        "time"

        _ "github.com/mattn/go-sqlite3" // SQLite driver
        _ "github.com/lib/pq"           // PostgreSQL driver
        "helixtrack.ru/core/internal/config"
)

// OptimizedDatabase extends Database with performance features
type OptimizedDatabase interface {
        Database

        // PreparedQuery executes a prepared statement with caching
        PreparedQuery(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)

        // PreparedQueryRow executes a prepared statement that returns a single row
        PreparedQueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row

        // PreparedExec executes a prepared statement that doesn't return rows
        PreparedExec(ctx context.Context, query string, args ...interface{}) (sql.Result, error)

        // GetStats returns database performance statistics
        GetStats() *DatabaseStats

        // ClearPreparedStatements clears the prepared statement cache
        ClearPreparedStatements() error
}

// DatabaseStats contains performance metrics
type DatabaseStats struct {
        OpenConnections     int           // Current open connections
        InUseConnections    int           // Connections currently in use
        IdleConnections     int           // Idle connections
        WaitCount           int64         // Total connections waited for
        WaitDuration        time.Duration // Total time waited for connections
        MaxIdleClosed       int64         // Connections closed due to max idle
        MaxLifetimeClosed   int64         // Connections closed due to max lifetime
        PreparedStmtCount   int           // Number of cached prepared statements
        QueryCount          int64         // Total queries executed
        PreparedQueryCount  int64         // Total prepared queries executed
        AvgQueryDuration    time.Duration // Average query execution time
}

// optimizedDB is the high-performance implementation
type optimizedDB struct {
        conn               *sql.DB
        dbType             string
        encryptionKey      string

        // Prepared statement cache
        stmtCache          map[string]*sql.Stmt
        stmtCacheMu        sync.RWMutex

        // Performance metrics
        queryCount         int64
        preparedQueryCount int64
        totalQueryTime     time.Duration
        queryTimeMu        sync.RWMutex
}

// OptimizationConfig contains database optimization settings
type OptimizationConfig struct {
        // Connection Pool Settings
        MaxOpenConns        int           // Maximum number of open connections
        MaxIdleConns        int           // Maximum number of idle connections
        ConnMaxLifetime     time.Duration // Maximum connection lifetime
        ConnMaxIdleTime     time.Duration // Maximum connection idle time

        // SQLCipher Settings (SQLite only)
        EncryptionKey       string        // Encryption key for SQLCipher
        KDFIterations       int           // Key derivation iterations (default: 256000)
        CipherPageSize      int           // Page size in bytes (default: 4096)
        CipherUseHMAC       bool          // Use HMAC for integrity (default: true)

        // Performance Settings
        EnableWAL           bool          // Enable Write-Ahead Logging (SQLite)
        CacheSize           int           // Cache size in pages (SQLite, default: -2000 = 2MB)
        BusyTimeout         int           // Busy timeout in milliseconds (SQLite)
        JournalMode         string        // Journal mode (SQLite, default: WAL)
        Synchronous         string        // Synchronous mode (SQLite, default: NORMAL)
        TempStore           string        // Temp store location (SQLite, default: MEMORY)
        MMAPSize            int64         // Memory-mapped I/O size (SQLite, default: 0 = disabled)

        // PostgreSQL Settings
        StatementTimeout    int           // Statement timeout in milliseconds
        IdleInTxTimeout     int           // Idle in transaction timeout
        EnableJIT           bool          // Enable JIT compilation (PostgreSQL 11+)
}

// DefaultOptimizationConfig returns optimized default settings
func DefaultOptimizationConfig() OptimizationConfig <span class="cov5" title="14">{
        return OptimizationConfig{
                // Connection Pool - Optimized for high concurrency
                MaxOpenConns:      100,                  // High concurrency support
                MaxIdleConns:      25,                   // Keep connections warm
                ConnMaxLifetime:   time.Hour,            // Recycle connections hourly
                ConnMaxIdleTime:   15 * time.Minute,     // Close idle after 15min

                // SQLCipher - Secure with good performance
                KDFIterations:     256000,               // Strong key derivation
                CipherPageSize:    4096,                 // Optimal page size
                CipherUseHMAC:     true,                 // Integrity verification

                // SQLite Performance - Maximum performance
                EnableWAL:         true,                 // Write-Ahead Logging
                CacheSize:         -64000,               // 64MB cache
                BusyTimeout:       5000,                 // 5 second busy timeout
                JournalMode:       "WAL",                // Best concurrency
                Synchronous:       "NORMAL",             // Balance safety/performance
                TempStore:         "MEMORY",             // Fast temp tables
                MMAPSize:          268435456,            // 256MB memory-mapped I/O

                // PostgreSQL - Production optimized
                StatementTimeout:  30000,                // 30 second timeout
                IdleInTxTimeout:   60000,                // 1 minute idle in tx
                EnableJIT:         true,                 // JIT compilation
        }
}</span>

// NewOptimizedDatabase creates a high-performance encrypted database connection
func NewOptimizedDatabase(cfg config.DatabaseConfig, optCfg OptimizationConfig) (OptimizedDatabase, error) <span class="cov5" title="14">{
        var conn *sql.DB
        var err error

        switch cfg.Type </span>{
        case "sqlite":<span class="cov5" title="13">
                // Build SQLCipher connection string with encryption and optimizations
                connStr := cfg.SQLitePath

                // Check if the path already contains parameters (e.g., "file::memory:?cache=shared")
                hasParams := false
                if len(connStr) &gt; 0 &amp;&amp; (connStr[len(connStr)-1] != '/' &amp;&amp; connStr[len(connStr)-1] != '\\') </span><span class="cov5" title="13">{
                        // Check if string contains '?'
                        for i := 0; i &lt; len(connStr); i++ </span><span class="cov9" title="254">{
                                if connStr[i] == '?' </span><span class="cov5" title="12">{
                                        hasParams = true
                                        break</span>
                                }
                        }
                }

                <span class="cov5" title="13">if optCfg.EncryptionKey != "" </span><span class="cov1" title="1">{
                        // Use SQLCipher with encryption
                        if hasParams </span><span class="cov0" title="0">{
                                connStr += fmt.Sprintf("&amp;_pragma_key=%s", optCfg.EncryptionKey)
                        }</span> else<span class="cov1" title="1"> {
                                connStr += fmt.Sprintf("?_pragma_key=%s", optCfg.EncryptionKey)
                                hasParams = true
                        }</span>

                        // Add cipher configuration
                        <span class="cov1" title="1">connStr += fmt.Sprintf("&amp;_pragma_cipher_page_size=%d", optCfg.CipherPageSize)
                        connStr += fmt.Sprintf("&amp;_pragma_kdf_iter=%d", optCfg.KDFIterations)
                        if optCfg.CipherUseHMAC </span><span class="cov1" title="1">{
                                connStr += "&amp;_pragma_cipher_use_hmac=ON"
                        }</span>
                }

                // Add performance pragmas
                <span class="cov5" title="13">separator := "?"
                if hasParams </span><span class="cov5" title="13">{
                        separator = "&amp;"
                }</span>
                <span class="cov5" title="13">connStr += fmt.Sprintf("%s_pragma_foreign_keys=ON", separator)
                connStr += fmt.Sprintf("&amp;_pragma_journal_mode=%s", optCfg.JournalMode)
                connStr += fmt.Sprintf("&amp;_pragma_synchronous=%s", optCfg.Synchronous)
                connStr += fmt.Sprintf("&amp;_pragma_cache_size=%d", optCfg.CacheSize)
                connStr += fmt.Sprintf("&amp;_pragma_temp_store=%s", optCfg.TempStore)
                connStr += fmt.Sprintf("&amp;_pragma_mmap_size=%d", optCfg.MMAPSize)
                connStr += fmt.Sprintf("&amp;_pragma_busy_timeout=%d", optCfg.BusyTimeout)

                // Additional optimizations
                connStr += "&amp;_pragma_locking_mode=NORMAL"  // Allow multiple connections
                connStr += "&amp;_pragma_auto_vacuum=INCREMENTAL" // Incremental vacuum
                connStr += "&amp;_pragma_page_size=4096"       // Optimal page size

                // Open with SQLCipher driver
                if optCfg.EncryptionKey != "" </span><span class="cov1" title="1">{
                        conn, err = sql.Open("sqlite3", connStr)
                }</span> else<span class="cov5" title="12"> {
                        // Fallback to standard SQLite if no encryption
                        conn, err = sql.Open("sqlite3", connStr)
                }</span>

                <span class="cov5" title="13">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open sqlite database: %w", err)
                }</span>

                // Configure connection pool for SQLite
                // Note: SQLite with WAL mode supports multiple readers
                <span class="cov5" title="13">if optCfg.EnableWAL </span><span class="cov5" title="13">{
                        conn.SetMaxOpenConns(optCfg.MaxOpenConns)
                        conn.SetMaxIdleConns(optCfg.MaxIdleConns)
                }</span> else<span class="cov0" title="0"> {
                        conn.SetMaxOpenConns(1) // Single writer mode
                        conn.SetMaxIdleConns(1)
                }</span>

        case "postgres":<span class="cov0" title="0">
                connStr := fmt.Sprintf(
                        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                        cfg.PostgresHost,
                        cfg.PostgresPort,
                        cfg.PostgresUser,
                        cfg.PostgresPassword,
                        cfg.PostgresDatabase,
                        cfg.PostgresSSLMode,
                )

                // Add performance parameters
                if optCfg.StatementTimeout &gt; 0 </span><span class="cov0" title="0">{
                        connStr += fmt.Sprintf(" statement_timeout=%d", optCfg.StatementTimeout)
                }</span>
                <span class="cov0" title="0">if optCfg.IdleInTxTimeout &gt; 0 </span><span class="cov0" title="0">{
                        connStr += fmt.Sprintf(" idle_in_transaction_session_timeout=%d", optCfg.IdleInTxTimeout)
                }</span>

                <span class="cov0" title="0">conn, err = sql.Open("postgres", connStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open postgres database: %w", err)
                }</span>

                // Configure connection pool for PostgreSQL
                <span class="cov0" title="0">conn.SetMaxOpenConns(optCfg.MaxOpenConns)
                conn.SetMaxIdleConns(optCfg.MaxIdleConns)</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported database type: %s", cfg.Type)</span>
        }

        // Set connection pool timeouts
        <span class="cov5" title="13">conn.SetConnMaxLifetime(optCfg.ConnMaxLifetime)
        conn.SetConnMaxIdleTime(optCfg.ConnMaxIdleTime)

        // Verify connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := conn.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Apply PostgreSQL-specific optimizations
        <span class="cov5" title="13">if cfg.Type == "postgres" </span><span class="cov0" title="0">{
                if optCfg.EnableJIT </span><span class="cov0" title="0">{
                        _, _ = conn.Exec("SET jit = ON")
                }</span>
                // Set work_mem for better query performance
                <span class="cov0" title="0">_, _ = conn.Exec("SET work_mem = '64MB'")
                // Set shared_buffers recommendation
                _, _ = conn.Exec("SET shared_buffers = '256MB'")
                // Set effective_cache_size
                _, _ = conn.Exec("SET effective_cache_size = '1GB'")</span>
        }

        <span class="cov5" title="13">return &amp;optimizedDB{
                conn:          conn,
                dbType:        cfg.Type,
                encryptionKey: optCfg.EncryptionKey,
                stmtCache:     make(map[string]*sql.Stmt),
        }, nil</span>
}

// Query executes a query that returns rows
func (d *optimizedDB) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov1" title="1">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        d.incrementQueryCount()
        return d.conn.QueryContext(ctx, query, args...)
}</span>

// QueryRow executes a query that returns a single row
func (d *optimizedDB) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov2" title="2">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        d.incrementQueryCount()
        return d.conn.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a query that doesn't return rows
func (d *optimizedDB) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="133">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        d.incrementQueryCount()
        return d.conn.ExecContext(ctx, query, args...)
}</span>

// PreparedQuery executes a prepared statement with caching
func (d *optimizedDB) PreparedQuery(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov5" title="12">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        stmt, err := d.getOrCreateStmt(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="12">d.incrementPreparedQueryCount()
        return stmt.QueryContext(ctx, args...)</span>
}

// PreparedQueryRow executes a prepared statement that returns a single row
func (d *optimizedDB) PreparedQueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov8" title="106">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        stmt, err := d.getOrCreateStmt(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to regular query on error
                return d.conn.QueryRowContext(ctx, query, args...)
        }</span>

        <span class="cov8" title="106">d.incrementPreparedQueryCount()
        return stmt.QueryRowContext(ctx, args...)</span>
}

// PreparedExec executes a prepared statement that doesn't return rows
func (d *optimizedDB) PreparedExec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov2" title="3">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        stmt, err := d.getOrCreateStmt(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">d.incrementPreparedQueryCount()
        return stmt.ExecContext(ctx, args...)</span>
}

// getOrCreateStmt gets a cached prepared statement or creates a new one
func (d *optimizedDB) getOrCreateStmt(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov8" title="121">{
        // Check cache first (read lock)
        d.stmtCacheMu.RLock()
        stmt, exists := d.stmtCache[query]
        d.stmtCacheMu.RUnlock()

        if exists </span><span class="cov8" title="103">{
                return stmt, nil
        }</span>

        // Create new statement (write lock)
        <span class="cov5" title="18">d.stmtCacheMu.Lock()
        defer d.stmtCacheMu.Unlock()

        // Double-check after acquiring write lock
        stmt, exists = d.stmtCache[query]
        if exists </span><span class="cov0" title="0">{
                return stmt, nil
        }</span>

        // Prepare new statement
        <span class="cov5" title="18">stmt, err := d.conn.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare statement: %w", err)
        }</span>

        <span class="cov5" title="18">d.stmtCache[query] = stmt
        return stmt, nil</span>
}

// ClearPreparedStatements clears the prepared statement cache
func (d *optimizedDB) ClearPreparedStatements() error <span class="cov5" title="14">{
        d.stmtCacheMu.Lock()
        defer d.stmtCacheMu.Unlock()

        var lastErr error
        for _, stmt := range d.stmtCache </span><span class="cov5" title="18">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                }</span>
        }

        <span class="cov5" title="14">d.stmtCache = make(map[string]*sql.Stmt)
        return lastErr</span>
}

// Begin starts a transaction
func (d *optimizedDB) Begin(ctx context.Context) (*sql.Tx, error) <span class="cov0" title="0">{
        return d.conn.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: sql.LevelReadCommitted, // Best balance for most workloads
        })
}</span>

// Close closes the database connection and cleans up resources
func (d *optimizedDB) Close() error <span class="cov5" title="13">{
        // Clear prepared statements first
        d.ClearPreparedStatements()

        return d.conn.Close()
}</span>

// Ping verifies the database connection
func (d *optimizedDB) Ping(ctx context.Context) error <span class="cov3" title="4">{
        return d.conn.PingContext(ctx)
}</span>

// GetType returns the database type
func (d *optimizedDB) GetType() string <span class="cov1" title="1">{
        return d.dbType
}</span>

// GetStats returns database performance statistics
func (d *optimizedDB) GetStats() *DatabaseStats <span class="cov5" title="12">{
        stats := d.conn.Stats()

        d.queryTimeMu.RLock()
        queryCount := d.queryCount
        preparedQueryCount := d.preparedQueryCount
        totalQueryTime := d.totalQueryTime
        d.queryTimeMu.RUnlock()

        var avgQueryDuration time.Duration
        totalQueries := queryCount + preparedQueryCount
        if totalQueries &gt; 0 </span><span class="cov5" title="12">{
                avgQueryDuration = totalQueryTime / time.Duration(totalQueries)
        }</span>

        <span class="cov5" title="12">d.stmtCacheMu.RLock()
        preparedStmtCount := len(d.stmtCache)
        d.stmtCacheMu.RUnlock()

        return &amp;DatabaseStats{
                OpenConnections:    stats.OpenConnections,
                InUseConnections:   stats.InUse,
                IdleConnections:    stats.Idle,
                WaitCount:          stats.WaitCount,
                WaitDuration:       stats.WaitDuration,
                MaxIdleClosed:      stats.MaxIdleClosed,
                MaxLifetimeClosed:  stats.MaxLifetimeClosed,
                PreparedStmtCount:  preparedStmtCount,
                QueryCount:         queryCount,
                PreparedQueryCount: preparedQueryCount,
                AvgQueryDuration:   avgQueryDuration,
        }</span>
}

// incrementQueryCount atomically increments the query counter
func (d *optimizedDB) incrementQueryCount() <span class="cov8" title="136">{
        d.queryTimeMu.Lock()
        d.queryCount++
        d.queryTimeMu.Unlock()
}</span>

// incrementPreparedQueryCount atomically increments the prepared query counter
func (d *optimizedDB) incrementPreparedQueryCount() <span class="cov8" title="121">{
        d.queryTimeMu.Lock()
        d.preparedQueryCount++
        d.queryTimeMu.Unlock()
}</span>

// trackQueryTime adds query execution time to total
func (d *optimizedDB) trackQueryTime(duration time.Duration) <span class="cov10" title="257">{
        d.queryTimeMu.Lock()
        d.totalQueryTime += duration
        d.queryTimeMu.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
        "helixtrack.ru/core/internal/config"
)

var (
        globalLogger *zap.Logger
        sugared      *zap.SugaredLogger
)

// Initialize initializes the global logger with the given configuration
func Initialize(cfg config.LogConfig) error <span class="cov8" title="9">{
        // Create log directory if it doesn't exist
        if err := os.MkdirAll(cfg.LogPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        // Determine log level
        <span class="cov8" title="9">level := zapcore.InfoLevel
        if cfg.Level != "" </span><span class="cov8" title="9">{
                if err := level.UnmarshalText([]byte(cfg.Level)); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid log level '%s': %w", cfg.Level, err)
                }</span>
        }

        // Configure encoder
        <span class="cov8" title="8">encoderConfig := zap.NewProductionEncoderConfig()
        encoderConfig.TimeKey = "timestamp"
        encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder

        // Determine log file path
        logFilePath := filepath.Join(cfg.LogPath, "htCore.log")
        if cfg.LogfileBaseName != "" </span><span class="cov7" title="7">{
                logFilePath = filepath.Join(cfg.LogPath, cfg.LogfileBaseName+".log")
        }</span>

        // Configure log rotation with lumberjack
        <span class="cov8" title="8">fileWriter := &amp;lumberjack.Logger{
                Filename:   logFilePath,
                MaxSize:    int(cfg.LogSizeLimit / 1024 / 1024), // Convert bytes to MB
                MaxBackups: 3,
                MaxAge:     28, // days
                Compress:   true,
        }

        // Create core that writes to both file and console
        fileCore := zapcore.NewCore(
                zapcore.NewJSONEncoder(encoderConfig),
                zapcore.AddSync(fileWriter),
                level,
        )

        consoleCore := zapcore.NewCore(
                zapcore.NewConsoleEncoder(encoderConfig),
                zapcore.AddSync(os.Stdout),
                level,
        )

        // Combine cores
        core := zapcore.NewTee(fileCore, consoleCore)

        // Create logger
        globalLogger = zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))
        sugared = globalLogger.Sugar()

        return nil</span>
}

// Get returns the global logger instance
func Get() *zap.Logger <span class="cov10" title="14">{
        if globalLogger == nil </span><span class="cov3" title="2">{
                // Fallback to a default logger if not initialized
                globalLogger, _ = zap.NewProduction()
                sugared = globalLogger.Sugar()
        }</span>
        <span class="cov10" title="14">return globalLogger</span>
}

// GetSugared returns the global sugared logger instance
func GetSugared() *zap.SugaredLogger <span class="cov7" title="6">{
        if sugared == nil </span><span class="cov1" title="1">{
                Get() // Initialize if not already done
        }</span>
        <span class="cov7" title="6">return sugared</span>
}

// Sync flushes any buffered log entries
func Sync() error <span class="cov8" title="9">{
        if globalLogger != nil </span><span class="cov8" title="8">{
                err := globalLogger.Sync()
                // Ignore "sync /dev/stdout: invalid argument" and "sync /dev/stderr: invalid argument" errors
                // These are expected on Linux and other Unix-like systems
                if err != nil &amp;&amp; (strings.Contains(err.Error(), "sync /dev/stdout") ||
                        strings.Contains(err.Error(), "sync /dev/stderr") ||
                        errors.Is(err, os.ErrInvalid)) </span><span class="cov8" title="8">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Debug logs a debug message
func Debug(msg string, fields ...zap.Field) <span class="cov1" title="1">{
        Get().Debug(msg, fields...)
}</span>

// Info logs an info message
func Info(msg string, fields ...zap.Field) <span class="cov7" title="6">{
        Get().Info(msg, fields...)
}</span>

// Warn logs a warning message
func Warn(msg string, fields ...zap.Field) <span class="cov3" title="2">{
        Get().Warn(msg, fields...)
}</span>

// Error logs an error message
func Error(msg string, fields ...zap.Field) <span class="cov3" title="2">{
        Get().Error(msg, fields...)
}</span>

// Fatal logs a fatal message and exits
func Fatal(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Get().Fatal(msg, fields...)
}</span>

// Debugf logs a debug message with fmt.Sprintf-style formatting
func Debugf(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Debugf(template, args...)
}</span>

// Infof logs an info message with fmt.Sprintf-style formatting
func Infof(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Infof(template, args...)
}</span>

// Warnf logs a warning message with fmt.Sprintf-style formatting
func Warnf(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Warnf(template, args...)
}</span>

// Errorf logs an error message with fmt.Sprintf-style formatting
func Errorf(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Errorf(template, args...)
}</span>

// Fatalf logs a fatal message with fmt.Sprintf-style formatting and exits
func Fatalf(template string, args ...interface{}) <span class="cov0" title="0">{
        GetSugared().Fatalf(template, args...)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package metrics

import (
        "sync"
        "sync/atomic"
        "time"

        "github.com/gin-gonic/gin"
)

// Metrics collects application performance metrics
type Metrics struct {
        // Request metrics
        totalRequests       int64
        successfulRequests  int64
        failedRequests      int64
        totalRequestTime    int64 // nanoseconds
        minRequestTime      int64 // nanoseconds
        maxRequestTime      int64 // nanoseconds

        // Status code counts
        status2xx           int64
        status3xx           int64
        status4xx           int64
        status5xx           int64

        // Endpoint metrics
        endpointMetrics     map[string]*EndpointMetrics
        endpointMu          sync.RWMutex

        // System metrics
        startTime           time.Time
        lastRequestTime     time.Time
        lastRequestMu       sync.RWMutex
}

// EndpointMetrics contains metrics for a specific endpoint
type EndpointMetrics struct {
        Path              string
        Method            string
        Count             int64
        TotalTime         int64 // nanoseconds
        MinTime           int64 // nanoseconds
        MaxTime           int64 // nanoseconds
        Status2xx         int64
        Status3xx         int64
        Status4xx         int64
        Status5xx         int64
}

// MetricsSummary contains summarized metrics
type MetricsSummary struct {
        TotalRequests      int64         `json:"total_requests"`
        SuccessfulRequests int64         `json:"successful_requests"`
        FailedRequests     int64         `json:"failed_requests"`
        AvgRequestTime     time.Duration `json:"avg_request_time"`
        MinRequestTime     time.Duration `json:"min_request_time"`
        MaxRequestTime     time.Duration `json:"max_request_time"`
        RequestsPerSecond  float64       `json:"requests_per_second"`
        Status2xx          int64         `json:"status_2xx"`
        Status3xx          int64         `json:"status_3xx"`
        Status4xx          int64         `json:"status_4xx"`
        Status5xx          int64         `json:"status_5xx"`
        Uptime             time.Duration `json:"uptime"`
        LastRequestTime    time.Time     `json:"last_request_time"`
        Endpoints          []*EndpointMetrics `json:"endpoints,omitempty"`
}

// NewMetrics creates a new metrics collector
func NewMetrics() *Metrics <span class="cov5" title="13">{
        return &amp;Metrics{
                endpointMetrics: make(map[string]*EndpointMetrics),
                startTime:       time.Now(),
                minRequestTime:  int64(^uint64(0) &gt;&gt; 1), // Max int64
        }
}</span>

// RecordRequest records a request
func (m *Metrics) RecordRequest(duration time.Duration, statusCode int, path, method string) <span class="cov10" title="225">{
        durationNs := duration.Nanoseconds()

        // Update total counts
        atomic.AddInt64(&amp;m.totalRequests, 1)

        if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 </span><span class="cov9" title="221">{
                atomic.AddInt64(&amp;m.successfulRequests, 1)
                atomic.AddInt64(&amp;m.status2xx, 1)
        }</span> else<span class="cov3" title="4"> if statusCode &gt;= 300 &amp;&amp; statusCode &lt; 400 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;m.status3xx, 1)
        }</span> else<span class="cov2" title="3"> if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 </span><span class="cov2" title="2">{
                atomic.AddInt64(&amp;m.failedRequests, 1)
                atomic.AddInt64(&amp;m.status4xx, 1)
        }</span> else<span class="cov1" title="1"> if statusCode &gt;= 500 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;m.failedRequests, 1)
                atomic.AddInt64(&amp;m.status5xx, 1)
        }</span>

        // Update timing
        <span class="cov10" title="225">atomic.AddInt64(&amp;m.totalRequestTime, durationNs)

        // Update min time
        for </span><span class="cov10" title="225">{
                oldMin := atomic.LoadInt64(&amp;m.minRequestTime)
                if durationNs &gt;= oldMin </span><span class="cov9" title="211">{
                        break</span>
                }
                <span class="cov5" title="14">if atomic.CompareAndSwapInt64(&amp;m.minRequestTime, oldMin, durationNs) </span><span class="cov5" title="14">{
                        break</span>
                }
        }

        // Update max time
        <span class="cov10" title="225">for </span><span class="cov10" title="225">{
                oldMax := atomic.LoadInt64(&amp;m.maxRequestTime)
                if durationNs &lt;= oldMax </span><span class="cov9" title="212">{
                        break</span>
                }
                <span class="cov5" title="13">if atomic.CompareAndSwapInt64(&amp;m.maxRequestTime, oldMax, durationNs) </span><span class="cov5" title="13">{
                        break</span>
                }
        }

        // Update last request time
        <span class="cov10" title="225">m.lastRequestMu.Lock()
        m.lastRequestTime = time.Now()
        m.lastRequestMu.Unlock()

        // Update endpoint metrics
        m.recordEndpointMetrics(path, method, durationNs, statusCode)</span>
}

// recordEndpointMetrics records metrics for a specific endpoint
func (m *Metrics) recordEndpointMetrics(path, method string, durationNs int64, statusCode int) <span class="cov10" title="225">{
        key := method + ":" + path

        m.endpointMu.RLock()
        endpoint, exists := m.endpointMetrics[key]
        m.endpointMu.RUnlock()

        if !exists </span><span class="cov6" title="21">{
                m.endpointMu.Lock()
                // Double-check after acquiring write lock
                endpoint, exists = m.endpointMetrics[key]
                if !exists </span><span class="cov6" title="21">{
                        endpoint = &amp;EndpointMetrics{
                                Path:    path,
                                Method:  method,
                                MinTime: int64(^uint64(0) &gt;&gt; 1), // Max int64
                        }
                        m.endpointMetrics[key] = endpoint
                }</span>
                <span class="cov6" title="21">m.endpointMu.Unlock()</span>
        }

        // Update endpoint metrics
        <span class="cov10" title="225">atomic.AddInt64(&amp;endpoint.Count, 1)
        atomic.AddInt64(&amp;endpoint.TotalTime, durationNs)

        // Update endpoint min time
        for </span><span class="cov10" title="225">{
                oldMin := atomic.LoadInt64(&amp;endpoint.MinTime)
                if durationNs &gt;= oldMin </span><span class="cov9" title="201">{
                        break</span>
                }
                <span class="cov6" title="24">if atomic.CompareAndSwapInt64(&amp;endpoint.MinTime, oldMin, durationNs) </span><span class="cov6" title="24">{
                        break</span>
                }
        }

        // Update endpoint max time
        <span class="cov10" title="225">for </span><span class="cov10" title="225">{
                oldMax := atomic.LoadInt64(&amp;endpoint.MaxTime)
                if durationNs &lt;= oldMax </span><span class="cov9" title="203">{
                        break</span>
                }
                <span class="cov6" title="22">if atomic.CompareAndSwapInt64(&amp;endpoint.MaxTime, oldMax, durationNs) </span><span class="cov6" title="22">{
                        break</span>
                }
        }

        // Update endpoint status codes
        <span class="cov10" title="225">if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 </span><span class="cov9" title="221">{
                atomic.AddInt64(&amp;endpoint.Status2xx, 1)
        }</span> else<span class="cov3" title="4"> if statusCode &gt;= 300 &amp;&amp; statusCode &lt; 400 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;endpoint.Status3xx, 1)
        }</span> else<span class="cov2" title="3"> if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 </span><span class="cov2" title="2">{
                atomic.AddInt64(&amp;endpoint.Status4xx, 1)
        }</span> else<span class="cov1" title="1"> if statusCode &gt;= 500 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;endpoint.Status5xx, 1)
        }</span>
}

// GetSummary returns a summary of metrics
func (m *Metrics) GetSummary(includeEndpoints bool) *MetricsSummary <span class="cov5" title="13">{
        totalRequests := atomic.LoadInt64(&amp;m.totalRequests)
        successfulRequests := atomic.LoadInt64(&amp;m.successfulRequests)
        failedRequests := atomic.LoadInt64(&amp;m.failedRequests)
        totalRequestTime := atomic.LoadInt64(&amp;m.totalRequestTime)
        minRequestTime := atomic.LoadInt64(&amp;m.minRequestTime)
        maxRequestTime := atomic.LoadInt64(&amp;m.maxRequestTime)
        status2xx := atomic.LoadInt64(&amp;m.status2xx)
        status3xx := atomic.LoadInt64(&amp;m.status3xx)
        status4xx := atomic.LoadInt64(&amp;m.status4xx)
        status5xx := atomic.LoadInt64(&amp;m.status5xx)

        var avgRequestTime time.Duration
        if totalRequests &gt; 0 </span><span class="cov4" title="11">{
                avgRequestTime = time.Duration(totalRequestTime / totalRequests)
        }</span>

        <span class="cov5" title="13">uptime := time.Since(m.startTime)
        var requestsPerSecond float64
        if uptime.Seconds() &gt; 0 </span><span class="cov5" title="13">{
                requestsPerSecond = float64(totalRequests) / uptime.Seconds()
        }</span>

        <span class="cov5" title="13">m.lastRequestMu.RLock()
        lastRequestTime := m.lastRequestTime
        m.lastRequestMu.RUnlock()

        summary := &amp;MetricsSummary{
                TotalRequests:      totalRequests,
                SuccessfulRequests: successfulRequests,
                FailedRequests:     failedRequests,
                AvgRequestTime:     avgRequestTime,
                MinRequestTime:     time.Duration(minRequestTime),
                MaxRequestTime:     time.Duration(maxRequestTime),
                RequestsPerSecond:  requestsPerSecond,
                Status2xx:          status2xx,
                Status3xx:          status3xx,
                Status4xx:          status4xx,
                Status5xx:          status5xx,
                Uptime:             uptime,
                LastRequestTime:    lastRequestTime,
        }

        if includeEndpoints </span><span class="cov2" title="3">{
                m.endpointMu.RLock()
                summary.Endpoints = make([]*EndpointMetrics, 0, len(m.endpointMetrics))
                for _, endpoint := range m.endpointMetrics </span><span class="cov3" title="6">{
                        // Create a copy
                        endpointCopy := &amp;EndpointMetrics{
                                Path:      endpoint.Path,
                                Method:    endpoint.Method,
                                Count:     atomic.LoadInt64(&amp;endpoint.Count),
                                TotalTime: atomic.LoadInt64(&amp;endpoint.TotalTime),
                                MinTime:   atomic.LoadInt64(&amp;endpoint.MinTime),
                                MaxTime:   atomic.LoadInt64(&amp;endpoint.MaxTime),
                                Status2xx: atomic.LoadInt64(&amp;endpoint.Status2xx),
                                Status3xx: atomic.LoadInt64(&amp;endpoint.Status3xx),
                                Status4xx: atomic.LoadInt64(&amp;endpoint.Status4xx),
                                Status5xx: atomic.LoadInt64(&amp;endpoint.Status5xx),
                        }
                        summary.Endpoints = append(summary.Endpoints, endpointCopy)
                }</span>
                <span class="cov2" title="3">m.endpointMu.RUnlock()</span>
        }

        <span class="cov5" title="13">return summary</span>
}

// Reset resets all metrics
func (m *Metrics) Reset() <span class="cov2" title="2">{
        atomic.StoreInt64(&amp;m.totalRequests, 0)
        atomic.StoreInt64(&amp;m.successfulRequests, 0)
        atomic.StoreInt64(&amp;m.failedRequests, 0)
        atomic.StoreInt64(&amp;m.totalRequestTime, 0)
        atomic.StoreInt64(&amp;m.minRequestTime, int64(^uint64(0)&gt;&gt;1))
        atomic.StoreInt64(&amp;m.maxRequestTime, 0)
        atomic.StoreInt64(&amp;m.status2xx, 0)
        atomic.StoreInt64(&amp;m.status3xx, 0)
        atomic.StoreInt64(&amp;m.status4xx, 0)
        atomic.StoreInt64(&amp;m.status5xx, 0)

        m.endpointMu.Lock()
        m.endpointMetrics = make(map[string]*EndpointMetrics)
        m.endpointMu.Unlock()

        m.startTime = time.Now()

        m.lastRequestMu.Lock()
        m.lastRequestTime = time.Time{}
        m.lastRequestMu.Unlock()
}</span>

// MetricsMiddleware creates middleware for metrics collection
func MetricsMiddleware(metrics *Metrics) gin.HandlerFunc <span class="cov2" title="2">{
        return func(c *gin.Context) </span><span class="cov4" title="9">{
                start := time.Now()

                // Process request
                c.Next()

                // Record metrics
                duration := time.Since(start)
                metrics.RecordRequest(duration, c.Writer.Status(), c.Request.URL.Path, c.Request.Method)
        }</span>
}

// Global metrics instance
var globalMetrics = NewMetrics()

// GetGlobalMetrics returns the global metrics instance
func GetGlobalMetrics() *Metrics <span class="cov2" title="2">{
        return globalMetrics
}</span>

// HealthStatus represents application health status
type HealthStatus struct {
        Status      string        `json:"status"`
        Uptime      time.Duration `json:"uptime"`
        Version     string        `json:"version"`
        Database    string        `json:"database"`
        Cache       string        `json:"cache,omitempty"`
        Metrics     *MetricsSummary `json:"metrics,omitempty"`
        Timestamp   time.Time     `json:"timestamp"`
}

// HealthCheck performs a health check
type HealthCheck struct {
        Version string
        DBPing  func() error
}

// Check performs health check
func (hc *HealthCheck) Check(includeMetrics bool) *HealthStatus <span class="cov2" title="3">{
        status := "healthy"
        dbStatus := "connected"

        // Check database
        if hc.DBPing != nil </span><span class="cov2" title="3">{
                if err := hc.DBPing(); err != nil </span><span class="cov1" title="1">{
                        status = "unhealthy"
                        dbStatus = "disconnected"
                }</span>
        }

        <span class="cov2" title="3">health := &amp;HealthStatus{
                Status:    status,
                Uptime:    time.Since(globalMetrics.startTime),
                Version:   hc.Version,
                Database:  dbStatus,
                Timestamp: time.Now(),
        }

        if includeMetrics </span><span class="cov1" title="1">{
                health.Metrics = globalMetrics.GetSummary(true)
        }</span>

        <span class="cov2" title="3">return health</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// JWTMiddleware creates a middleware for JWT validation
type JWTMiddleware struct {
        authService services.AuthService
        secretKey   string // For local JWT validation (optional)
}

// NewJWTMiddleware creates a new JWT middleware
func NewJWTMiddleware(authService services.AuthService, secretKey string) *JWTMiddleware <span class="cov6" title="8">{
        return &amp;JWTMiddleware{
                authService: authService,
                secretKey:   secretKey,
        }
}</span>

// Validate is a Gin middleware that validates JWT tokens
func (m *JWTMiddleware) Validate() gin.HandlerFunc <span class="cov6" title="7">{
        return func(c *gin.Context) </span><span class="cov6" title="7">{
                // Get token from Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeMissingJWT,
                                "Missing Authorization header",
                                "",
                        ))
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;" format
                <span class="cov5" title="6">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeInvalidJWT,
                                "Invalid Authorization header format",
                                "",
                        ))
                        return
                }</span>

                <span class="cov5" title="5">token := parts[1]

                // Validate token
                claims, err := m.validateToken(c.Request.Context(), token)
                if err != nil </span><span class="cov3" title="3">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeInvalidJWT,
                                err.Error(),
                                "",
                        ))
                        return
                }</span>

                // Store claims in context for handlers to use
                <span class="cov2" title="2">c.Set("claims", claims)
                c.Set("username", claims.Username)

                c.Next()</span>
        }
}

// ValidateToken is a public method to validate JWT tokens
func (m *JWTMiddleware) ValidateToken(ctx context.Context, tokenString string) (*models.JWTClaims, error) <span class="cov0" title="0">{
        return m.validateToken(ctx, tokenString)
}</span>

// validateToken validates the JWT token using either the auth service or local validation
func (m *JWTMiddleware) validateToken(ctx context.Context, tokenString string) (*models.JWTClaims, error) <span class="cov5" title="5">{
        // If auth service is enabled, use it for validation
        if m.authService != nil &amp;&amp; m.authService.IsEnabled() </span><span class="cov2" title="2">{
                return m.authService.ValidateToken(ctx, tokenString)
        }</span>

        // Otherwise, validate locally (always available with default or provided secret key)
        <span class="cov3" title="3">return m.validateTokenLocally(tokenString)</span>
}

// validateTokenLocally validates the JWT token locally using the secret key
func (m *JWTMiddleware) validateTokenLocally(tokenString string) (*models.JWTClaims, error) <span class="cov3" title="3">{
        // Use default secret key if not provided
        secretKey := m.secretKey
        if secretKey == "" </span><span class="cov0" title="0">{
                secretKey = "helix-track-default-secret-key-change-in-production"
        }</span>

        <span class="cov3" title="3">token, err := jwt.ParseWithClaims(tokenString, &amp;models.JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov3" title="3">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, jwt.ErrSignatureInvalid
                }</span>
                <span class="cov3" title="3">return []byte(secretKey), nil</span>
        })

        <span class="cov3" title="3">if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if claims, ok := token.Claims.(*models.JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov1" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, jwt.ErrTokenInvalidClaims</span>
}

// GetClaims retrieves JWT claims from the Gin context
func GetClaims(c *gin.Context) (*models.JWTClaims, bool) <span class="cov5" title="5">{
        claims, exists := c.Get("claims")
        if !exists </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        <span class="cov4" title="4">jwtClaims, ok := claims.(*models.JWTClaims)
        return jwtClaims, ok</span>
}

// GetUsername retrieves the username from the Gin context
func GetUsername(c *gin.Context) (string, bool) <span class="cov10" title="32">{
        username, exists := c.Get("username")
        if !exists </span><span class="cov4" title="4">{
                return "", false
        }</span>

        <span class="cov9" title="28">usernameStr, ok := username.(string)
        return usernameStr, ok</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// CompressionMiddleware provides response compression
func CompressionMiddleware(level int) gin.HandlerFunc <span class="cov4" title="4">{
        if level &lt; gzip.DefaultCompression || level &gt; gzip.BestCompression </span><span class="cov0" title="0">{
                level = gzip.DefaultCompression
        }</span>

        // Pool of gzip writers for reuse
        <span class="cov4" title="4">gzipPool := sync.Pool{
                New: func() interface{} </span><span class="cov2" title="2">{
                        gz, _ := gzip.NewWriterLevel(io.Discard, level)
                        return gz
                }</span>,
        }

        <span class="cov4" title="4">return func(c *gin.Context) </span><span class="cov4" title="4">{
                // Check if client supports gzip
                if !strings.Contains(c.GetHeader("Accept-Encoding"), "gzip") </span><span class="cov2" title="2">{
                        c.Next()
                        return
                }</span>

                // Don't compress if content is already compressed
                <span class="cov2" title="2">if c.GetHeader("Content-Encoding") != "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Get gzip writer from pool
                <span class="cov2" title="2">gz := gzipPool.Get().(*gzip.Writer)
                defer gzipPool.Put(gz)

                gz.Reset(c.Writer)
                defer gz.Close()

                // Wrap response writer
                c.Writer = &amp;gzipResponseWriter{
                        ResponseWriter: c.Writer,
                        writer:         gz,
                }

                c.Header("Content-Encoding", "gzip")
                c.Header("Vary", "Accept-Encoding")

                c.Next()</span>
        }
}

// gzipResponseWriter wraps gin.ResponseWriter with gzip compression
type gzipResponseWriter struct {
        gin.ResponseWriter
        writer *gzip.Writer
}

func (g *gzipResponseWriter) Write(data []byte) (int, error) <span class="cov4" title="3">{
        return g.writer.Write(data)
}</span>

func (g *gzipResponseWriter) WriteString(s string) (int, error) <span class="cov1" title="1">{
        return g.writer.Write([]byte(s))
}</span>

// RateLimiterConfig contains rate limiting configuration
type RateLimiterConfig struct {
        RequestsPerSecond int           // Maximum requests per second
        BurstSize         int           // Maximum burst size
        CleanupInterval   time.Duration // Cleanup interval for old entries
}

// DefaultRateLimiterConfig returns optimized default settings
func DefaultRateLimiterConfig() RateLimiterConfig <span class="cov4" title="4">{
        return RateLimiterConfig{
                RequestsPerSecond: 1000,              // 1000 req/sec
                BurstSize:         2000,              // Allow bursts up to 2000
                CleanupInterval:   1 * time.Minute,   // Cleanup every minute
        }
}</span>

// tokenBucket represents a token bucket for rate limiting
type tokenBucket struct {
        tokens         float64
        lastRefill     time.Time
        maxTokens      float64
        refillRate     float64 // tokens per second
        mu             sync.Mutex
}

// rateLimiter implements rate limiting
type rateLimiter struct {
        buckets         map[string]*tokenBucket
        mu              sync.RWMutex
        config          RateLimiterConfig
        stopCleanup     chan struct{}
        cleanupDone     sync.WaitGroup
}

// newRateLimiter creates a new rate limiter
func newRateLimiter(cfg RateLimiterConfig) *rateLimiter <span class="cov4" title="3">{
        rl := &amp;rateLimiter{
                buckets:     make(map[string]*tokenBucket),
                config:      cfg,
                stopCleanup: make(chan struct{}),
        }

        // Start background cleanup
        rl.cleanupDone.Add(1)
        go rl.cleanupLoop()

        return rl
}</span>

// allow checks if a request is allowed
func (rl *rateLimiter) allow(key string) bool <span class="cov9" title="18">{
        rl.mu.RLock()
        bucket, exists := rl.buckets[key]
        rl.mu.RUnlock()

        if !exists </span><span class="cov4" title="3">{
                rl.mu.Lock()
                // Double-check after acquiring write lock
                bucket, exists = rl.buckets[key]
                if !exists </span><span class="cov4" title="3">{
                        bucket = &amp;tokenBucket{
                                tokens:     float64(rl.config.BurstSize),
                                lastRefill: time.Now(),
                                maxTokens:  float64(rl.config.BurstSize),
                                refillRate: float64(rl.config.RequestsPerSecond),
                        }
                        rl.buckets[key] = bucket
                }</span>
                <span class="cov4" title="3">rl.mu.Unlock()</span>
        }

        <span class="cov9" title="18">return bucket.take()</span>
}

// take attempts to take a token from the bucket
func (tb *tokenBucket) take() bool <span class="cov10" title="25">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        now := time.Now()
        elapsed := now.Sub(tb.lastRefill).Seconds()

        // Refill tokens based on elapsed time
        tb.tokens += elapsed * tb.refillRate
        if tb.tokens &gt; tb.maxTokens </span><span class="cov4" title="4">{
                tb.tokens = tb.maxTokens
        }</span>
        <span class="cov10" title="25">tb.lastRefill = now

        // Check if we have tokens available
        if tb.tokens &gt;= 1.0 </span><span class="cov9" title="23">{
                tb.tokens -= 1.0
                return true
        }</span>

        <span class="cov2" title="2">return false</span>
}

// cleanupLoop removes old buckets
func (rl *rateLimiter) cleanupLoop() <span class="cov4" title="3">{
        defer rl.cleanupDone.Done()

        ticker := time.NewTicker(rl.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov5" title="5">{
                select </span>{
                case &lt;-ticker.C:<span class="cov2" title="2">
                        rl.cleanup()</span>
                case &lt;-rl.stopCleanup:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// cleanup removes inactive buckets
func (rl *rateLimiter) cleanup() <span class="cov2" title="2">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        for key, bucket := range rl.buckets </span><span class="cov2" title="2">{
                bucket.mu.Lock()
                inactive := now.Sub(bucket.lastRefill) &gt; 5*time.Minute
                bucket.mu.Unlock()

                if inactive </span><span class="cov0" title="0">{
                        delete(rl.buckets, key)
                }</span>
        }
}

// close stops the rate limiter
func (rl *rateLimiter) close() <span class="cov1" title="1">{
        close(rl.stopCleanup)
        rl.cleanupDone.Wait()
}</span>

// RateLimitMiddleware creates rate limiting middleware
func RateLimitMiddleware(cfg RateLimiterConfig) gin.HandlerFunc <span class="cov2" title="2">{
        limiter := newRateLimiter(cfg)

        return func(c *gin.Context) </span><span class="cov8" title="17">{
                // Use client IP as key
                key := c.ClientIP()

                if !limiter.allow(key) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                                "retry_after": "1s",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="16">c.Next()</span>
        }
}

// CircuitBreakerConfig contains circuit breaker configuration
type CircuitBreakerConfig struct {
        MaxFailures     int           // Maximum failures before opening
        Timeout         time.Duration // Timeout before attempting to close
        HalfOpenMax     int           // Maximum requests in half-open state
        FailureRatio    float64       // Failure ratio threshold (0.0 - 1.0)
        MinRequests     int           // Minimum requests before evaluating ratio
}

// DefaultCircuitBreakerConfig returns optimized default settings
func DefaultCircuitBreakerConfig() CircuitBreakerConfig <span class="cov4" title="3">{
        return CircuitBreakerConfig{
                MaxFailures:  5,
                Timeout:      30 * time.Second,
                HalfOpenMax:  3,
                FailureRatio: 0.5,
                MinRequests:  10,
        }
}</span>

// circuitState represents circuit breaker state
type circuitState int

const (
        stateClosed circuitState = iota
        stateOpen
        stateHalfOpen
)

// circuitBreaker implements circuit breaker pattern
type circuitBreaker struct {
        config          CircuitBreakerConfig
        state           circuitState
        failures        int
        successes       int
        totalRequests   int
        halfOpenCount   int
        lastFailureTime time.Time
        mu              sync.RWMutex
}

// newCircuitBreaker creates a new circuit breaker
func newCircuitBreaker(cfg CircuitBreakerConfig) *circuitBreaker <span class="cov2" title="2">{
        return &amp;circuitBreaker{
                config: cfg,
                state:  stateClosed,
        }
}</span>

// allow checks if request is allowed through circuit breaker
func (cb *circuitBreaker) allow() bool <span class="cov5" title="5">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        switch cb.state </span>{
        case stateClosed:<span class="cov4" title="3">
                return true</span>

        case stateOpen:<span class="cov2" title="2">
                // Check if we should transition to half-open
                if time.Since(cb.lastFailureTime) &gt; cb.config.Timeout </span><span class="cov1" title="1">{
                        cb.state = stateHalfOpen
                        cb.halfOpenCount = 0
                        return true
                }</span>
                <span class="cov1" title="1">return false</span>

        case stateHalfOpen:<span class="cov0" title="0">
                // Allow limited requests in half-open state
                if cb.halfOpenCount &lt; cb.config.HalfOpenMax </span><span class="cov0" title="0">{
                        cb.halfOpenCount++
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>

        default:<span class="cov0" title="0">
                return false</span>
        }
}

// recordSuccess records a successful request
func (cb *circuitBreaker) recordSuccess() <span class="cov2" title="2">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.successes++
        cb.totalRequests++

        if cb.state == stateHalfOpen </span><span class="cov2" title="2">{
                // Transition to closed if enough successes
                if cb.successes &gt;= cb.config.HalfOpenMax </span><span class="cov1" title="1">{
                        cb.state = stateClosed
                        cb.failures = 0
                        cb.successes = 0
                        cb.totalRequests = 0
                }</span>
        }
}

// recordFailure records a failed request
func (cb *circuitBreaker) recordFailure() <span class="cov5" title="5">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.failures++
        cb.totalRequests++
        cb.lastFailureTime = time.Now()

        // Check if we should open the circuit
        if cb.state == stateClosed </span><span class="cov5" title="5">{
                // Check max failures
                if cb.failures &gt;= cb.config.MaxFailures </span><span class="cov2" title="2">{
                        cb.state = stateOpen
                        return
                }</span>

                // Check failure ratio
                <span class="cov4" title="3">if cb.totalRequests &gt;= cb.config.MinRequests </span><span class="cov0" title="0">{
                        ratio := float64(cb.failures) / float64(cb.totalRequests)
                        if ratio &gt;= cb.config.FailureRatio </span><span class="cov0" title="0">{
                                cb.state = stateOpen
                                return
                        }</span>
                }
        } else<span class="cov0" title="0"> if cb.state == stateHalfOpen </span><span class="cov0" title="0">{
                // Any failure in half-open state opens the circuit
                cb.state = stateOpen
        }</span>
}

// getState returns current circuit state
func (cb *circuitBreaker) getState() circuitState <span class="cov4" title="3">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()
        return cb.state
}</span>

// CircuitBreakerMiddleware creates circuit breaker middleware
func CircuitBreakerMiddleware(cfg CircuitBreakerConfig) gin.HandlerFunc <span class="cov1" title="1">{
        breaker := newCircuitBreaker(cfg)

        return func(c *gin.Context) </span><span class="cov4" title="4">{
                if !breaker.allow() </span><span class="cov1" title="1">{
                        c.JSON(http.StatusServiceUnavailable, gin.H{
                                "error": "Service temporarily unavailable",
                                "retry_after": cfg.Timeout.String(),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov4" title="3">c.Next()

                // Record result based on status code
                if c.Writer.Status() &gt;= 500 </span><span class="cov4" title="3">{
                        breaker.recordFailure()
                }</span> else<span class="cov0" title="0"> {
                        breaker.recordSuccess()
                }</span>
        }
}

// TimeoutMiddleware adds request timeout
func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                // Create context with timeout
                ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
                defer cancel()

                // Replace request context
                c.Request = c.Request.WithContext(ctx)

                // Channel to signal when request is done
                finished := make(chan struct{})

                go func() </span><span class="cov2" title="2">{
                        c.Next()
                        close(finished)
                }</span>()

                <span class="cov2" title="2">select </span>{
                case &lt;-finished:<span class="cov1" title="1">
                        // Request completed successfully
                        return</span>
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        // Timeout occurred
                        c.JSON(http.StatusRequestTimeout, gin.H{
                                "error": "Request timeout",
                        })
                        c.Abort()</span>
                }
        }
}

// CORSConfig contains CORS configuration
type CORSConfig struct {
        AllowOrigins     []string
        AllowMethods     []string
        AllowHeaders     []string
        ExposeHeaders    []string
        AllowCredentials bool
        MaxAge           time.Duration
}

// DefaultCORSConfig returns default CORS configuration
func DefaultCORSConfig() CORSConfig <span class="cov4" title="4">{
        return CORSConfig{
                AllowOrigins:     []string{"*"},
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: false,
                MaxAge:           12 * time.Hour,
        }
}</span>

// CORSMiddleware creates CORS middleware
func CORSMiddleware(cfg CORSConfig) gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov4" title="3">{
                origin := c.Request.Header.Get("Origin")

                // Set CORS headers
                if len(cfg.AllowOrigins) &gt; 0 </span><span class="cov4" title="3">{
                        if cfg.AllowOrigins[0] == "*" </span><span class="cov2" title="2">{
                                c.Header("Access-Control-Allow-Origin", "*")
                        }</span> else<span class="cov1" title="1"> {
                                for _, allowedOrigin := range cfg.AllowOrigins </span><span class="cov1" title="1">{
                                        if origin == allowedOrigin </span><span class="cov1" title="1">{
                                                c.Header("Access-Control-Allow-Origin", origin)
                                                break</span>
                                        }
                                }
                        }
                }

                <span class="cov4" title="3">if len(cfg.AllowMethods) &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Allow-Methods", strings.Join(cfg.AllowMethods, ", "))
                }</span>

                <span class="cov4" title="3">if len(cfg.AllowHeaders) &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Allow-Headers", strings.Join(cfg.AllowHeaders, ", "))
                }</span>

                <span class="cov4" title="3">if len(cfg.ExposeHeaders) &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Expose-Headers", strings.Join(cfg.ExposeHeaders, ", "))
                }</span>

                <span class="cov4" title="3">if cfg.AllowCredentials </span><span class="cov1" title="1">{
                        c.Header("Access-Control-Allow-Credentials", "true")
                }</span>

                <span class="cov4" title="3">if cfg.MaxAge &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Max-Age", fmt.Sprintf("%.0f", cfg.MaxAge.Seconds()))
                }</span>

                // Handle preflight requests
                <span class="cov4" title="3">if c.Request.Method == "OPTIONS" </span><span class="cov1" title="1">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov2" title="2">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// PermissionMiddleware creates a middleware for permission checking
func PermissionMiddleware(permService services.PermissionService) gin.HandlerFunc <span class="cov7" title="6">{
        return func(c *gin.Context) </span><span class="cov7" title="6">{
                // Skip permission check if service is not enabled
                if !permService.IsEnabled() </span><span class="cov1" title="1">{
                        c.Next()
                        return
                }</span>

                // Get JWT claims from context (set by JWT middleware)
                <span class="cov6" title="5">claims, exists := c.Get("claims")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "No authentication provided",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov6" title="4">jwtClaims, ok := claims.(*models.JWTClaims)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "Invalid authentication claims",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                // Store username in context for later use
                <span class="cov4" title="3">c.Set("username", jwtClaims.Username)
                c.Set("permissionService", permService)

                c.Next()</span>
        }
}

// RequirePermission creates a middleware that requires a specific permission level
func RequirePermission(permService services.PermissionService, context string, level models.PermissionLevel) gin.HandlerFunc <span class="cov10" title="12">{
        return func(c *gin.Context) </span><span class="cov10" title="12">{
                // Skip permission check if service is not enabled
                if !permService.IsEnabled() </span><span class="cov1" title="1">{
                        c.Next()
                        return
                }</span>

                <span class="cov9" title="11">username, exists := c.Get("username")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "No username in context",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov9" title="10">usernameStr, ok := username.(string)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Invalid username type",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                // Check permission
                <span class="cov8" title="9">allowed, err := permService.CheckPermission(c.Request.Context(), usernameStr, context, level)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Permission check failed: "+err.Error(),
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="8">if !allowed </span><span class="cov4" title="3">{
                        c.JSON(http.StatusForbidden, models.NewErrorResponse(
                                models.ErrorCodeForbidden,
                                "Permission denied",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov6" title="5">c.Next()</span>
        }
}

// CheckPermissionForAction checks permission for a specific action and context
func CheckPermissionForAction(c *gin.Context, permService services.PermissionService, action, context string) bool <span class="cov9" title="10">{
        // Skip permission check if service is not enabled
        if !permService.IsEnabled() </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov8" title="9">username, exists := c.Get("username")
        if !exists </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="8">usernameStr, ok := username.(string)
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>

        // Determine required permission level from action
        <span class="cov8" title="7">requiredLevel := models.GetRequiredPermissionLevel(action)

        // Check permission
        allowed, err := permService.CheckPermission(c.Request.Context(), usernameStr, context, requiredLevel)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov7" title="6">return allowed</span>
}

// GetUserPermissions retrieves all permissions for the current user
func GetUserPermissions(c *gin.Context, permService services.PermissionService) ([]models.Permission, error) <span class="cov6" title="4">{
        username, exists := c.Get("username")
        if !exists </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov4" title="3">usernameStr, ok := username.(string)
        if !ok </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov3" title="2">return permService.GetUserPermissions(c.Request.Context(), usernameStr)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/security/engine"
)

// RBACMiddleware enforces role-based access control using the Security Engine
func RBACMiddleware(securityEngine engine.Engine, resource string, action engine.Action) gin.HandlerFunc <span class="cov9" title="18">{
        return func(c *gin.Context) </span><span class="cov9" title="18">{
                username, exists := GetUsername(c)
                if !exists </span><span class="cov1" title="1">{
                        logger.Warn("RBAC middleware: no username in context")
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "Authentication required",
                                "",
                        ))
                        return
                }</span>

                // Extract resource ID from request (if available)
                <span class="cov9" title="17">resourceID := extractResourceID(c, resource)

                // Build access request
                accessReq := engine.AccessRequest{
                        Username:   username,
                        Resource:   resource,
                        ResourceID: resourceID,
                        Action:     action,
                        Context:    extractContext(c),
                }

                // Check access
                response, err := securityEngine.CheckAccess(c.Request.Context(), accessReq)
                if err != nil </span><span class="cov3" title="2">{
                        logger.Error("RBAC middleware: access check failed",
                                zap.Error(err),
                                zap.String("username", username),
                                zap.String("resource", resource),
                        )
                        c.AbortWithStatusJSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Authorization check failed",
                                "",
                        ))
                        return
                }</span>

                <span class="cov9" title="15">if !response.Allowed </span><span class="cov1" title="1">{
                        logger.Warn("RBAC middleware: access denied",
                                zap.String("username", username),
                                zap.String("resource", resource),
                                zap.String("resource_id", resourceID),
                                zap.String("action", string(action)),
                                zap.String("reason", response.Reason),
                        )
                        c.AbortWithStatusJSON(http.StatusForbidden, models.NewErrorResponse(
                                models.ErrorCodeForbidden,
                                response.Reason,
                                "",
                        ))
                        return
                }</span>

                <span class="cov8" title="14">logger.Debug("RBAC middleware: access granted",
                        zap.String("username", username),
                        zap.String("resource", resource),
                        zap.String("action", string(action)),
                )

                // Store authorization result in context for handlers to use
                c.Set("rbac_authorized", true)
                c.Set("rbac_resource", resource)
                c.Set("rbac_action", string(action))

                c.Next()</span>
        }
}

// RequireSecurityLevel creates middleware that enforces security level checks
func RequireSecurityLevel(securityEngine engine.Engine) gin.HandlerFunc <span class="cov5" title="5">{
        return func(c *gin.Context) </span><span class="cov5" title="5">{
                username, exists := GetUsername(c)
                if !exists </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "Authentication required",
                                "",
                        ))
                        return
                }</span>

                // Get entity ID from request parameters
                <span class="cov5" title="4">entityID := c.Param("id")
                if entityID == "" </span><span class="cov1" title="1">{
                        entityID = c.Query("id")
                }</span>

                <span class="cov5" title="4">if entityID == "" </span><span class="cov1" title="1">{
                        // No specific entity, allow - will be checked at entity level
                        c.Next()
                        return
                }</span>

                // Check security level access
                <span class="cov4" title="3">hasAccess, err := securityEngine.ValidateSecurityLevel(c.Request.Context(), username, entityID)
                if err != nil </span><span class="cov1" title="1">{
                        logger.Error("Security level check failed",
                                zap.Error(err),
                                zap.String("username", username),
                                zap.String("entity_id", entityID),
                        )
                        c.AbortWithStatusJSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Security level validation failed",
                                "",
                        ))
                        return
                }</span>

                <span class="cov3" title="2">if !hasAccess </span><span class="cov1" title="1">{
                        logger.Warn("Security level access denied",
                                zap.String("username", username),
                                zap.String("entity_id", entityID),
                        )
                        c.AbortWithStatusJSON(http.StatusForbidden, models.NewErrorResponse(
                                models.ErrorCodeForbidden,
                                "Insufficient security clearance for this resource",
                                "",
                        ))
                        return
                }</span>

                <span class="cov1" title="1">c.Set("security_level_checked", true)
                c.Next()</span>
        }
}

// RequireProjectRole creates middleware that requires a specific project role
func RequireProjectRole(securityEngine engine.Engine, requiredRole string) gin.HandlerFunc <span class="cov5" title="4">{
        return func(c *gin.Context) </span><span class="cov5" title="4">{
                username, exists := GetUsername(c)
                if !exists </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "Authentication required",
                                "",
                        ))
                        return
                }</span>

                // Get project ID from request
                <span class="cov5" title="4">projectID := c.Param("projectId")
                if projectID == "" </span><span class="cov1" title="1">{
                        projectID = c.Query("projectId")
                }</span>
                <span class="cov5" title="4">if projectID == "" </span><span class="cov1" title="1">{
                        projectID = c.GetString("project_id")
                }</span>

                <span class="cov5" title="4">if projectID == "" </span><span class="cov1" title="1">{
                        logger.Warn("Project role check: no project ID in request")
                        c.AbortWithStatusJSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeMissingData,
                                "Project ID required",
                                "",
                        ))
                        return
                }</span>

                // Check if user has the required role
                <span class="cov4" title="3">hasRole, err := securityEngine.EvaluateRole(c.Request.Context(), username, projectID, requiredRole)
                if err != nil </span><span class="cov1" title="1">{
                        logger.Error("Project role check failed",
                                zap.Error(err),
                                zap.String("username", username),
                                zap.String("project_id", projectID),
                                zap.String("required_role", requiredRole),
                        )
                        c.AbortWithStatusJSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Role validation failed",
                                "",
                        ))
                        return
                }</span>

                <span class="cov3" title="2">if !hasRole </span><span class="cov1" title="1">{
                        logger.Warn("Project role check: insufficient role",
                                zap.String("username", username),
                                zap.String("project_id", projectID),
                                zap.String("required_role", requiredRole),
                        )
                        c.AbortWithStatusJSON(http.StatusForbidden, models.NewErrorResponse(
                                models.ErrorCodeForbidden,
                                "Insufficient project role for this operation",
                                "",
                        ))
                        return
                }</span>

                <span class="cov1" title="1">c.Set("project_role_checked", true)
                c.Set("project_role", requiredRole)
                c.Next()</span>
        }
}

// SecurityContextMiddleware adds security context to the request
func SecurityContextMiddleware(securityEngine engine.Engine) gin.HandlerFunc <span class="cov3" title="2">{
        return func(c *gin.Context) </span><span class="cov3" title="2">{
                username, exists := GetUsername(c)
                if !exists </span><span class="cov1" title="1">{
                        // No user, skip security context
                        c.Next()
                        return
                }</span>

                // Get security context for user
                <span class="cov1" title="1">secCtx, err := securityEngine.GetSecurityContext(c.Request.Context(), username)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to get security context",
                                zap.Error(err),
                                zap.String("username", username),
                        )
                        // Don't fail the request, just log the error
                        c.Next()
                        return
                }</span>

                // Store security context in Gin context
                <span class="cov1" title="1">c.Set("security_context", secCtx)

                logger.Debug("Security context loaded",
                        zap.String("username", username),
                        zap.Int("role_count", len(secCtx.Roles)),
                        zap.Int("team_count", len(secCtx.Teams)),
                )

                c.Next()</span>
        }
}

// extractResourceID extracts the resource ID from the request
func extractResourceID(c *gin.Context, resource string) string <span class="cov10" title="21">{
        // Try URL parameters first
        if id := c.Param("id"); id != "" </span><span class="cov3" title="2">{
                return id
        }</span>

        // Try query parameters
        <span class="cov9" title="19">if id := c.Query("id"); id != "" </span><span class="cov1" title="1">{
                return id
        }</span>

        // Try resource-specific ID parameter
        <span class="cov9" title="18">idParam := resource + "Id"
        if id := c.Param(idParam); id != "" </span><span class="cov1" title="1">{
                return id
        }</span>
        <span class="cov9" title="17">if id := c.Query(idParam); id != "" </span><span class="cov0" title="0">{
                return id
        }</span>

        // Try to extract from JSON body (if POST/PUT)
        <span class="cov9" title="17">if c.Request.Method == "POST" || c.Request.Method == "PUT" </span><span class="cov1" title="1">{
                var body map[string]interface{}
                if err := c.ShouldBindJSON(&amp;body); err == nil </span><span class="cov1" title="1">{
                        if id, ok := body["id"].(string); ok &amp;&amp; id != "" </span><span class="cov1" title="1">{
                                return id
                        }</span>
                        <span class="cov0" title="0">if id, ok := body[idParam].(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                                return id
                        }</span>
                }
        }

        <span class="cov9" title="16">return ""</span>
}

// extractContext extracts additional context from the request
func extractContext(c *gin.Context) map[string]string <span class="cov9" title="18">{
        context := make(map[string]string)

        // Extract project ID if available
        if projectID := c.Param("projectId"); projectID != "" </span><span class="cov1" title="1">{
                context["project_id"] = projectID
        }</span> else<span class="cov9" title="17"> if projectID := c.Query("projectId"); projectID != "" </span><span class="cov0" title="0">{
                context["project_id"] = projectID
        }</span>

        // Extract team ID if available
        <span class="cov9" title="18">if teamID := c.Param("teamId"); teamID != "" </span><span class="cov1" title="1">{
                context["team_id"] = teamID
        }</span> else<span class="cov9" title="17"> if teamID := c.Query("teamId"); teamID != "" </span><span class="cov0" title="0">{
                context["team_id"] = teamID
        }</span>

        // Add IP address and user agent
        <span class="cov9" title="18">context["ip_address"] = c.ClientIP()
        context["user_agent"] = c.Request.UserAgent()
        context["request_path"] = c.Request.URL.Path
        context["request_method"] = c.Request.Method

        return context</span>
}

// GetSecurityContext retrieves the security context from Gin context
func GetSecurityContext(c *gin.Context) (*engine.SecurityContext, bool) <span class="cov5" title="4">{
        secCtxInterface, exists := c.Get("security_context")
        if !exists </span><span class="cov3" title="2">{
                return nil, false
        }</span>

        <span class="cov3" title="2">secCtx, ok := secCtxInterface.(*engine.SecurityContext)
        return secCtx, ok</span>
}

// IsAuthorized checks if the current request has been authorized
func IsAuthorized(c *gin.Context) bool <span class="cov4" title="3">{
        authorized, exists := c.Get("rbac_authorized")
        if !exists </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov3" title="2">return authorized.(bool)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

// Asset represents a file attachment or asset (images, documents, files)
type Asset struct {
        ID          string `json:"id" db:"id"`
        URL         string `json:"url" db:"url" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// AssetTicketMapping represents the many-to-many relationship between assets and tickets
type AssetTicketMapping struct {
        ID       string `json:"id" db:"id"`
        AssetID  string `json:"assetId" db:"asset_id" binding:"required"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// AssetCommentMapping represents the many-to-many relationship between assets and comments
type AssetCommentMapping struct {
        ID        string `json:"id" db:"id"`
        AssetID   string `json:"assetId" db:"asset_id" binding:"required"`
        CommentID string `json:"commentId" db:"comment_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// AssetProjectMapping represents the many-to-many relationship between assets and projects
type AssetProjectMapping struct {
        ID        string `json:"id" db:"id"`
        AssetID   string `json:"assetId" db:"asset_id" binding:"required"`
        ProjectID string `json:"projectId" db:"project_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// AssetTeamMapping represents the many-to-many relationship between assets and teams
type AssetTeamMapping struct {
        ID       string `json:"id" db:"id"`
        AssetID  string `json:"assetId" db:"asset_id" binding:"required"`
        TeamID   string `json:"teamId" db:"team_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// GetDisplayName returns a user-friendly display name
func (a *Asset) GetDisplayName() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">if a.URL != "" </span><span class="cov0" title="0">{
                return a.URL
        }</span>
        <span class="cov0" title="0">return "Unknown Asset"</span>
}

// IsValid checks if the asset has required fields
func (a *Asset) IsValid() bool <span class="cov0" title="0">{
        return a.URL != ""
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

// Audit represents an audit log entry tracking actions in the system
type Audit struct {
        ID           string `json:"id" db:"id"`
        Action       string `json:"action" db:"action" binding:"required"`       // The action performed
        UserID       string `json:"userId" db:"user_id"`                         // User who performed the action
        EntityID     string `json:"entityId" db:"entity_id"`                     // ID of the entity affected
        EntityType   string `json:"entityType" db:"entity_type"`                 // Type of entity (project, ticket, etc.)
        Details      string `json:"details,omitempty" db:"details"`              // JSON encoded details
        IsPublic     bool   `json:"isPublic" db:"is_public"`                     // V3: Whether activity is public
        ActivityType string `json:"activityType,omitempty" db:"activity_type"`   // V3: Type of activity (comment, status_change, etc.)
        Created      int64  `json:"created" db:"created"`
        Modified     int64  `json:"modified" db:"modified"`
        Deleted      bool   `json:"deleted" db:"deleted"`
}

// AuditMetaData represents additional metadata for audit entries
type AuditMetaData struct {
        ID       string `json:"id" db:"id"`
        AuditID  string `json:"auditId" db:"audit_id" binding:"required"`
        Property string `json:"property" db:"property" binding:"required"`
        Value    string `json:"value" db:"value"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// Valid audit actions
var validAuditActions = map[string]bool{
        // Standard CRUD actions
        ActionCreate:        true,
        ActionRead:          true,
        ActionModify:        true,
        ActionRemove:        true,
        ActionList:          true,
        ActionAuthenticate:  true,

        // Entity-specific actions
        "login":            true,
        "logout":           true,
        "permission_change": true,
        "status_change":    true,
        "assignment_change": true,
        "comment_add":      true,
        "attachment_add":   true,
        "workflow_transition": true,
}

// IsValidAction validates if the action is a recognized audit action
func (a *Audit) IsValidAction() bool <span class="cov0" title="0">{
        return validAuditActions[a.Action]
}</span>

// HasEntity checks if the audit entry has entity information
func (a *Audit) HasEntity() bool <span class="cov0" title="0">{
        return a.EntityID != "" &amp;&amp; a.EntityType != ""
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

// Board represents a Kanban/Scrum board for organizing tickets
type Board struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
        Version     int    `json:"version" db:"version"` // Optimistic locking version
}

// BoardMetaData represents additional metadata for boards (properties like board type, columns, etc.)
type BoardMetaData struct {
        ID       string `json:"id" db:"id"`
        BoardID  string `json:"boardId" db:"board_id" binding:"required"`
        Property string `json:"property" db:"property" binding:"required"`
        Value    string `json:"value" db:"value"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// TicketBoardMapping represents the relationship between tickets and boards
type TicketBoardMapping struct {
        ID       string `json:"id" db:"id"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        BoardID  string `json:"boardId" db:"board_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// Common board metadata property keys
const (
        BoardPropertyType        = "type"        // kanban, scrum, custom
        BoardPropertyColumns     = "columns"     // JSON array of column definitions
        BoardPropertyDefaultView = "defaultView" // list, board, calendar
        BoardPropertyOwner       = "owner"       // User ID of board owner
        BoardPropertyTeam        = "team"        // Team ID if board is team-specific
        BoardPropertyProject     = "project"     // Project ID if board is project-specific
)

// Board type constants
const (
        BoardTypeKanban = "kanban"
        BoardTypeScrum  = "scrum"
        BoardTypeCustom = "custom"
)

// GetDisplayName returns a user-friendly display name for the board
func (b *Board) GetDisplayName() string <span class="cov0" title="0">{
        if b.Title != "" </span><span class="cov0" title="0">{
                return b.Title
        }</span>
        <span class="cov0" title="0">return "Untitled Board"</span>
}

// IsValid checks if the board has required fields
func (b *Board) IsValid() bool <span class="cov0" title="0">{
        return b.ID != "" &amp;&amp; b.Title != ""
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

// BoardColumn represents a column on a board (for Kanban/Scrum)
type BoardColumn struct {
        ID       string  `json:"id" db:"id"`
        BoardID  string  `json:"boardId" db:"board_id" binding:"required"`
        Title    string  `json:"title" db:"title" binding:"required"`
        StatusID *string `json:"statusId,omitempty" db:"status_id"` // Maps to ticket_status
        Position int     `json:"position" db:"position" binding:"required"`
        MaxItems *int    `json:"maxItems,omitempty" db:"max_items"` // WIP limit
        Created  int64   `json:"created" db:"created"`
        Modified int64   `json:"modified" db:"modified"`
        Deleted  bool    `json:"deleted" db:"deleted"`
}

// BoardSwimlane represents a swimlane on a board
type BoardSwimlane struct {
        ID       string  `json:"id" db:"id"`
        BoardID  string  `json:"boardId" db:"board_id" binding:"required"`
        Title    string  `json:"title" db:"title" binding:"required"`
        Query    *string `json:"query,omitempty" db:"query"` // JQL-like query for swimlane
        Position int     `json:"position" db:"position" binding:"required"`
        Created  int64   `json:"created" db:"created"`
        Modified int64   `json:"modified" db:"modified"`
        Deleted  bool    `json:"deleted" db:"deleted"`
}

// BoardQuickFilter represents a quick filter on a board
type BoardQuickFilter struct {
        ID       string  `json:"id" db:"id"`
        BoardID  string  `json:"boardId" db:"board_id" binding:"required"`
        Title    string  `json:"title" db:"title" binding:"required"`
        Query    *string `json:"query,omitempty" db:"query"` // JQL-like query for quick filter
        Position int     `json:"position" db:"position" binding:"required"`
        Created  int64   `json:"created" db:"created"`
        Deleted  bool    `json:"deleted" db:"deleted"`
}

// HasWIPLimit checks if the column has a WIP (Work In Progress) limit
func (bc *BoardColumn) HasWIPLimit() bool <span class="cov0" title="0">{
        return bc.MaxItems != nil &amp;&amp; *bc.MaxItems &gt; 0
}</span>

// IsWIPLimitExceeded checks if the current item count exceeds the WIP limit
func (bc *BoardColumn) IsWIPLimitExceeded(currentCount int) bool <span class="cov0" title="0">{
        if !bc.HasWIPLimit() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return currentCount &gt; *bc.MaxItems</span>
}

// HasQuery checks if the swimlane has a query defined
func (bs *BoardSwimlane) HasQuery() bool <span class="cov0" title="0">{
        return bs.Query != nil &amp;&amp; *bs.Query != ""
}</span>

// HasQuery checks if the quick filter has a query defined
func (bq *BoardQuickFilter) HasQuery() bool <span class="cov0" title="0">{
        return bq.Query != nil &amp;&amp; *bq.Query != ""
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

// UserPresence represents online/offline status for a user
type UserPresence struct {
        ID            string `json:"id" db:"id"`
        UserID        string `json:"user_id" db:"user_id" binding:"required"`
        Status        string `json:"status" db:"status" binding:"required"` // online, offline, away, busy, dnd
        StatusMessage string `json:"status_message,omitempty" db:"status_message"`
        LastSeen      int64  `json:"last_seen" db:"last_seen"`
        CreatedAt     int64  `json:"created_at" db:"created_at"`
        UpdatedAt     int64  `json:"updated_at" db:"updated_at"`
}

// Presence status constants
const (
        PresenceStatusOnline  = "online"
        PresenceStatusOffline = "offline"
        PresenceStatusAway    = "away"
        PresenceStatusBusy    = "busy"
        PresenceStatusDND     = "dnd"
)

// IsValidStatus checks if the presence status is valid
func (up *UserPresence) IsValidStatus() bool <span class="cov8" title="7">{
        return up.Status == PresenceStatusOnline ||
                up.Status == PresenceStatusOffline ||
                up.Status == PresenceStatusAway ||
                up.Status == PresenceStatusBusy ||
                up.Status == PresenceStatusDND
}</span>

// ChatRoom represents a chat room that can be associated with any entity
type ChatRoom struct {
        ID          string `json:"id" db:"id"`
        Name        string `json:"name,omitempty" db:"name"`
        Description string `json:"description,omitempty" db:"description"`
        Type        string `json:"type" db:"type" binding:"required"` // direct, group, team, project, ticket, account, organization, attachment, custom
        EntityType  string `json:"entity_type,omitempty" db:"entity_type"`
        EntityID    string `json:"entity_id,omitempty" db:"entity_id"`
        CreatedBy   string `json:"created_by" db:"created_by" binding:"required"`
        IsPrivate   bool   `json:"is_private" db:"is_private"`
        IsArchived  bool   `json:"is_archived" db:"is_archived"`
        CreatedAt   int64  `json:"created_at" db:"created_at"`
        UpdatedAt   int64  `json:"updated_at" db:"updated_at"`
        Deleted     bool   `json:"deleted" db:"deleted"`
        DeletedAt   *int64 `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Chat room type constants
const (
        ChatRoomTypeDirect       = "direct"
        ChatRoomTypeGroup        = "group"
        ChatRoomTypeTeam         = "team"
        ChatRoomTypeProject      = "project"
        ChatRoomTypeTicket       = "ticket"
        ChatRoomTypeAccount      = "account"
        ChatRoomTypeOrganization = "organization"
        ChatRoomTypeAttachment   = "attachment"
        ChatRoomTypeCustom       = "custom"
)

// IsValidType checks if the chat room type is valid
func (cr *ChatRoom) IsValidType() bool <span class="cov10" title="11">{
        return cr.Type == ChatRoomTypeDirect ||
                cr.Type == ChatRoomTypeGroup ||
                cr.Type == ChatRoomTypeTeam ||
                cr.Type == ChatRoomTypeProject ||
                cr.Type == ChatRoomTypeTicket ||
                cr.Type == ChatRoomTypeAccount ||
                cr.Type == ChatRoomTypeOrganization ||
                cr.Type == ChatRoomTypeAttachment ||
                cr.Type == ChatRoomTypeCustom
}</span>

// ChatParticipant represents a user in a chat room
type ChatParticipant struct {
        ID         string `json:"id" db:"id"`
        ChatRoomID string `json:"chat_room_id" db:"chat_room_id" binding:"required"`
        UserID     string `json:"user_id" db:"user_id" binding:"required"`
        Role       string `json:"role" db:"role" binding:"required"` // owner, admin, moderator, member, guest
        IsMuted    bool   `json:"is_muted" db:"is_muted"`
        JoinedAt   int64  `json:"joined_at" db:"joined_at"`
        LeftAt     *int64 `json:"left_at,omitempty" db:"left_at"`
        CreatedAt  int64  `json:"created_at" db:"created_at"`
        UpdatedAt  int64  `json:"updated_at" db:"updated_at"`
        Deleted    bool   `json:"deleted" db:"deleted"`
        DeletedAt  *int64 `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Participant role constants
const (
        ChatParticipantRoleOwner     = "owner"
        ChatParticipantRoleAdmin     = "admin"
        ChatParticipantRoleModerator = "moderator"
        ChatParticipantRoleMember    = "member"
        ChatParticipantRoleGuest     = "guest"
)

// IsValidRole checks if the participant role is valid
func (cp *ChatParticipant) IsValidRole() bool <span class="cov8" title="7">{
        return cp.Role == ChatParticipantRoleOwner ||
                cp.Role == ChatParticipantRoleAdmin ||
                cp.Role == ChatParticipantRoleModerator ||
                cp.Role == ChatParticipantRoleMember ||
                cp.Role == ChatParticipantRoleGuest
}</span>

// Message represents a chat message
type Message struct {
        ID              string                 `json:"id" db:"id"`
        ChatRoomID      string                 `json:"chat_room_id" db:"chat_room_id" binding:"required"`
        SenderID        string                 `json:"sender_id" db:"sender_id" binding:"required"`
        ParentID        *string                `json:"parent_id,omitempty" db:"parent_id"`         // for threads/replies
        QuotedMessageID *string                `json:"quoted_message_id,omitempty" db:"quoted_message_id"` // for quotes
        Type            string                 `json:"type" db:"type" binding:"required"`          // text, reply, quote, system, file, code, poll
        Content         string                 `json:"content" db:"content" binding:"required"`
        ContentFormat   string                 `json:"content_format" db:"content_format"` // plain, markdown, html
        Metadata        map[string]interface{} `json:"metadata,omitempty" db:"metadata"`   // JSONB in database
        IsEdited        bool                   `json:"is_edited" db:"is_edited"`
        EditedAt        *int64                 `json:"edited_at,omitempty" db:"edited_at"`
        IsPinned        bool                   `json:"is_pinned" db:"is_pinned"`
        PinnedAt        *int64                 `json:"pinned_at,omitempty" db:"pinned_at"`
        PinnedBy        *string                `json:"pinned_by,omitempty" db:"pinned_by"`
        CreatedAt       int64                  `json:"created_at" db:"created_at"`
        UpdatedAt       int64                  `json:"updated_at" db:"updated_at"`
        Deleted         bool                   `json:"deleted" db:"deleted"`
        DeletedAt       *int64                 `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Message type constants
const (
        MessageTypeText   = "text"
        MessageTypeReply  = "reply"
        MessageTypeQuote  = "quote"
        MessageTypeSystem = "system"
        MessageTypeFile   = "file"
        MessageTypeCode   = "code"
        MessageTypePoll   = "poll"
)

// Content format constants
const (
        ContentFormatPlain    = "plain"
        ContentFormatMarkdown = "markdown"
        ContentFormatHTML     = "html"
)

// IsValidType checks if the message type is valid
func (m *Message) IsValidType() bool <span class="cov9" title="9">{
        return m.Type == MessageTypeText ||
                m.Type == MessageTypeReply ||
                m.Type == MessageTypeQuote ||
                m.Type == MessageTypeSystem ||
                m.Type == MessageTypeFile ||
                m.Type == MessageTypeCode ||
                m.Type == MessageTypePoll
}</span>

// IsValidContentFormat checks if the content format is valid
func (m *Message) IsValidContentFormat() bool <span class="cov7" title="5">{
        return m.ContentFormat == ContentFormatPlain ||
                m.ContentFormat == ContentFormatMarkdown ||
                m.ContentFormat == ContentFormatHTML
}</span>

// TypingIndicator represents real-time typing status
type TypingIndicator struct {
        ID         string `json:"id" db:"id"`
        ChatRoomID string `json:"chat_room_id" db:"chat_room_id" binding:"required"`
        UserID     string `json:"user_id" db:"user_id" binding:"required"`
        IsTyping   bool   `json:"is_typing" db:"is_typing"`
        StartedAt  int64  `json:"started_at" db:"started_at"`
        ExpiresAt  int64  `json:"expires_at" db:"expires_at"` // auto-expire after 5 seconds
}

// MessageReadReceipt represents message read status
type MessageReadReceipt struct {
        ID        string `json:"id" db:"id"`
        MessageID string `json:"message_id" db:"message_id" binding:"required"`
        UserID    string `json:"user_id" db:"user_id" binding:"required"`
        ReadAt    int64  `json:"read_at" db:"read_at"`
        CreatedAt int64  `json:"created_at" db:"created_at"`
}

// MessageAttachment represents file attachments for messages
type MessageAttachment struct {
        ID           string                 `json:"id" db:"id"`
        MessageID    string                 `json:"message_id" db:"message_id" binding:"required"`
        FileName     string                 `json:"file_name" db:"file_name" binding:"required"`
        FileType     string                 `json:"file_type,omitempty" db:"file_type"`
        FileSize     int64                  `json:"file_size" db:"file_size" binding:"required"`
        FileURL      string                 `json:"file_url" db:"file_url" binding:"required"`
        ThumbnailURL string                 `json:"thumbnail_url,omitempty" db:"thumbnail_url"`
        Metadata     map[string]interface{} `json:"metadata,omitempty" db:"metadata"` // dimensions, duration, etc.
        UploadedBy   string                 `json:"uploaded_by" db:"uploaded_by" binding:"required"`
        CreatedAt    int64                  `json:"created_at" db:"created_at"`
        Deleted      bool                   `json:"deleted" db:"deleted"`
        DeletedAt    *int64                 `json:"deleted_at,omitempty" db:"deleted_at"`
}

// MessageReaction represents emoji reactions to messages
type MessageReaction struct {
        ID        string `json:"id" db:"id"`
        MessageID string `json:"message_id" db:"message_id" binding:"required"`
        UserID    string `json:"user_id" db:"user_id" binding:"required"`
        Emoji     string `json:"emoji" db:"emoji" binding:"required"` // emoji unicode or :emoji_name:
        CreatedAt int64  `json:"created_at" db:"created_at"`
}

// ChatExternalIntegration represents integration with external chat providers
type ChatExternalIntegration struct {
        ID         string                 `json:"id" db:"id"`
        ChatRoomID string                 `json:"chat_room_id" db:"chat_room_id" binding:"required"`
        Provider   string                 `json:"provider" db:"provider" binding:"required"` // slack, telegram, yandex, google, whatsapp, custom
        ExternalID string                 `json:"external_id" db:"external_id" binding:"required"`
        Config     map[string]interface{} `json:"config,omitempty" db:"config"` // provider-specific configuration
        IsActive   bool                   `json:"is_active" db:"is_active"`
        CreatedAt  int64                  `json:"created_at" db:"created_at"`
        UpdatedAt  int64                  `json:"updated_at" db:"updated_at"`
        Deleted    bool                   `json:"deleted" db:"deleted"`
        DeletedAt  *int64                 `json:"deleted_at,omitempty" db:"deleted_at"`
}

// External integration provider constants
const (
        ChatProviderSlack    = "slack"
        ChatProviderTelegram = "telegram"
        ChatProviderYandex   = "yandex"
        ChatProviderGoogle   = "google"
        ChatProviderWhatsApp = "whatsapp"
        ChatProviderCustom   = "custom"
)

// IsValidProvider checks if the provider is valid
func (cei *ChatExternalIntegration) IsValidProvider() bool <span class="cov8" title="8">{
        return cei.Provider == ChatProviderSlack ||
                cei.Provider == ChatProviderTelegram ||
                cei.Provider == ChatProviderYandex ||
                cei.Provider == ChatProviderGoogle ||
                cei.Provider == ChatProviderWhatsApp ||
                cei.Provider == ChatProviderCustom
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import "time"

// Comment represents a comment in the system
type Comment struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title"`
        Description string `json:"description" db:"description"`
        UserID      string `json:"userId" db:"user_id"`     // Comment author
        ParentID    string `json:"parentId" db:"parent_id"` // For nested comments
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
        Version     int    `json:"version" db:"version"` // Optimistic locking version
}

// NewComment creates a new comment with current timestamps
func NewComment(id, title, description, userID, parentID string) *Comment <span class="cov0" title="0">{
        now := time.Now().Unix()
        return &amp;Comment{
                ID:          id,
                Title:       title,
                Description: description,
                UserID:      userID,
                ParentID:    parentID,
                Created:     now,
                Modified:    now,
                Deleted:     false,
                Version:     1,
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

// Component represents a project component (module, subsystem, feature area)
type Component struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// ComponentMetaData represents additional metadata for a component
type ComponentMetaData struct {
        ID          string `json:"id" db:"id"`
        ComponentID string `json:"componentId" db:"component_id" binding:"required"`
        Property    string `json:"property" db:"property" binding:"required"`
        Value       string `json:"value" db:"value"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// ComponentTicketMapping represents the many-to-many relationship between components and tickets
type ComponentTicketMapping struct {
        ID          string `json:"id" db:"id"`
        ComponentID string `json:"componentId" db:"component_id" binding:"required"`
        TicketID    string `json:"ticketId" db:"ticket_id" binding:"required"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// GetDisplayName returns a user-friendly display name
func (c *Component) GetDisplayName() string <span class="cov0" title="0">{
        if c.Title != "" </span><span class="cov0" title="0">{
                return c.Title
        }</span>
        <span class="cov0" title="0">return "Unknown Component"</span>
}

// IsValid checks if the component has required fields
func (c *Component) IsValid() bool <span class="cov0" title="0">{
        return c.Title != ""
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

// CustomField represents a user-defined custom field for tickets
type CustomField struct {
        ID            string  `json:"id" db:"id"`
        FieldName     string  `json:"fieldName" db:"field_name" binding:"required"`
        FieldType     string  `json:"fieldType" db:"field_type" binding:"required"`
        Description   string  `json:"description,omitempty" db:"description"`
        ProjectID     *string `json:"projectId,omitempty" db:"project_id"` // NULL for global fields
        IsRequired    bool    `json:"isRequired" db:"is_required"`
        DefaultValue  *string `json:"defaultValue,omitempty" db:"default_value"`
        Configuration *string `json:"configuration,omitempty" db:"configuration"` // JSON configuration
        Created       int64   `json:"created" db:"created"`
        Modified      int64   `json:"modified" db:"modified"`
        Deleted       bool    `json:"deleted" db:"deleted"`
}

// CustomFieldType represents the type of custom field
type CustomFieldType string

const (
        CustomFieldTypeText        CustomFieldType = "text"
        CustomFieldTypeTextArea    CustomFieldType = "textarea"
        CustomFieldTypeNumber      CustomFieldType = "number"
        CustomFieldTypeDate        CustomFieldType = "date"
        CustomFieldTypeDateTime    CustomFieldType = "datetime"
        CustomFieldTypeSelect      CustomFieldType = "select"
        CustomFieldTypeMultiSelect CustomFieldType = "multi_select"
        CustomFieldTypeUser        CustomFieldType = "user"
        CustomFieldTypeURL         CustomFieldType = "url"
        CustomFieldTypeCheckbox    CustomFieldType = "checkbox"
        CustomFieldTypeRadio       CustomFieldType = "radio"
)

// CustomFieldOption represents an option for select/multi-select custom fields
type CustomFieldOption struct {
        ID            string `json:"id" db:"id"`
        CustomFieldID string `json:"customFieldId" db:"custom_field_id" binding:"required"`
        Value         string `json:"value" db:"value" binding:"required"`
        DisplayValue  string `json:"displayValue" db:"display_value" binding:"required"`
        Position      int    `json:"position" db:"position"`
        IsDefault     bool   `json:"isDefault" db:"is_default"`
        Created       int64  `json:"created" db:"created"`
        Modified      int64  `json:"modified" db:"modified"`
        Deleted       bool   `json:"deleted" db:"deleted"`
}

// TicketCustomFieldValue represents the value of a custom field for a specific ticket
type TicketCustomFieldValue struct {
        ID            string  `json:"id" db:"id"`
        TicketID      string  `json:"ticketId" db:"ticket_id" binding:"required"`
        CustomFieldID string  `json:"customFieldId" db:"custom_field_id" binding:"required"`
        Value         *string `json:"value,omitempty" db:"value"` // NULL for empty/unset fields
        Created       int64   `json:"created" db:"created"`
        Modified      int64   `json:"modified" db:"modified"`
        Deleted       bool    `json:"deleted" db:"deleted"`
}

// IsValidFieldType checks if the field type is valid
func (cf *CustomField) IsValidFieldType() bool <span class="cov6" title="14">{
        validTypes := []CustomFieldType{
                CustomFieldTypeText,
                CustomFieldTypeTextArea,
                CustomFieldTypeNumber,
                CustomFieldTypeDate,
                CustomFieldTypeDateTime,
                CustomFieldTypeSelect,
                CustomFieldTypeMultiSelect,
                CustomFieldTypeUser,
                CustomFieldTypeURL,
                CustomFieldTypeCheckbox,
                CustomFieldTypeRadio,
        }

        for _, validType := range validTypes </span><span class="cov10" title="91">{
                if CustomFieldType(cf.FieldType) == validType </span><span class="cov5" title="12">{
                        return true
                }</span>
        }

        <span class="cov2" title="2">return false</span>
}

// IsGlobal checks if the custom field is global (applies to all projects)
func (cf *CustomField) IsGlobal() bool <span class="cov3" title="3">{
        return cf.ProjectID == nil
}</span>

// IsSelectType checks if the field type is select or multi-select
func (cf *CustomField) IsSelectType() bool <span class="cov5" title="12">{
        return CustomFieldType(cf.FieldType) == CustomFieldTypeSelect ||
                CustomFieldType(cf.FieldType) == CustomFieldTypeMultiSelect
}</span>

// RequiresOptions checks if the field type requires options (select types)
func (cf *CustomField) RequiresOptions() bool <span class="cov4" title="7">{
        return cf.IsSelectType() || CustomFieldType(cf.FieldType) == CustomFieldTypeRadio
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

// Cycle represents a sprint/milestone/release (Agile iteration)
// Cycles form a hierarchy: Release (1000) &gt; Milestone (100) &gt; Sprint (10)
type Cycle struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title" binding:"required"`
        Description *string `json:"description,omitempty" db:"description"` // NULL allowed
        CycleID     *string `json:"cycleId,omitempty" db:"cycle_id"`         // Parent cycle ID (NULL for top-level cycles)
        Type        int     `json:"type" db:"type" binding:"required"`
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// Cycle type constants
const (
        CycleTypeRelease   = 1000 // Top-level release cycle
        CycleTypeMilestone = 100  // Mid-level milestone
        CycleTypeSprint    = 10   // Bottom-level sprint
)

// CycleProjectMapping represents the many-to-many relationship between cycles and projects
type CycleProjectMapping struct {
        ID        string `json:"id" db:"id"`
        CycleID   string `json:"cycleId" db:"cycle_id" binding:"required"`
        ProjectID string `json:"projectId" db:"project_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// TicketCycleMapping represents the many-to-many relationship between tickets and cycles
type TicketCycleMapping struct {
        ID       string `json:"id" db:"id"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        CycleID  string `json:"cycleId" db:"cycle_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// IsValidType checks if the cycle type is valid (10, 100, or 1000)
func (c *Cycle) IsValidType() bool <span class="cov0" title="0">{
        return c.Type == CycleTypeSprint || c.Type == CycleTypeMilestone || c.Type == CycleTypeRelease
}</span>

// GetTypeName returns a user-friendly type name
func (c *Cycle) GetTypeName() string <span class="cov0" title="0">{
        switch c.Type </span>{
        case CycleTypeRelease:<span class="cov0" title="0">
                return "Release"</span>
        case CycleTypeMilestone:<span class="cov0" title="0">
                return "Milestone"</span>
        case CycleTypeSprint:<span class="cov0" title="0">
                return "Sprint"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// IsValidParent checks if the parent cycle type is valid for this cycle
// Parent's type must be greater than current cycle's type (Release &gt; Milestone &gt; Sprint)
func (c *Cycle) IsValidParent(parentType int) bool <span class="cov0" title="0">{
        if c.CycleID == nil || *c.CycleID == "" </span><span class="cov0" title="0">{
                return true // No parent is valid
        }</span>
        <span class="cov0" title="0">return parentType &gt; c.Type</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package models

// Dashboard represents a customizable dashboard with widgets
type Dashboard struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title" binding:"required"`
        Description string  `json:"description,omitempty" db:"description"`
        OwnerID     string  `json:"ownerId" db:"owner_id" binding:"required"`
        IsPublic    bool    `json:"isPublic" db:"is_public"`
        IsFavorite  bool    `json:"isFavorite" db:"is_favorite"`
        Layout      *string `json:"layout,omitempty" db:"layout"` // JSON layout configuration
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
        Version     int     `json:"version" db:"version"` // Optimistic locking version
}

// DashboardWidget represents a widget on a dashboard
type DashboardWidget struct {
        ID            string  `json:"id" db:"id"`
        DashboardID   string  `json:"dashboardId" db:"dashboard_id" binding:"required"`
        WidgetType    string  `json:"widgetType" db:"widget_type" binding:"required"`
        Title         *string `json:"title,omitempty" db:"title"`
        PositionX     *int    `json:"positionX,omitempty" db:"position_x"`
        PositionY     *int    `json:"positionY,omitempty" db:"position_y"`
        Width         *int    `json:"width,omitempty" db:"width"`
        Height        *int    `json:"height,omitempty" db:"height"`
        Configuration *string `json:"configuration,omitempty" db:"configuration"` // JSON widget configuration
        Created       int64   `json:"created" db:"created"`
        Modified      int64   `json:"modified" db:"modified"`
        Deleted       bool    `json:"deleted" db:"deleted"`
}

// DashboardShareMapping represents sharing a dashboard with users/teams/projects
type DashboardShareMapping struct {
        ID          string  `json:"id" db:"id"`
        DashboardID string  `json:"dashboardId" db:"dashboard_id" binding:"required"`
        UserID      *string `json:"userId,omitempty" db:"user_id"`       // NULL if not user-specific
        TeamID      *string `json:"teamId,omitempty" db:"team_id"`       // NULL if not team-specific
        ProjectID   *string `json:"projectId,omitempty" db:"project_id"` // NULL if not project-specific
        Created     int64   `json:"created" db:"created"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// Widget type constants
const (
        WidgetTypeFilterResults  = "filter_results"
        WidgetTypePieChart       = "pie_chart"
        WidgetTypeBarChart       = "bar_chart"
        WidgetTypeLineChart      = "line_chart"
        WidgetTypeActivityStream = "activity_stream"
        WidgetTypeStatistics     = "statistics"
        WidgetTypeRecentTickets  = "recent_tickets"
        WidgetTypeAssignedToMe   = "assigned_to_me"
        WidgetTypeCreatedByMe    = "created_by_me"
        WidgetTypeHeatMap        = "heat_map"
)

// IsOwner checks if the given userID is the owner
func (d *Dashboard) IsOwner(userID string) bool <span class="cov0" title="0">{
        return d.OwnerID == userID
}</span>

// IsValidWidgetType checks if the widget type is valid
func (dw *DashboardWidget) IsValidWidgetType() bool <span class="cov0" title="0">{
        validTypes := map[string]bool{
                WidgetTypeFilterResults:  true,
                WidgetTypePieChart:       true,
                WidgetTypeBarChart:       true,
                WidgetTypeLineChart:      true,
                WidgetTypeActivityStream: true,
                WidgetTypeStatistics:     true,
                WidgetTypeRecentTickets:  true,
                WidgetTypeAssignedToMe:   true,
                WidgetTypeCreatedByMe:    true,
                WidgetTypeHeatMap:        true,
        }
        return validTypes[dw.WidgetType]
}</span>

// GetShareType returns the type of share (user, team, or project)
func (ds *DashboardShareMapping) GetShareType() string <span class="cov0" title="0">{
        if ds.UserID != nil &amp;&amp; *ds.UserID != "" </span><span class="cov0" title="0">{
                return "user"
        }</span>
        <span class="cov0" title="0">if ds.TeamID != nil &amp;&amp; *ds.TeamID != "" </span><span class="cov0" title="0">{
                return "team"
        }</span>
        <span class="cov0" title="0">if ds.ProjectID != nil &amp;&amp; *ds.ProjectID != "" </span><span class="cov0" title="0">{
                return "project"
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package models

import (
        "errors"
        "time"
)

// Document represents the main document entity
type Document struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title"`
        SpaceID     string  `json:"space_id" db:"space_id"`
        ParentID    *string `json:"parent_id,omitempty" db:"parent_id"`        // For hierarchy
        TypeID      string  `json:"type_id" db:"type_id"`
        ProjectID   *string `json:"project_id,omitempty" db:"project_id"`      // Optional link to project
        CreatorID   string  `json:"creator_id" db:"creator_id"`
        Version     int     `json:"version" db:"version"`                      // Current version (optimistic locking)
        Position    int     `json:"position" db:"position"`                    // Position in hierarchy
        IsPublished bool    `json:"is_published" db:"is_published"`
        IsArchived  bool    `json:"is_archived" db:"is_archived"`
        PublishDate *int64  `json:"publish_date,omitempty" db:"publish_date"`  // Scheduled or actual publish date
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// Validate validates the document
func (d *Document) Validate() error <span class="cov8" title="10">{
        if d.ID == "" </span><span class="cov1" title="1">{
                return errors.New("document ID cannot be empty")
        }</span>
        <span class="cov8" title="9">if d.Title == "" </span><span class="cov1" title="1">{
                return errors.New("document title cannot be empty")
        }</span>
        <span class="cov7" title="8">if d.SpaceID == "" </span><span class="cov1" title="1">{
                return errors.New("document space ID cannot be empty")
        }</span>
        <span class="cov7" title="7">if d.TypeID == "" </span><span class="cov1" title="1">{
                return errors.New("document type ID cannot be empty")
        }</span>
        <span class="cov6" title="6">if d.CreatorID == "" </span><span class="cov1" title="1">{
                return errors.New("document creator ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if d.Version &lt; 1 </span><span class="cov1" title="1">{
                return errors.New("document version must be at least 1")
        }</span>
        <span class="cov5" title="4">if d.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("document created timestamp cannot be zero")
        }</span>
        <span class="cov4" title="3">if d.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("document modified timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (d *Document) SetTimestamps() <span class="cov4" title="3">{
        now := time.Now().Unix()
        if d.Created == 0 </span><span class="cov1" title="1">{
                d.Created = now
        }</span>
        <span class="cov4" title="3">d.Modified = now</span>
}

// IncrementVersion increments the version number for optimistic locking
func (d *Document) IncrementVersion() <span class="cov7" title="8">{
        d.Version++
        d.Modified = time.Now().Unix()
}</span>

// DocumentContent represents the content of a document version
type DocumentContent struct {
        ID          string  `json:"id" db:"id"`
        DocumentID  string  `json:"document_id" db:"document_id"`
        Version     int     `json:"version" db:"version"`
        ContentType string  `json:"content_type" db:"content_type"` // "html", "markdown", "plain", "storage"
        Content     *string `json:"content,omitempty" db:"content"`
        ContentHash *string `json:"content_hash,omitempty" db:"content_hash"` // SHA-256 hash
        SizeBytes   int     `json:"size_bytes" db:"size_bytes"`
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// Validate validates the document content
func (dc *DocumentContent) Validate() error <span class="cov10" title="16">{
        if dc.ID == "" </span><span class="cov1" title="1">{
                return errors.New("document content ID cannot be empty")
        }</span>
        <span class="cov9" title="15">if dc.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("document content document ID cannot be empty")
        }</span>
        <span class="cov9" title="14">if dc.Version &lt; 1 </span><span class="cov1" title="1">{
                return errors.New("document content version must be at least 1")
        }</span>
        <span class="cov9" title="13">if dc.ContentType == "" </span><span class="cov1" title="1">{
                return errors.New("document content type cannot be empty")
        }</span>
        <span class="cov9" title="12">validTypes := map[string]bool{
                "html": true, "markdown": true, "plain": true, "storage": true,
        }
        if !validTypes[dc.ContentType] </span><span class="cov1" title="1">{
                return errors.New("invalid content type")
        }</span>
        <span class="cov8" title="11">if dc.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("document content created timestamp cannot be zero")
        }</span>
        <span class="cov8" title="10">if dc.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("document content modified timestamp cannot be zero")
        }</span>
        <span class="cov8" title="9">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (dc *DocumentContent) SetTimestamps() <span class="cov3" title="2">{
        now := time.Now().Unix()
        if dc.Created == 0 </span><span class="cov1" title="1">{
                dc.Created = now
        }</span>
        <span class="cov3" title="2">dc.Modified = now</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package models

import (
        "errors"
        "time"
)

// DocumentViewHistory represents a single view of a document
type DocumentViewHistory struct {
        ID           string  `json:"id" db:"id"`
        DocumentID   string  `json:"document_id" db:"document_id"`
        UserID       *string `json:"user_id,omitempty" db:"user_id"` // NULL for anonymous
        IPAddress    *string `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent    *string `json:"user_agent,omitempty" db:"user_agent"`
        SessionID    *string `json:"session_id,omitempty" db:"session_id"`
        ViewDuration *int    `json:"view_duration,omitempty" db:"view_duration"` // Seconds
        Timestamp    int64   `json:"timestamp" db:"timestamp"`
}

// Validate validates the view history entry
func (dvh *DocumentViewHistory) Validate() error <span class="cov5" title="6">{
        if dvh.ID == "" </span><span class="cov1" title="1">{
                return errors.New("view history ID cannot be empty")
        }</span>
        <span class="cov5" title="5">if dvh.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("view history document ID cannot be empty")
        }</span>
        <span class="cov4" title="4">if dvh.Timestamp == 0 </span><span class="cov1" title="1">{
                return errors.New("view history timestamp cannot be zero")
        }</span>
        <span class="cov3" title="3">return nil</span>
}

// SetTimestamps sets the timestamp
func (dvh *DocumentViewHistory) SetTimestamps() <span class="cov2" title="2">{
        if dvh.Timestamp == 0 </span><span class="cov1" title="1">{
                dvh.Timestamp = time.Now().Unix()
        }</span>
}

// DocumentAnalytics represents aggregated analytics for a document
type DocumentAnalytics struct {
        ID               string   `json:"id" db:"id"`
        DocumentID       string   `json:"document_id" db:"document_id"`
        TotalViews       int      `json:"total_views" db:"total_views"`
        UniqueViewers    int      `json:"unique_viewers" db:"unique_viewers"`
        TotalEdits       int      `json:"total_edits" db:"total_edits"`
        UniqueEditors    int      `json:"unique_editors" db:"unique_editors"`
        TotalComments    int      `json:"total_comments" db:"total_comments"`
        TotalReactions   int      `json:"total_reactions" db:"total_reactions"`
        TotalWatchers    int      `json:"total_watchers" db:"total_watchers"`
        AvgViewDuration  *int     `json:"avg_view_duration,omitempty" db:"avg_view_duration"` // Seconds
        LastViewed       *int64   `json:"last_viewed,omitempty" db:"last_viewed"`
        LastEdited       *int64   `json:"last_edited,omitempty" db:"last_edited"`
        PopularityScore  float64  `json:"popularity_score" db:"popularity_score"`
        Updated          int64    `json:"updated" db:"updated"`
}

// Validate validates the document analytics
func (da *DocumentAnalytics) Validate() error <span class="cov4" title="4">{
        if da.ID == "" </span><span class="cov1" title="1">{
                return errors.New("analytics ID cannot be empty")
        }</span>
        <span class="cov3" title="3">if da.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("analytics document ID cannot be empty")
        }</span>
        <span class="cov2" title="2">if da.Updated == 0 </span><span class="cov1" title="1">{
                return errors.New("analytics updated timestamp cannot be zero")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetTimestamps sets the updated timestamp
func (da *DocumentAnalytics) SetTimestamps() <span class="cov10" title="30">{
        da.Updated = time.Now().Unix()
}</span>

// CalculatePopularityScore calculates a popularity score based on metrics
func (da *DocumentAnalytics) CalculatePopularityScore() <span class="cov5" title="5">{
        // Simple algorithm: weighted sum of various metrics
        score := float64(da.TotalViews)*0.1 +
                float64(da.UniqueViewers)*0.3 +
                float64(da.TotalEdits)*0.2 +
                float64(da.TotalComments)*0.2 +
                float64(da.TotalReactions)*0.1 +
                float64(da.TotalWatchers)*0.1

        da.PopularityScore = score
}</span>

// IncrementView increments view counters
func (da *DocumentAnalytics) IncrementView(isUnique bool) <span class="cov5" title="6">{
        da.TotalViews++
        if isUnique </span><span class="cov4" title="4">{
                da.UniqueViewers++
        }</span>
        <span class="cov5" title="6">now := time.Now().Unix()
        da.LastViewed = &amp;now
        da.SetTimestamps()</span>
}

// IncrementEdit increments edit counters
func (da *DocumentAnalytics) IncrementEdit(isUnique bool) <span class="cov5" title="5">{
        da.TotalEdits++
        if isUnique </span><span class="cov3" title="3">{
                da.UniqueEditors++
        }</span>
        <span class="cov5" title="5">now := time.Now().Unix()
        da.LastEdited = &amp;now
        da.SetTimestamps()</span>
}

// IncrementComment increments comment counter
func (da *DocumentAnalytics) IncrementComment() <span class="cov3" title="3">{
        da.TotalComments++
        da.SetTimestamps()
}</span>

// IncrementReaction increments reaction counter
func (da *DocumentAnalytics) IncrementReaction() <span class="cov2" title="2">{
        da.TotalReactions++
        da.SetTimestamps()
}</span>

// IncrementWatcher increments watcher counter
func (da *DocumentAnalytics) IncrementWatcher() <span class="cov2" title="2">{
        da.TotalWatchers++
        da.SetTimestamps()
}</span>

// DecrementComment decrements comment counter
func (da *DocumentAnalytics) DecrementComment() <span class="cov4" title="4">{
        if da.TotalComments &gt; 0 </span><span class="cov3" title="3">{
                da.TotalComments--
        }</span>
        <span class="cov4" title="4">da.SetTimestamps()</span>
}

// DecrementReaction decrements reaction counter
func (da *DocumentAnalytics) DecrementReaction() <span class="cov4" title="4">{
        if da.TotalReactions &gt; 0 </span><span class="cov3" title="3">{
                da.TotalReactions--
        }</span>
        <span class="cov4" title="4">da.SetTimestamps()</span>
}

// DecrementWatcher decrements watcher counter
func (da *DocumentAnalytics) DecrementWatcher() <span class="cov4" title="4">{
        if da.TotalWatchers &gt; 0 </span><span class="cov3" title="3">{
                da.TotalWatchers--
        }</span>
        <span class="cov4" title="4">da.SetTimestamps()</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package models

import (
        "errors"
        "fmt"
        "time"
)

// DocumentAttachment represents a file attached to a document
type DocumentAttachment struct {
        ID               string  `json:"id" db:"id"`
        DocumentID       string  `json:"document_id" db:"document_id"`
        Filename         string  `json:"filename" db:"filename"`
        OriginalFilename string  `json:"original_filename" db:"original_filename"`
        MimeType         string  `json:"mime_type" db:"mime_type"`
        SizeBytes        int     `json:"size_bytes" db:"size_bytes"`
        StoragePath      string  `json:"storage_path" db:"storage_path"`
        Checksum         string  `json:"checksum" db:"checksum"` // SHA-256
        UploaderID       string  `json:"uploader_id" db:"uploader_id"`
        Description      *string `json:"description,omitempty" db:"description"`
        Version          int     `json:"version" db:"version"`
        Created          int64   `json:"created" db:"created"`
        Modified         int64   `json:"modified" db:"modified"`
        Deleted          bool    `json:"deleted" db:"deleted"`
}

// Validate validates the document attachment
func (da *DocumentAttachment) Validate() error <span class="cov8" title="13">{
        if da.ID == "" </span><span class="cov1" title="1">{
                return errors.New("attachment ID cannot be empty")
        }</span>
        <span class="cov7" title="12">if da.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("attachment document ID cannot be empty")
        }</span>
        <span class="cov7" title="11">if da.Filename == "" </span><span class="cov1" title="1">{
                return errors.New("attachment filename cannot be empty")
        }</span>
        <span class="cov7" title="10">if da.OriginalFilename == "" </span><span class="cov1" title="1">{
                return errors.New("attachment original filename cannot be empty")
        }</span>
        <span class="cov7" title="9">if da.MimeType == "" </span><span class="cov1" title="1">{
                return errors.New("attachment MIME type cannot be empty")
        }</span>
        <span class="cov6" title="8">if da.SizeBytes &lt; 0 </span><span class="cov1" title="1">{
                return errors.New("attachment size cannot be negative")
        }</span>
        <span class="cov6" title="7">if da.StoragePath == "" </span><span class="cov1" title="1">{
                return errors.New("attachment storage path cannot be empty")
        }</span>
        <span class="cov5" title="6">if da.Checksum == "" </span><span class="cov1" title="1">{
                return errors.New("attachment checksum cannot be empty")
        }</span>
        <span class="cov5" title="5">if da.UploaderID == "" </span><span class="cov1" title="1">{
                return errors.New("attachment uploader ID cannot be empty")
        }</span>
        <span class="cov4" title="4">if da.Version &lt; 1 </span><span class="cov1" title="1">{
                return errors.New("attachment version must be at least 1")
        }</span>
        <span class="cov4" title="3">if da.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("attachment created timestamp cannot be zero")
        }</span>
        <span class="cov2" title="2">if da.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("attachment modified timestamp cannot be zero")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (da *DocumentAttachment) SetTimestamps() <span class="cov0" title="0">{
        now := time.Now().Unix()
        if da.Created == 0 </span><span class="cov0" title="0">{
                da.Created = now
        }</span>
        <span class="cov0" title="0">da.Modified = now</span>
}

// IncrementVersion increments the version number
func (da *DocumentAttachment) IncrementVersion() <span class="cov4" title="3">{
        da.Version++
        da.Modified = time.Now().Unix()
}</span>

// IsImage returns true if the attachment is an image
func (da *DocumentAttachment) IsImage() bool <span class="cov10" title="27">{
        imageTypes := map[string]bool{
                "image/jpeg": true,
                "image/jpg":  true,
                "image/png":  true,
                "image/gif":  true,
                "image/webp": true,
                "image/svg+xml": true,
        }
        return imageTypes[da.MimeType]
}</span>

// IsDocument returns true if the attachment is a document
func (da *DocumentAttachment) IsDocument() bool <span class="cov10" title="27">{
        docTypes := map[string]bool{
                "application/pdf": true,
                "application/msword": true,
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
                "application/vnd.ms-excel": true,
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": true,
                "text/plain": true,
                "text/markdown": true,
        }
        return docTypes[da.MimeType]
}</span>

// IsVideo returns true if the attachment is a video
func (da *DocumentAttachment) IsVideo() bool <span class="cov9" title="25">{
        videoTypes := map[string]bool{
                "video/mp4": true,
                "video/mpeg": true,
                "video/webm": true,
                "video/quicktime": true,
        }
        return videoTypes[da.MimeType]
}</span>

// GetHumanReadableSize returns the file size in human-readable format
func (da *DocumentAttachment) GetHumanReadableSize() string <span class="cov5" title="6">{
        const unit = 1024
        if da.SizeBytes &lt; unit </span><span class="cov1" title="1">{
                return fmt.Sprintf("%d B", da.SizeBytes)
        }</span>
        <span class="cov5" title="5">div, exp := int64(unit), 0
        for n := da.SizeBytes / unit; n &gt;= unit; n /= unit </span><span class="cov4" title="4">{
                div *= unit
                exp++
        }</span>
        <span class="cov5" title="5">return fmt.Sprintf("%d %s", da.SizeBytes/int(div), []string{"KB", "MB", "GB", "TB", "PB", "EB"}[exp])</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package models

import (
        "errors"
        "time"
)

// DocumentComment represents a comment on a document
type DocumentComment struct {
        ID         string  `json:"id" db:"id"`
        DocumentID string  `json:"document_id" db:"document_id"`
        UserID     string  `json:"user_id" db:"user_id"`
        Content    string  `json:"content" db:"content"`
        ParentID   *string `json:"parent_id,omitempty" db:"parent_id"` // For threading
        Version    int     `json:"version" db:"version"`               // Comment version (for edits)
        IsResolved bool    `json:"is_resolved" db:"is_resolved"`
        Created    int64   `json:"created" db:"created"`
        Modified   int64   `json:"modified" db:"modified"`
        Deleted    bool    `json:"deleted" db:"deleted"`
}

// Validate validates the document comment
func (dc *DocumentComment) Validate() error <span class="cov9" title="10">{
        if dc.ID == "" </span><span class="cov1" title="1">{
                return errors.New("comment ID cannot be empty")
        }</span>
        <span class="cov8" title="9">if dc.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("comment document ID cannot be empty")
        }</span>
        <span class="cov8" title="8">if dc.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("comment user ID cannot be empty")
        }</span>
        <span class="cov8" title="7">if dc.Content == "" </span><span class="cov1" title="1">{
                return errors.New("comment content cannot be empty")
        }</span>
        <span class="cov7" title="6">if dc.Version &lt; 1 </span><span class="cov1" title="1">{
                return errors.New("comment version must be at least 1")
        }</span>
        <span class="cov6" title="5">if dc.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("comment created timestamp cannot be zero")
        }</span>
        <span class="cov6" title="4">if dc.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("comment modified timestamp cannot be zero")
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (dc *DocumentComment) SetTimestamps() <span class="cov0" title="0">{
        now := time.Now().Unix()
        if dc.Created == 0 </span><span class="cov0" title="0">{
                dc.Created = now
        }</span>
        <span class="cov0" title="0">dc.Modified = now</span>
}

// DocumentInlineComment represents an inline comment with position
type DocumentInlineComment struct {
        ID            string  `json:"id" db:"id"`
        DocumentID    string  `json:"document_id" db:"document_id"`
        CommentID     string  `json:"comment_id" db:"comment_id"`
        PositionStart int     `json:"position_start" db:"position_start"`
        PositionEnd   int     `json:"position_end" db:"position_end"`
        SelectedText  *string `json:"selected_text,omitempty" db:"selected_text"`
        IsResolved    bool    `json:"is_resolved" db:"is_resolved"`
        Created       int64   `json:"created" db:"created"`
}

// Validate validates the inline comment
func (dic *DocumentInlineComment) Validate() error <span class="cov8" title="8">{
        if dic.ID == "" </span><span class="cov1" title="1">{
                return errors.New("inline comment ID cannot be empty")
        }</span>
        <span class="cov8" title="7">if dic.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("inline comment document ID cannot be empty")
        }</span>
        <span class="cov7" title="6">if dic.CommentID == "" </span><span class="cov1" title="1">{
                return errors.New("inline comment comment ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dic.PositionStart &lt; 0 </span><span class="cov1" title="1">{
                return errors.New("position start cannot be negative")
        }</span>
        <span class="cov6" title="4">if dic.PositionEnd &lt; dic.PositionStart </span><span class="cov1" title="1">{
                return errors.New("position end must be &gt;= position start")
        }</span>
        <span class="cov4" title="3">if dic.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("inline comment created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dic *DocumentInlineComment) SetTimestamps() <span class="cov0" title="0">{
        if dic.Created == 0 </span><span class="cov0" title="0">{
                dic.Created = time.Now().Unix()
        }</span>
}

// DocumentMention represents a user mention in a document
type DocumentMention struct {
        ID               string  `json:"id" db:"id"`
        DocumentID       string  `json:"document_id" db:"document_id"`
        MentionedUserID  string  `json:"mentioned_user_id" db:"mentioned_user_id"`
        MentioningUserID string  `json:"mentioning_user_id" db:"mentioning_user_id"`
        MentionContext   *string `json:"mention_context,omitempty" db:"mention_context"`
        Position         *int    `json:"position,omitempty" db:"position"`
        IsAcknowledged   bool    `json:"is_acknowledged" db:"is_acknowledged"`
        Created          int64   `json:"created" db:"created"`
}

// Validate validates the document mention
func (dm *DocumentMention) Validate() error <span class="cov8" title="7">{
        if dm.ID == "" </span><span class="cov1" title="1">{
                return errors.New("mention ID cannot be empty")
        }</span>
        <span class="cov7" title="6">if dm.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("mention document ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dm.MentionedUserID == "" </span><span class="cov1" title="1">{
                return errors.New("mentioned user ID cannot be empty")
        }</span>
        <span class="cov6" title="4">if dm.MentioningUserID == "" </span><span class="cov1" title="1">{
                return errors.New("mentioning user ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if dm.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("mention created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dm *DocumentMention) SetTimestamps() <span class="cov0" title="0">{
        if dm.Created == 0 </span><span class="cov0" title="0">{
                dm.Created = time.Now().Unix()
        }</span>
}

// DocumentReaction represents a reaction (like, emoji) on a document
type DocumentReaction struct {
        ID           string  `json:"id" db:"id"`
        DocumentID   string  `json:"document_id" db:"document_id"`
        UserID       string  `json:"user_id" db:"user_id"`
        ReactionType string  `json:"reaction_type" db:"reaction_type"` // "like", "love", "thumbsup"
        Emoji        *string `json:"emoji,omitempty" db:"emoji"`
        Created      int64   `json:"created" db:"created"`
}

// Validate validates the document reaction
func (dr *DocumentReaction) Validate() error <span class="cov8" title="7">{
        if dr.ID == "" </span><span class="cov1" title="1">{
                return errors.New("reaction ID cannot be empty")
        }</span>
        <span class="cov7" title="6">if dr.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("reaction document ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dr.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("reaction user ID cannot be empty")
        }</span>
        <span class="cov6" title="4">if dr.ReactionType == "" </span><span class="cov1" title="1">{
                return errors.New("reaction type cannot be empty")
        }</span>
        <span class="cov4" title="3">if dr.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("reaction created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dr *DocumentReaction) SetTimestamps() <span class="cov0" title="0">{
        if dr.Created == 0 </span><span class="cov0" title="0">{
                dr.Created = time.Now().Unix()
        }</span>
}

// DocumentWatcher represents a user watching a document
type DocumentWatcher struct {
        ID                string `json:"id" db:"id"`
        DocumentID        string `json:"document_id" db:"document_id"`
        UserID            string `json:"user_id" db:"user_id"`
        NotificationLevel string `json:"notification_level" db:"notification_level"` // "all", "mentions", "none"
        Created           int64  `json:"created" db:"created"`
}

// Validate validates the document watcher
func (dw *DocumentWatcher) Validate() error <span class="cov10" title="12">{
        if dw.ID == "" </span><span class="cov1" title="1">{
                return errors.New("watcher ID cannot be empty")
        }</span>
        <span class="cov9" title="11">if dw.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("watcher document ID cannot be empty")
        }</span>
        <span class="cov9" title="10">if dw.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("watcher user ID cannot be empty")
        }</span>
        <span class="cov8" title="9">if dw.NotificationLevel == "" </span><span class="cov1" title="1">{
                return errors.New("notification level cannot be empty")
        }</span>
        <span class="cov8" title="8">validLevels := map[string]bool{
                "all": true, "mentions": true, "none": true,
        }
        if !validLevels[dw.NotificationLevel] </span><span class="cov1" title="1">{
                return errors.New("invalid notification level")
        }</span>
        <span class="cov8" title="7">if dw.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("watcher created timestamp cannot be zero")
        }</span>
        <span class="cov7" title="6">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dw *DocumentWatcher) SetTimestamps() <span class="cov0" title="0">{
        if dw.Created == 0 </span><span class="cov0" title="0">{
                dw.Created = time.Now().Unix()
        }</span>
}

// DocumentLabel represents a reusable label
type DocumentLabel struct {
        ID          string  `json:"id" db:"id"`
        Name        string  `json:"name" db:"name"`
        Description *string `json:"description,omitempty" db:"description"`
        Color       *string `json:"color,omitempty" db:"color"` // Hex color code
        Created     int64   `json:"created" db:"created"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// Validate validates the document label
func (dl *DocumentLabel) Validate() error <span class="cov6" title="5">{
        if dl.ID == "" </span><span class="cov1" title="1">{
                return errors.New("label ID cannot be empty")
        }</span>
        <span class="cov6" title="4">if dl.Name == "" </span><span class="cov1" title="1">{
                return errors.New("label name cannot be empty")
        }</span>
        <span class="cov4" title="3">if dl.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("label created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dl *DocumentLabel) SetTimestamps() <span class="cov0" title="0">{
        if dl.Created == 0 </span><span class="cov0" title="0">{
                dl.Created = time.Now().Unix()
        }</span>
}

// DocumentTag represents a document tag
type DocumentTag struct {
        ID      string `json:"id" db:"id"`
        Name    string `json:"name" db:"name"`
        Created int64  `json:"created" db:"created"`
        Deleted bool   `json:"deleted" db:"deleted"`
}

// Validate validates the document tag
func (dt *DocumentTag) Validate() error <span class="cov6" title="4">{
        if dt.ID == "" </span><span class="cov1" title="1">{
                return errors.New("tag ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if dt.Name == "" </span><span class="cov1" title="1">{
                return errors.New("tag name cannot be empty")
        }</span>
        <span class="cov3" title="2">if dt.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("tag created timestamp cannot be zero")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dt *DocumentTag) SetTimestamps() <span class="cov0" title="0">{
        if dt.Created == 0 </span><span class="cov0" title="0">{
                dt.Created = time.Now().Unix()
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package models

import (
        "errors"
        "time"
)

// CommentDocumentMapping links core comments to documents
// This allows the core comment system to be used for documents
type CommentDocumentMapping struct {
        ID         string `json:"id" db:"id"`
        CommentID  string `json:"comment_id" db:"comment_id"`
        DocumentID string `json:"document_id" db:"document_id"`
        UserID     string `json:"user_id" db:"user_id"`
        IsResolved bool   `json:"is_resolved" db:"is_resolved"`
        Created    int64  `json:"created" db:"created"`
        Deleted    bool   `json:"deleted" db:"deleted"`
}

// Validate validates the comment-document mapping
func (cdm *CommentDocumentMapping) Validate() error <span class="cov6" title="7">{
        if cdm.ID == "" </span><span class="cov1" title="1">{
                return errors.New("comment-document mapping ID cannot be empty")
        }</span>
        <span class="cov6" title="6">if cdm.CommentID == "" </span><span class="cov1" title="1">{
                return errors.New("comment-document mapping comment ID cannot be empty")
        }</span>
        <span class="cov5" title="5">if cdm.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("comment-document mapping document ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if cdm.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("comment-document mapping user ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if cdm.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("comment-document mapping created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets the created timestamp
func (cdm *CommentDocumentMapping) SetTimestamps() <span class="cov0" title="0">{
        if cdm.Created == 0 </span><span class="cov0" title="0">{
                cdm.Created = time.Now().Unix()
        }</span>
}

// LabelDocumentMapping links core labels to documents
// This allows the core label system to be used for documents
type LabelDocumentMapping struct {
        ID         string `json:"id" db:"id"`
        LabelID    string `json:"label_id" db:"label_id"`
        DocumentID string `json:"document_id" db:"document_id"`
        UserID     string `json:"user_id" db:"user_id"`
        Created    int64  `json:"created" db:"created"`
        Deleted    bool   `json:"deleted" db:"deleted"`
}

// Validate validates the label-document mapping
func (ldm *LabelDocumentMapping) Validate() error <span class="cov6" title="6">{
        if ldm.ID == "" </span><span class="cov1" title="1">{
                return errors.New("label-document mapping ID cannot be empty")
        }</span>
        <span class="cov5" title="5">if ldm.LabelID == "" </span><span class="cov1" title="1">{
                return errors.New("label-document mapping label ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if ldm.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("label-document mapping document ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if ldm.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("label-document mapping user ID cannot be empty")
        }</span>
        <span class="cov3" title="2">if ldm.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("label-document mapping created timestamp cannot be zero")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetTimestamps sets the created timestamp
func (ldm *LabelDocumentMapping) SetTimestamps() <span class="cov0" title="0">{
        if ldm.Created == 0 </span><span class="cov0" title="0">{
                ldm.Created = time.Now().Unix()
        }</span>
}

// VoteMapping represents a generic vote/reaction on any entity
// Replaces the old ticket_vote_mapping with a universal system
type VoteMapping struct {
        ID         string  `json:"id" db:"id"`
        EntityType string  `json:"entity_type" db:"entity_type"` // "ticket", "document", "comment", etc.
        EntityID   string  `json:"entity_id" db:"entity_id"`
        UserID     string  `json:"user_id" db:"user_id"`
        VoteType   string  `json:"vote_type" db:"vote_type"` // "upvote", "downvote", "like", "love", etc.
        Emoji      *string `json:"emoji,omitempty" db:"emoji"`
        Created    int64   `json:"created" db:"created"`
        Deleted    bool    `json:"deleted" db:"deleted"`
}

// Validate validates the vote mapping
func (vm *VoteMapping) Validate() error <span class="cov10" title="21">{
        if vm.ID == "" </span><span class="cov1" title="1">{
                return errors.New("vote mapping ID cannot be empty")
        }</span>
        <span class="cov9" title="20">if vm.EntityType == "" </span><span class="cov1" title="1">{
                return errors.New("vote mapping entity type cannot be empty")
        }</span>
        <span class="cov9" title="19">if vm.EntityID == "" </span><span class="cov1" title="1">{
                return errors.New("vote mapping entity ID cannot be empty")
        }</span>
        <span class="cov9" title="18">if vm.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("vote mapping user ID cannot be empty")
        }</span>
        <span class="cov9" title="17">if vm.VoteType == "" </span><span class="cov1" title="1">{
                return errors.New("vote mapping vote type cannot be empty")
        }</span>
        <span class="cov9" title="16">validTypes := map[string]bool{
                "upvote": true, "downvote": true, "like": true, "love": true,
                "celebrate": true, "support": true, "insightful": true,
        }
        if !validTypes[vm.VoteType] </span><span class="cov1" title="1">{
                return errors.New("invalid vote type")
        }</span>
        <span class="cov9" title="15">if vm.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("vote mapping created timestamp cannot be zero")
        }</span>
        <span class="cov8" title="14">return nil</span>
}

// SetTimestamps sets the created timestamp
func (vm *VoteMapping) SetTimestamps() <span class="cov0" title="0">{
        if vm.Created == 0 </span><span class="cov0" title="0">{
                vm.Created = time.Now().Unix()
        }</span>
}

// IsPositive returns true for positive vote types
func (vm *VoteMapping) IsPositive() bool <span class="cov7" title="8">{
        positiveTypes := map[string]bool{
                "upvote": true, "like": true, "love": true,
                "celebrate": true, "support": true, "insightful": true,
        }
        return positiveTypes[vm.VoteType]
}</span>

// IsNegative returns true for negative vote types
func (vm *VoteMapping) IsNegative() bool <span class="cov7" title="8">{
        return vm.VoteType == "downvote"
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package models

import (
        "errors"
        "time"
)

// DocumentTagMapping represents a tag-to-document mapping
type DocumentTagMapping struct {
        ID         string `json:"id" db:"id"`
        DocumentID string `json:"document_id" db:"document_id"`
        TagID      string `json:"tag_id" db:"tag_id"`
        UserID     string `json:"user_id" db:"user_id"`
        Created    int64  `json:"created" db:"created"`
        Deleted    bool   `json:"deleted" db:"deleted"`
}

// Validate validates the tag mapping
func (dtm *DocumentTagMapping) Validate() error <span class="cov6" title="6">{
        if dtm.ID == "" </span><span class="cov1" title="1">{
                return errors.New("tag mapping ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dtm.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("tag mapping document ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if dtm.TagID == "" </span><span class="cov1" title="1">{
                return errors.New("tag mapping tag ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if dtm.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("tag mapping user ID cannot be empty")
        }</span>
        <span class="cov3" title="2">if dtm.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("tag mapping created timestamp cannot be zero")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dtm *DocumentTagMapping) SetTimestamps() <span class="cov0" title="0">{
        if dtm.Created == 0 </span><span class="cov0" title="0">{
                dtm.Created = time.Now().Unix()
        }</span>
}

// DocumentEntityLink represents a link from a document to any system entity
type DocumentEntityLink struct {
        ID          string  `json:"id" db:"id"`
        DocumentID  string  `json:"document_id" db:"document_id"`
        EntityType  string  `json:"entity_type" db:"entity_type"` // "ticket", "project", "user", etc.
        EntityID    string  `json:"entity_id" db:"entity_id"`
        LinkType    string  `json:"link_type" db:"link_type"`
        Description *string `json:"description,omitempty" db:"description"`
        UserID      string  `json:"user_id" db:"user_id"`
        Created     int64   `json:"created" db:"created"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// Validate validates the entity link
func (del *DocumentEntityLink) Validate() error <span class="cov9" title="14">{
        if del.ID == "" </span><span class="cov1" title="1">{
                return errors.New("entity link ID cannot be empty")
        }</span>
        <span class="cov9" title="13">if del.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("entity link document ID cannot be empty")
        }</span>
        <span class="cov9" title="12">if del.EntityType == "" </span><span class="cov1" title="1">{
                return errors.New("entity link entity type cannot be empty")
        }</span>
        <span class="cov8" title="11">if del.EntityID == "" </span><span class="cov1" title="1">{
                return errors.New("entity link entity ID cannot be empty")
        }</span>
        <span class="cov8" title="10">if del.LinkType == "" </span><span class="cov1" title="1">{
                return errors.New("entity link link type cannot be empty")
        }</span>
        <span class="cov8" title="9">if del.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("entity link user ID cannot be empty")
        }</span>
        <span class="cov7" title="8">if del.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("entity link created timestamp cannot be zero")
        }</span>
        <span class="cov7" title="7">return nil</span>
}

// SetTimestamps sets the created timestamp
func (del *DocumentEntityLink) SetTimestamps() <span class="cov0" title="0">{
        if del.Created == 0 </span><span class="cov0" title="0">{
                del.Created = time.Now().Unix()
        }</span>
}

// DocumentRelationship represents a relationship between two documents
type DocumentRelationship struct {
        ID               string `json:"id" db:"id"`
        SourceDocumentID string `json:"source_document_id" db:"source_document_id"`
        TargetDocumentID string `json:"target_document_id" db:"target_document_id"`
        RelationshipType string `json:"relationship_type" db:"relationship_type"`
        UserID           string `json:"user_id" db:"user_id"`
        Created          int64  `json:"created" db:"created"`
        Deleted          bool   `json:"deleted" db:"deleted"`
}

// Validate validates the document relationship
func (dr *DocumentRelationship) Validate() error <span class="cov10" title="16">{
        if dr.ID == "" </span><span class="cov1" title="1">{
                return errors.New("relationship ID cannot be empty")
        }</span>
        <span class="cov9" title="15">if dr.SourceDocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("relationship source document ID cannot be empty")
        }</span>
        <span class="cov9" title="14">if dr.TargetDocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("relationship target document ID cannot be empty")
        }</span>
        <span class="cov9" title="13">if dr.SourceDocumentID == dr.TargetDocumentID </span><span class="cov1" title="1">{
                return errors.New("source and target document cannot be the same")
        }</span>
        <span class="cov9" title="12">if dr.RelationshipType == "" </span><span class="cov1" title="1">{
                return errors.New("relationship type cannot be empty")
        }</span>
        <span class="cov8" title="11">if dr.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("relationship user ID cannot be empty")
        }</span>
        <span class="cov8" title="10">if dr.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("relationship created timestamp cannot be zero")
        }</span>
        <span class="cov8" title="9">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dr *DocumentRelationship) SetTimestamps() <span class="cov0" title="0">{
        if dr.Created == 0 </span><span class="cov0" title="0">{
                dr.Created = time.Now().Unix()
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package models

import (
        "errors"
        "time"
)

// DocumentSpace represents a document space (similar to Confluence spaces)
// Spaces organize documents into logical groups
type DocumentSpace struct {
        ID          string `json:"id" db:"id"`
        Key         string `json:"key" db:"key"`                   // Short identifier (e.g., "DOCS", "TECH")
        Name        string `json:"name" db:"name"`
        Description string `json:"description,omitempty" db:"description"`
        OwnerID     string `json:"owner_id" db:"owner_id"`         // User who owns the space
        IsPublic    bool   `json:"is_public" db:"is_public"`       // Public or private space
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// Validate validates the document space
func (ds *DocumentSpace) Validate() error <span class="cov10" title="14">{
        if ds.ID == "" </span><span class="cov1" title="1">{
                return errors.New("document space ID cannot be empty")
        }</span>
        <span class="cov9" title="13">if ds.Key == "" </span><span class="cov1" title="1">{
                return errors.New("document space key cannot be empty")
        }</span>
        <span class="cov9" title="12">if ds.Name == "" </span><span class="cov1" title="1">{
                return errors.New("document space name cannot be empty")
        }</span>
        <span class="cov9" title="11">if ds.OwnerID == "" </span><span class="cov1" title="1">{
                return errors.New("document space owner ID cannot be empty")
        }</span>
        <span class="cov8" title="10">if ds.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("document space created timestamp cannot be zero")
        }</span>
        <span class="cov8" title="9">if ds.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("document space modified timestamp cannot be zero")
        }</span>
        <span class="cov8" title="8">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (ds *DocumentSpace) SetTimestamps() <span class="cov3" title="2">{
        now := time.Now().Unix()
        if ds.Created == 0 </span><span class="cov1" title="1">{
                ds.Created = now
        }</span>
        <span class="cov3" title="2">ds.Modified = now</span>
}

// DocumentType represents a document type (page, blog post, template, etc.)
type DocumentType struct {
        ID          string `json:"id" db:"id"`
        Key         string `json:"key" db:"key"`                   // "page", "blog", "template", etc.
        Name        string `json:"name" db:"name"`
        Description string `json:"description,omitempty" db:"description"`
        Icon        string `json:"icon,omitempty" db:"icon"`       // Icon identifier
        SchemaJSON  string `json:"schema_json,omitempty" db:"schema_json"` // JSON schema for this type
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// Validate validates the document type
func (dt *DocumentType) Validate() error <span class="cov8" title="10">{
        if dt.ID == "" </span><span class="cov1" title="1">{
                return errors.New("document type ID cannot be empty")
        }</span>
        <span class="cov8" title="9">if dt.Key == "" </span><span class="cov1" title="1">{
                return errors.New("document type key cannot be empty")
        }</span>
        <span class="cov8" title="8">if dt.Name == "" </span><span class="cov1" title="1">{
                return errors.New("document type name cannot be empty")
        }</span>
        <span class="cov7" title="7">if dt.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("document type created timestamp cannot be zero")
        }</span>
        <span class="cov7" title="6">if dt.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("document type modified timestamp cannot be zero")
        }</span>
        <span class="cov6" title="5">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (dt *DocumentType) SetTimestamps() <span class="cov3" title="2">{
        now := time.Now().Unix()
        if dt.Created == 0 </span><span class="cov1" title="1">{
                dt.Created = now
        }</span>
        <span class="cov3" title="2">dt.Modified = now</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package models

import (
        "errors"
        "time"
)

// DocumentTemplate represents a reusable document template
type DocumentTemplate struct {
        ID              string  `json:"id" db:"id"`
        Name            string  `json:"name" db:"name"`
        Description     *string `json:"description,omitempty" db:"description"`
        SpaceID         *string `json:"space_id,omitempty" db:"space_id"`
        TypeID          string  `json:"type_id" db:"type_id"`
        ContentTemplate string  `json:"content_template" db:"content_template"`
        VariablesJSON   *string `json:"variables_json,omitempty" db:"variables_json"`
        CreatorID       string  `json:"creator_id" db:"creator_id"`
        IsPublic        bool    `json:"is_public" db:"is_public"`
        UseCount        int     `json:"use_count" db:"use_count"`
        Created         int64   `json:"created" db:"created"`
        Modified        int64   `json:"modified" db:"modified"`
        Deleted         bool    `json:"deleted" db:"deleted"`
}

// Validate validates the document template
func (dt *DocumentTemplate) Validate() error <span class="cov7" title="9">{
        if dt.ID == "" </span><span class="cov1" title="1">{
                return errors.New("template ID cannot be empty")
        }</span>
        <span class="cov7" title="8">if dt.Name == "" </span><span class="cov1" title="1">{
                return errors.New("template name cannot be empty")
        }</span>
        <span class="cov7" title="7">if dt.TypeID == "" </span><span class="cov1" title="1">{
                return errors.New("template type ID cannot be empty")
        }</span>
        <span class="cov6" title="6">if dt.ContentTemplate == "" </span><span class="cov1" title="1">{
                return errors.New("template content cannot be empty")
        }</span>
        <span class="cov6" title="5">if dt.CreatorID == "" </span><span class="cov1" title="1">{
                return errors.New("template creator ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if dt.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("template created timestamp cannot be zero")
        }</span>
        <span class="cov4" title="3">if dt.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("template modified timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (dt *DocumentTemplate) SetTimestamps() <span class="cov3" title="2">{
        now := time.Now().Unix()
        if dt.Created == 0 </span><span class="cov1" title="1">{
                dt.Created = now
        }</span>
        <span class="cov3" title="2">dt.Modified = now</span>
}

// IncrementUseCount increments the use count
func (dt *DocumentTemplate) IncrementUseCount() <span class="cov10" title="17">{
        dt.UseCount++
}</span>

// DocumentBlueprint represents a multi-step template wizard
type DocumentBlueprint struct {
        ID             string  `json:"id" db:"id"`
        Name           string  `json:"name" db:"name"`
        Description    *string `json:"description,omitempty" db:"description"`
        SpaceID        *string `json:"space_id,omitempty" db:"space_id"`
        TemplateID     string  `json:"template_id" db:"template_id"`
        WizardStepsJSON *string `json:"wizard_steps_json,omitempty" db:"wizard_steps_json"`
        CreatorID      string  `json:"creator_id" db:"creator_id"`
        IsPublic       bool    `json:"is_public" db:"is_public"`
        Created        int64   `json:"created" db:"created"`
        Modified       int64   `json:"modified" db:"modified"`
        Deleted        bool    `json:"deleted" db:"deleted"`
}

// Validate validates the document blueprint
func (db *DocumentBlueprint) Validate() error <span class="cov7" title="8">{
        if db.ID == "" </span><span class="cov1" title="1">{
                return errors.New("blueprint ID cannot be empty")
        }</span>
        <span class="cov7" title="7">if db.Name == "" </span><span class="cov1" title="1">{
                return errors.New("blueprint name cannot be empty")
        }</span>
        <span class="cov6" title="6">if db.TemplateID == "" </span><span class="cov1" title="1">{
                return errors.New("blueprint template ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if db.CreatorID == "" </span><span class="cov1" title="1">{
                return errors.New("blueprint creator ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if db.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("blueprint created timestamp cannot be zero")
        }</span>
        <span class="cov4" title="3">if db.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("blueprint modified timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (db *DocumentBlueprint) SetTimestamps() <span class="cov3" title="2">{
        now := time.Now().Unix()
        if db.Created == 0 </span><span class="cov1" title="1">{
                db.Created = now
        }</span>
        <span class="cov3" title="2">db.Modified = now</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package models

import (
        "errors"
        "time"
)

// DocumentVersion represents a document version in the history
type DocumentVersion struct {
        ID            string  `json:"id" db:"id"`
        DocumentID    string  `json:"document_id" db:"document_id"`
        VersionNumber int     `json:"version_number" db:"version_number"`
        UserID        string  `json:"user_id" db:"user_id"`
        ChangeSummary *string `json:"change_summary,omitempty" db:"change_summary"`
        IsMajor       bool    `json:"is_major" db:"is_major"`
        IsMinor       bool    `json:"is_minor" db:"is_minor"`
        SnapshotJSON  *string `json:"snapshot_json,omitempty" db:"snapshot_json"` // Full snapshot
        ContentID     *string `json:"content_id,omitempty" db:"content_id"`
        Created       int64   `json:"created" db:"created"`
}

// Validate validates the document version
func (dv *DocumentVersion) Validate() error <span class="cov7" title="8">{
        if dv.ID == "" </span><span class="cov1" title="1">{
                return errors.New("document version ID cannot be empty")
        }</span>
        <span class="cov7" title="7">if dv.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("document version document ID cannot be empty")
        }</span>
        <span class="cov6" title="6">if dv.VersionNumber &lt; 1 </span><span class="cov1" title="1">{
                return errors.New("version number must be at least 1")
        }</span>
        <span class="cov6" title="5">if dv.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("document version user ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if dv.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("document version created timestamp cannot be zero")
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dv *DocumentVersion) SetTimestamps() <span class="cov3" title="2">{
        if dv.Created == 0 </span><span class="cov1" title="1">{
                dv.Created = time.Now().Unix()
        }</span>
}

// DocumentVersionLabel represents a label for a version
type DocumentVersionLabel struct {
        ID          string  `json:"id" db:"id"`
        VersionID   string  `json:"version_id" db:"version_id"`
        Label       string  `json:"label" db:"label"`
        Description *string `json:"description,omitempty" db:"description"`
        UserID      string  `json:"user_id" db:"user_id"`
        Created     int64   `json:"created" db:"created"`
}

// Validate validates the version label
func (dvl *DocumentVersionLabel) Validate() error <span class="cov7" title="7">{
        if dvl.ID == "" </span><span class="cov1" title="1">{
                return errors.New("version label ID cannot be empty")
        }</span>
        <span class="cov6" title="6">if dvl.VersionID == "" </span><span class="cov1" title="1">{
                return errors.New("version label version ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dvl.Label == "" </span><span class="cov1" title="1">{
                return errors.New("version label cannot be empty")
        }</span>
        <span class="cov5" title="4">if dvl.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("version label user ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if dvl.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("version label created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dvl *DocumentVersionLabel) SetTimestamps() <span class="cov0" title="0">{
        if dvl.Created == 0 </span><span class="cov0" title="0">{
                dvl.Created = time.Now().Unix()
        }</span>
}

// DocumentVersionTag represents a tag for a version
type DocumentVersionTag struct {
        ID        string `json:"id" db:"id"`
        VersionID string `json:"version_id" db:"version_id"`
        Tag       string `json:"tag" db:"tag"`
        UserID    string `json:"user_id" db:"user_id"`
        Created   int64  `json:"created" db:"created"`
}

// Validate validates the version tag
func (dvt *DocumentVersionTag) Validate() error <span class="cov6" title="6">{
        if dvt.ID == "" </span><span class="cov1" title="1">{
                return errors.New("version tag ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dvt.VersionID == "" </span><span class="cov1" title="1">{
                return errors.New("version tag version ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if dvt.Tag == "" </span><span class="cov1" title="1">{
                return errors.New("version tag cannot be empty")
        }</span>
        <span class="cov4" title="3">if dvt.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("version tag user ID cannot be empty")
        }</span>
        <span class="cov3" title="2">if dvt.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("version tag created timestamp cannot be zero")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dvt *DocumentVersionTag) SetTimestamps() <span class="cov0" title="0">{
        if dvt.Created == 0 </span><span class="cov0" title="0">{
                dvt.Created = time.Now().Unix()
        }</span>
}

// DocumentVersionComment represents a comment on a version
type DocumentVersionComment struct {
        ID        string `json:"id" db:"id"`
        VersionID string `json:"version_id" db:"version_id"`
        UserID    string `json:"user_id" db:"user_id"`
        Comment   string `json:"comment" db:"comment"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// Validate validates the version comment
func (dvc *DocumentVersionComment) Validate() error <span class="cov7" title="7">{
        if dvc.ID == "" </span><span class="cov1" title="1">{
                return errors.New("version comment ID cannot be empty")
        }</span>
        <span class="cov6" title="6">if dvc.VersionID == "" </span><span class="cov1" title="1">{
                return errors.New("version comment version ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dvc.UserID == "" </span><span class="cov1" title="1">{
                return errors.New("version comment user ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if dvc.Comment == "" </span><span class="cov1" title="1">{
                return errors.New("version comment cannot be empty")
        }</span>
        <span class="cov4" title="3">if dvc.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("version comment created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">if dvc.Modified == 0 </span><span class="cov1" title="1">{
                return errors.New("version comment modified timestamp cannot be zero")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// SetTimestamps sets created and modified timestamps
func (dvc *DocumentVersionComment) SetTimestamps() <span class="cov3" title="2">{
        now := time.Now().Unix()
        if dvc.Created == 0 </span><span class="cov1" title="1">{
                dvc.Created = now
        }</span>
        <span class="cov3" title="2">dvc.Modified = now</span>
}

// DocumentVersionMention represents a user mention in a version
type DocumentVersionMention struct {
        ID                string  `json:"id" db:"id"`
        VersionID         string  `json:"version_id" db:"version_id"`
        MentionedUserID   string  `json:"mentioned_user_id" db:"mentioned_user_id"`
        MentioningUserID  string  `json:"mentioning_user_id" db:"mentioning_user_id"`
        Context           *string `json:"context,omitempty" db:"context"`
        Created           int64   `json:"created" db:"created"`
}

// Validate validates the version mention
func (dvm *DocumentVersionMention) Validate() error <span class="cov7" title="7">{
        if dvm.ID == "" </span><span class="cov1" title="1">{
                return errors.New("version mention ID cannot be empty")
        }</span>
        <span class="cov6" title="6">if dvm.VersionID == "" </span><span class="cov1" title="1">{
                return errors.New("version mention version ID cannot be empty")
        }</span>
        <span class="cov6" title="5">if dvm.MentionedUserID == "" </span><span class="cov1" title="1">{
                return errors.New("mentioned user ID cannot be empty")
        }</span>
        <span class="cov5" title="4">if dvm.MentioningUserID == "" </span><span class="cov1" title="1">{
                return errors.New("mentioning user ID cannot be empty")
        }</span>
        <span class="cov4" title="3">if dvm.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("version mention created timestamp cannot be zero")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dvm *DocumentVersionMention) SetTimestamps() <span class="cov0" title="0">{
        if dvm.Created == 0 </span><span class="cov0" title="0">{
                dvm.Created = time.Now().Unix()
        }</span>
}

// DocumentVersionDiff represents a cached diff between versions
type DocumentVersionDiff struct {
        ID          string `json:"id" db:"id"`
        DocumentID  string `json:"document_id" db:"document_id"`
        FromVersion int    `json:"from_version" db:"from_version"`
        ToVersion   int    `json:"to_version" db:"to_version"`
        DiffType    string `json:"diff_type" db:"diff_type"` // "unified", "split", "html"
        DiffContent string `json:"diff_content" db:"diff_content"`
        Created     int64  `json:"created" db:"created"`
}

// Validate validates the version diff
func (dvd *DocumentVersionDiff) Validate() error <span class="cov10" title="15">{
        if dvd.ID == "" </span><span class="cov1" title="1">{
                return errors.New("version diff ID cannot be empty")
        }</span>
        <span class="cov9" title="14">if dvd.DocumentID == "" </span><span class="cov1" title="1">{
                return errors.New("version diff document ID cannot be empty")
        }</span>
        <span class="cov9" title="13">if dvd.FromVersion &lt; 1 </span><span class="cov1" title="1">{
                return errors.New("from version must be at least 1")
        }</span>
        <span class="cov9" title="12">if dvd.ToVersion &lt; 1 </span><span class="cov1" title="1">{
                return errors.New("to version must be at least 1")
        }</span>
        <span class="cov8" title="11">if dvd.FromVersion &gt;= dvd.ToVersion </span><span class="cov1" title="1">{
                return errors.New("from version must be less than to version")
        }</span>
        <span class="cov8" title="10">if dvd.DiffType == "" </span><span class="cov1" title="1">{
                return errors.New("diff type cannot be empty")
        }</span>
        <span class="cov8" title="9">validTypes := map[string]bool{
                "unified": true, "split": true, "html": true,
        }
        if !validTypes[dvd.DiffType] </span><span class="cov1" title="1">{
                return errors.New("invalid diff type")
        }</span>
        <span class="cov7" title="8">if dvd.DiffContent == "" </span><span class="cov1" title="1">{
                return errors.New("diff content cannot be empty")
        }</span>
        <span class="cov7" title="7">if dvd.Created == 0 </span><span class="cov1" title="1">{
                return errors.New("version diff created timestamp cannot be zero")
        }</span>
        <span class="cov6" title="6">return nil</span>
}

// SetTimestamps sets the created timestamp
func (dvd *DocumentVersionDiff) SetTimestamps() <span class="cov0" title="0">{
        if dvd.Created == 0 </span><span class="cov0" title="0">{
                dvd.Created = time.Now().Unix()
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package models

// Epic represents an epic - a large user story that can contain multiple stories
// Epics are implemented as a special type of ticket with additional fields
type Epic struct {
        ID        string  `json:"id" db:"id"`
        TicketID  string  `json:"ticketId" db:"ticket_id"` // References ticket table
        EpicColor *string `json:"epicColor,omitempty" db:"epic_color"`
        EpicName  *string `json:"epicName,omitempty" db:"epic_name"`
        IsEpic    bool    `json:"isEpic" db:"is_epic"`
}

// EpicStoryMapping represents a story belonging to an epic
// This is conceptual - in practice, stories have epic_id field in ticket table
type EpicStoryMapping struct {
        EpicID  string `json:"epicId"`
        StoryID string `json:"storyId"`
}

// Epic color constants (standard JIRA epic colors)
const (
        EpicColorGhola    = "#6554C0" // Purple
        EpicColorWestar   = "#00B8D9" // Cyan
        EpicColorJungle   = "#00875A" // Green
        EpicColorKournikova = "#FFAB00" // Yellow
        EpicColorRust     = "#FF8B00" // Orange
        EpicColorMonza    = "#DE350B" // Red
        EpicColorStorm    = "#5E6C84" // Grey
)

// IsEpicTicket checks if this represents an epic ticket
func (e *Epic) IsEpicTicket() bool <span class="cov0" title="0">{
        return e.IsEpic
}</span>

// GetColor returns the epic color or default
func (e *Epic) GetColor() string <span class="cov0" title="0">{
        if e.EpicColor != nil &amp;&amp; *e.EpicColor != "" </span><span class="cov0" title="0">{
                return *e.EpicColor
        }</span>
        <span class="cov0" title="0">return EpicColorGhola</span> // Default to purple
}

// GetName returns the epic name or empty string
func (e *Epic) GetName() string <span class="cov0" title="0">{
        if e.EpicName != nil </span><span class="cov0" title="0">{
                return *e.EpicName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// HasName checks if the epic has a name set
func (e *Epic) HasName() bool <span class="cov0" title="0">{
        return e.EpicName != nil &amp;&amp; *e.EpicName != ""
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package models

// Error code constants following the specification
const (
        // No error
        ErrorCodeNoError = -1

        // Request-related errors (100X)
        ErrorCodeInvalidRequest = 1000
        ErrorCodeInvalidAction  = 1001
        ErrorCodeMissingJWT     = 1002
        ErrorCodeInvalidJWT     = 1003
        ErrorCodeMissingObject  = 1004
        ErrorCodeInvalidObject  = 1005
        ErrorCodeMissingData    = 1006
        ErrorCodeInvalidData    = 1007
        ErrorCodeUnauthorized   = 1008
        ErrorCodeForbidden      = 1009

        // System-related errors (200X)
        ErrorCodeInternalError          = 2000
        ErrorCodeDatabaseError          = 2001
        ErrorCodeServiceUnavailable     = 2002
        ErrorCodeConfigurationError     = 2003
        ErrorCodeAuthServiceError       = 2004
        ErrorCodePermissionServiceError = 2005
        ErrorCodeExtensionServiceError  = 2006

        // Entity-related errors (300X)
        ErrorCodeEntityNotFound         = 3000
        ErrorCodeEntityAlreadyExists    = 3001
        ErrorCodeEntityValidationFailed = 3002
        ErrorCodeEntityDeleteFailed     = 3003
        ErrorCodeEntityUpdateFailed     = 3004
        ErrorCodeEntityCreateFailed     = 3005
        ErrorCodeVersionConflict        = 3006
)

// ErrorMessages provides default English error messages
var ErrorMessages = map[int]string{
        ErrorCodeNoError:                "Success",
        ErrorCodeInvalidRequest:         "Invalid request",
        ErrorCodeInvalidAction:          "Invalid action",
        ErrorCodeMissingJWT:             "Missing JWT token",
        ErrorCodeInvalidJWT:             "Invalid JWT token",
        ErrorCodeMissingObject:          "Missing object type",
        ErrorCodeInvalidObject:          "Invalid object type",
        ErrorCodeMissingData:            "Missing required data",
        ErrorCodeInvalidData:            "Invalid data format",
        ErrorCodeUnauthorized:           "Unauthorized",
        ErrorCodeForbidden:              "Forbidden - insufficient permissions",
        ErrorCodeInternalError:          "Internal server error",
        ErrorCodeDatabaseError:          "Database error",
        ErrorCodeServiceUnavailable:     "Service unavailable",
        ErrorCodeConfigurationError:     "Configuration error",
        ErrorCodeAuthServiceError:       "Authentication service error",
        ErrorCodePermissionServiceError: "Permission service error",
        ErrorCodeExtensionServiceError:  "Extension service error",
        ErrorCodeEntityNotFound:         "Entity not found",
        ErrorCodeEntityAlreadyExists:    "Entity already exists",
        ErrorCodeEntityValidationFailed: "Entity validation failed",
        ErrorCodeEntityDeleteFailed:     "Failed to delete entity",
        ErrorCodeEntityUpdateFailed:     "Failed to update entity",
        ErrorCodeEntityCreateFailed:     "Failed to create entity",
        ErrorCodeVersionConflict:        "Version conflict - entity was modified by another user",
}

// GetErrorMessage returns the error message for a given error code
func GetErrorMessage(code int) string <span class="cov10" title="49">{
        if msg, ok := ErrorMessages[code]; ok </span><span class="cov9" title="48">{
                return msg
        }</span>
        <span class="cov1" title="1">return "Unknown error"</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package models

import (
        "time"
)

// EventType represents the type of event
type EventType string

// Event type constants
const (
        // Entity lifecycle events
        EventEntityCreated EventType = "entity.created"
        EventEntityUpdated EventType = "entity.updated"
        EventEntityDeleted EventType = "entity.deleted"
        EventEntityRead    EventType = "entity.read"

        // Ticket events
        EventTicketCreated EventType = "ticket.created"
        EventTicketUpdated EventType = "ticket.updated"
        EventTicketDeleted EventType = "ticket.deleted"
        EventTicketRead    EventType = "ticket.read"

        // Project events
        EventProjectCreated EventType = "project.created"
        EventProjectUpdated EventType = "project.updated"
        EventProjectDeleted EventType = "project.deleted"
        EventProjectRead    EventType = "project.read"

        // Comment events
        EventCommentCreated EventType = "comment.created"
        EventCommentUpdated EventType = "comment.updated"
        EventCommentDeleted EventType = "comment.deleted"
        EventCommentRead    EventType = "comment.read"

        // Priority events
        EventPriorityCreated EventType = "priority.created"
        EventPriorityUpdated EventType = "priority.updated"
        EventPriorityDeleted EventType = "priority.deleted"
        EventPriorityRead    EventType = "priority.read"

        // Resolution events
        EventResolutionCreated EventType = "resolution.created"
        EventResolutionUpdated EventType = "resolution.updated"
        EventResolutionDeleted EventType = "resolution.deleted"
        EventResolutionRead    EventType = "resolution.read"

        // Version events
        EventVersionCreated  EventType = "version.created"
        EventVersionUpdated  EventType = "version.updated"
        EventVersionDeleted  EventType = "version.deleted"
        EventVersionRead     EventType = "version.read"
        EventVersionReleased EventType = "version.released"
        EventVersionArchived EventType = "version.archived"

        // Watcher events
        EventWatcherAdded   EventType = "watcher.added"
        EventWatcherRemoved EventType = "watcher.removed"

        // Filter events
        EventFilterSaved   EventType = "filter.saved"
        EventFilterUpdated EventType = "filter.updated"
        EventFilterDeleted EventType = "filter.deleted"
        EventFilterShared  EventType = "filter.shared"

        // Custom field events
        EventCustomFieldCreated EventType = "customfield.created"
        EventCustomFieldUpdated EventType = "customfield.updated"
        EventCustomFieldDeleted EventType = "customfield.deleted"
        EventCustomFieldRead    EventType = "customfield.read"

        // Board events
        EventBoardCreated EventType = "board.created"
        EventBoardUpdated EventType = "board.updated"
        EventBoardDeleted EventType = "board.deleted"

        // Cycle events (Sprint/Milestone/Release)
        EventCycleCreated EventType = "cycle.created"
        EventCycleUpdated EventType = "cycle.updated"
        EventCycleDeleted EventType = "cycle.deleted"

        // Workflow events
        EventWorkflowCreated EventType = "workflow.created"
        EventWorkflowUpdated EventType = "workflow.updated"
        EventWorkflowDeleted EventType = "workflow.deleted"

        // Account events
        EventAccountCreated EventType = "account.created"
        EventAccountUpdated EventType = "account.updated"
        EventAccountDeleted EventType = "account.deleted"

        // Organization events
        EventOrganizationCreated EventType = "organization.created"
        EventOrganizationUpdated EventType = "organization.updated"
        EventOrganizationDeleted EventType = "organization.deleted"

        // Team events
        EventTeamCreated EventType = "team.created"
        EventTeamUpdated EventType = "team.updated"
        EventTeamDeleted EventType = "team.deleted"

        // User events
        EventUserCreated EventType = "user.created"
        EventUserUpdated EventType = "user.updated"
        EventUserDeleted EventType = "user.deleted"

        // System events
        EventSystemHealthCheck EventType = "system.health_check"
        EventSystemError       EventType = "system.error"
        EventSystemShutdown    EventType = "system.shutdown"

        // Connection events
        EventConnectionEstablished EventType = "connection.established"
        EventConnectionClosed      EventType = "connection.closed"
        EventConnectionError       EventType = "connection.error"
)

// Event represents a system event to be broadcasted via WebSocket
type Event struct {
        ID        string                 `json:"id"`        // Unique event ID (UUID)
        Type      EventType              `json:"type"`      // Event type (e.g., "ticket.created")
        Action    string                 `json:"action"`    // Action that triggered the event (e.g., "create", "modify")
        Object    string                 `json:"object"`    // Object type (e.g., "ticket", "project")
        EntityID  string                 `json:"entityId"`  // ID of the entity affected
        Username  string                 `json:"username"`  // Username who triggered the event
        Timestamp time.Time              `json:"timestamp"` // When the event occurred
        Data      map[string]interface{} `json:"data"`      // Additional event data
        Context   EventContext           `json:"context"`   // Event context (permissions, etc.)
}

// EventContext contains contextual information about the event
type EventContext struct {
        ProjectID      string   `json:"projectId,omitempty"`      // Project ID if relevant
        OrganizationID string   `json:"organizationId,omitempty"` // Organization ID if relevant
        TeamID         string   `json:"teamId,omitempty"`         // Team ID if relevant
        AccountID      string   `json:"accountId,omitempty"`      // Account ID if relevant
        Permissions    []string `json:"permissions,omitempty"`    // Required permissions to see this event
}

// Subscription represents a client's subscription to specific event types
type Subscription struct {
        EventTypes     []EventType          `json:"eventTypes"`     // Event types to subscribe to
        EntityTypes    []string             `json:"entityTypes"`    // Entity types to filter (ticket, project, etc.)
        EntityIDs      []string             `json:"entityIds"`      // Specific entity IDs to filter
        Filters        map[string]string    `json:"filters"`        // Additional filters (projectId, teamId, etc.)
        IncludeReads   bool                 `json:"includeReads"`   // Whether to include read events
        CustomFilters  map[string][]string  `json:"customFilters"`  // Custom filter criteria
        PermissionMask int                  `json:"permissionMask"` // Required permission level
}

// NewEvent creates a new event with the given parameters
func NewEvent(eventType EventType, action, object, entityID, username string, data map[string]interface{}) *Event <span class="cov6" title="8">{
        return &amp;Event{
                ID:        generateEventID(),
                Type:      eventType,
                Action:    action,
                Object:    object,
                EntityID:  entityID,
                Username:  username,
                Timestamp: time.Now().UTC(),
                Data:      data,
                Context:   EventContext{},
        }
}</span>

// WithContext adds context to the event
func (e *Event) WithContext(context EventContext) *Event <span class="cov5" title="5">{
        e.Context = context
        return e
}</span>

// MatchesSubscription checks if the event matches a subscription
func (e *Event) MatchesSubscription(sub *Subscription) bool <span class="cov8" title="15">{
        // Check event type
        if len(sub.EventTypes) &gt; 0 </span><span class="cov4" title="3">{
                matched := false
                for _, et := range sub.EventTypes </span><span class="cov4" title="4">{
                        if e.Type == et </span><span class="cov2" title="2">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov4" title="3">if !matched </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check entity type
        <span class="cov8" title="14">if len(sub.EntityTypes) &gt; 0 </span><span class="cov4" title="3">{
                matched := false
                for _, et := range sub.EntityTypes </span><span class="cov4" title="4">{
                        if e.Object == et </span><span class="cov2" title="2">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov4" title="3">if !matched </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check entity ID
        <span class="cov8" title="13">if len(sub.EntityIDs) &gt; 0 </span><span class="cov4" title="3">{
                matched := false
                for _, eid := range sub.EntityIDs </span><span class="cov4" title="4">{
                        if e.EntityID == eid </span><span class="cov2" title="2">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov4" title="3">if !matched </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check if read events should be included
        <span class="cov8" title="12">if !sub.IncludeReads &amp;&amp; isReadEvent(e.Type) </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check filters (projectId, teamId, etc.)
        <span class="cov7" title="11">if len(sub.Filters) &gt; 0 </span><span class="cov6" title="6">{
                for key, value := range sub.Filters </span><span class="cov6" title="6">{
                        switch key </span>{
                        case "projectId":<span class="cov4" title="3">
                                if e.Context.ProjectID != value </span><span class="cov1" title="1">{
                                        return false
                                }</span>
                        case "organizationId":<span class="cov1" title="1">
                                if e.Context.OrganizationID != value </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        case "teamId":<span class="cov1" title="1">
                                if e.Context.TeamID != value </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        case "accountId":<span class="cov1" title="1">
                                if e.Context.AccountID != value </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }
        }

        <span class="cov7" title="10">return true</span>
}

// generateEventID generates a unique event ID
func generateEventID() string <span class="cov6" title="8">{
        // Use UUID generation from existing codebase
        // This is a placeholder - will use github.com/google/uuid
        return time.Now().Format("20060102150405.000000")
}</span>

// isReadEvent checks if the event type is a read event
func isReadEvent(eventType EventType) bool <span class="cov10" title="23">{
        return eventType == EventEntityRead ||
                eventType == EventTicketRead ||
                eventType == EventProjectRead ||
                eventType == EventCommentRead ||
                eventType == EventPriorityRead ||
                eventType == EventResolutionRead ||
                eventType == EventVersionRead ||
                eventType == EventCustomFieldRead
}</span>

// GetEventTypeFromAction returns the appropriate event type for an action and object
func GetEventTypeFromAction(action, object string) EventType <span class="cov10" title="23">{
        switch action </span>{
        case ActionCreate:<span class="cov8" title="16">
                return getCreateEventType(object)</span>
        case ActionModify:<span class="cov4" title="3">
                return getUpdateEventType(object)</span>
        case ActionRemove:<span class="cov2" title="2">
                return getDeleteEventType(object)</span>
        case ActionRead:<span class="cov1" title="1">
                return getReadEventType(object)</span>
        default:<span class="cov1" title="1">
                return EventEntityCreated</span>
        }
}

func getCreateEventType(object string) EventType <span class="cov8" title="16">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketCreated</span>
        case "project":<span class="cov1" title="1">
                return EventProjectCreated</span>
        case "comment":<span class="cov1" title="1">
                return EventCommentCreated</span>
        case "priority":<span class="cov1" title="1">
                return EventPriorityCreated</span>
        case "resolution":<span class="cov1" title="1">
                return EventResolutionCreated</span>
        case "version":<span class="cov1" title="1">
                return EventVersionCreated</span>
        case "filter":<span class="cov1" title="1">
                return EventFilterSaved</span>
        case "customfield":<span class="cov1" title="1">
                return EventCustomFieldCreated</span>
        case "board":<span class="cov1" title="1">
                return EventBoardCreated</span>
        case "cycle":<span class="cov1" title="1">
                return EventCycleCreated</span>
        case "workflow":<span class="cov1" title="1">
                return EventWorkflowCreated</span>
        case "account":<span class="cov1" title="1">
                return EventAccountCreated</span>
        case "organization":<span class="cov1" title="1">
                return EventOrganizationCreated</span>
        case "team":<span class="cov1" title="1">
                return EventTeamCreated</span>
        case "user":<span class="cov1" title="1">
                return EventUserCreated</span>
        default:<span class="cov1" title="1">
                return EventEntityCreated</span>
        }
}

func getUpdateEventType(object string) EventType <span class="cov4" title="3">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketUpdated</span>
        case "project":<span class="cov1" title="1">
                return EventProjectUpdated</span>
        case "comment":<span class="cov0" title="0">
                return EventCommentUpdated</span>
        case "priority":<span class="cov1" title="1">
                return EventPriorityUpdated</span>
        case "resolution":<span class="cov0" title="0">
                return EventResolutionUpdated</span>
        case "version":<span class="cov0" title="0">
                return EventVersionUpdated</span>
        case "filter":<span class="cov0" title="0">
                return EventFilterUpdated</span>
        case "customfield":<span class="cov0" title="0">
                return EventCustomFieldUpdated</span>
        case "board":<span class="cov0" title="0">
                return EventBoardUpdated</span>
        case "cycle":<span class="cov0" title="0">
                return EventCycleUpdated</span>
        case "workflow":<span class="cov0" title="0">
                return EventWorkflowUpdated</span>
        case "account":<span class="cov0" title="0">
                return EventAccountUpdated</span>
        case "organization":<span class="cov0" title="0">
                return EventOrganizationUpdated</span>
        case "team":<span class="cov0" title="0">
                return EventTeamUpdated</span>
        case "user":<span class="cov0" title="0">
                return EventUserUpdated</span>
        default:<span class="cov0" title="0">
                return EventEntityUpdated</span>
        }
}

func getDeleteEventType(object string) EventType <span class="cov2" title="2">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketDeleted</span>
        case "project":<span class="cov1" title="1">
                return EventProjectDeleted</span>
        case "comment":<span class="cov0" title="0">
                return EventCommentDeleted</span>
        case "priority":<span class="cov0" title="0">
                return EventPriorityDeleted</span>
        case "resolution":<span class="cov0" title="0">
                return EventResolutionDeleted</span>
        case "version":<span class="cov0" title="0">
                return EventVersionDeleted</span>
        case "filter":<span class="cov0" title="0">
                return EventFilterDeleted</span>
        case "customfield":<span class="cov0" title="0">
                return EventCustomFieldDeleted</span>
        case "board":<span class="cov0" title="0">
                return EventBoardDeleted</span>
        case "cycle":<span class="cov0" title="0">
                return EventCycleDeleted</span>
        case "workflow":<span class="cov0" title="0">
                return EventWorkflowDeleted</span>
        case "account":<span class="cov0" title="0">
                return EventAccountDeleted</span>
        case "organization":<span class="cov0" title="0">
                return EventOrganizationDeleted</span>
        case "team":<span class="cov0" title="0">
                return EventTeamDeleted</span>
        case "user":<span class="cov0" title="0">
                return EventUserDeleted</span>
        default:<span class="cov0" title="0">
                return EventEntityDeleted</span>
        }
}

func getReadEventType(object string) EventType <span class="cov1" title="1">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketRead</span>
        case "project":<span class="cov0" title="0">
                return EventProjectRead</span>
        case "comment":<span class="cov0" title="0">
                return EventCommentRead</span>
        case "priority":<span class="cov0" title="0">
                return EventPriorityRead</span>
        case "resolution":<span class="cov0" title="0">
                return EventResolutionRead</span>
        case "version":<span class="cov0" title="0">
                return EventVersionRead</span>
        case "customfield":<span class="cov0" title="0">
                return EventCustomFieldRead</span>
        default:<span class="cov0" title="0">
                return EventEntityRead</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package models

// Extension represents an extension/plugin in the system
type Extension struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title" binding:"required"`
        Description *string `json:"description,omitempty" db:"description"` // NULL allowed
        Version     string  `json:"version" db:"version"`
        Enabled     bool    `json:"enabled" db:"enabled"`
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// ExtensionMetaData represents additional metadata for extensions
type ExtensionMetaData struct {
        ID          string `json:"id" db:"id"`
        ExtensionID string `json:"extensionId" db:"extension_id" binding:"required"`
        Property    string `json:"property" db:"property" binding:"required"`
        Value       string `json:"value" db:"value"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// IsValid validates if the extension has required fields
func (e *Extension) IsValid() bool <span class="cov0" title="0">{
        return e.Title != ""
}</span>

// IsEnabled checks if the extension is enabled
func (e *Extension) IsEnabled() bool <span class="cov0" title="0">{
        return e.Enabled &amp;&amp; !e.Deleted
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package models

// Filter represents a saved search filter
type Filter struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        OwnerID     string `json:"ownerId" db:"owner_id" binding:"required"`
        Query       string `json:"query" db:"query" binding:"required"` // JSON query structure
        IsPublic    bool   `json:"isPublic" db:"is_public"`
        IsFavorite  bool   `json:"isFavorite" db:"is_favorite"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// FilterShareMapping represents filter sharing with users/teams/projects
type FilterShareMapping struct {
        ID        string  `json:"id" db:"id"`
        FilterID  string  `json:"filterId" db:"filter_id" binding:"required"`
        UserID    *string `json:"userId,omitempty" db:"user_id"`    // Pointer for nullable
        TeamID    *string `json:"teamId,omitempty" db:"team_id"`    // Pointer for nullable
        ProjectID *string `json:"projectId,omitempty" db:"project_id"` // Pointer for nullable
        Created   int64   `json:"created" db:"created"`
        Deleted   bool    `json:"deleted" db:"deleted"`
}

// ShareType represents the type of share
type ShareType string

const (
        ShareTypeUser    ShareType = "user"
        ShareTypeTeam    ShareType = "team"
        ShareTypeProject ShareType = "project"
        ShareTypePublic  ShareType = "public"
)

// GetShareType determines the share type based on which ID is set
func (f *FilterShareMapping) GetShareType() ShareType <span class="cov5" title="4">{
        if f.UserID != nil </span><span class="cov1" title="1">{
                return ShareTypeUser
        }</span>
        <span class="cov4" title="3">if f.TeamID != nil </span><span class="cov1" title="1">{
                return ShareTypeTeam
        }</span>
        <span class="cov3" title="2">if f.ProjectID != nil </span><span class="cov1" title="1">{
                return ShareTypeProject
        }</span>
        <span class="cov1" title="1">return ShareTypePublic</span>
}

// IsSharedWith checks if the filter is shared with a specific entity
func (f *Filter) IsSharedWith(userID, teamID, projectID string, shares []FilterShareMapping) bool <span class="cov7" title="9">{
        if f.IsPublic </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov7" title="8">for _, share := range shares </span><span class="cov10" title="18">{
                if share.Deleted </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov9" title="16">if share.UserID != nil &amp;&amp; *share.UserID == userID </span><span class="cov3" title="2">{
                        return true
                }</span>
                <span class="cov9" title="14">if share.TeamID != nil &amp;&amp; *share.TeamID == teamID </span><span class="cov3" title="2">{
                        return true
                }</span>
                <span class="cov8" title="12">if share.ProjectID != nil &amp;&amp; *share.ProjectID == projectID </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov4" title="3">return false</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package models

import (
        "fmt"
        "strings"
)

// EntityHistory represents a historical change to any editable entity
type EntityHistory struct {
        ID            string                 `json:"id" db:"id"`
        EntityID      string                 `json:"entityId" db:"entity_id"`
        EntityType    string                 `json:"entityType" db:"entity_type"`
        Version       int                    `json:"version" db:"version"`
        Action        string                 `json:"action" db:"action"`
        UserID        string                 `json:"userId" db:"user_id"`
        Timestamp     int64                  `json:"timestamp" db:"timestamp"`
        OldData       map[string]interface{} `json:"oldData,omitempty" db:"old_data"`
        NewData       map[string]interface{} `json:"newData,omitempty" db:"new_data"`
        ChangeSummary string                 `json:"changeSummary" db:"change_summary"`
        ConflictData  map[string]interface{} `json:"conflictData,omitempty" db:"conflict_data"`
}

// TicketHistory represents historical changes to tickets
type TicketHistory struct {
        ID            string                 `json:"id" db:"id"`
        TicketID      string                 `json:"ticketId" db:"ticket_id"`
        Version       int                    `json:"version" db:"version"`
        Action        string                 `json:"action" db:"action"`
        UserID        string                 `json:"userId" db:"user_id"`
        Timestamp     int64                  `json:"timestamp" db:"timestamp"`
        OldData       map[string]interface{} `json:"oldData,omitempty" db:"old_data"`
        NewData       map[string]interface{} `json:"newData,omitempty" db:"new_data"`
        ChangeSummary string                 `json:"changeSummary" db:"change_summary"`
        ConflictData  map[string]interface{} `json:"conflictData,omitempty" db:"conflict_data"`
}

// ProjectHistory represents historical changes to projects
type ProjectHistory struct {
        ID            string                 `json:"id" db:"id"`
        ProjectID     string                 `json:"projectId" db:"project_id"`
        Version       int                    `json:"version" db:"version"`
        Action        string                 `json:"action" db:"action"`
        UserID        string                 `json:"userId" db:"user_id"`
        Timestamp     int64                  `json:"timestamp" db:"timestamp"`
        OldData       map[string]interface{} `json:"oldData,omitempty" db:"old_data"`
        NewData       map[string]interface{} `json:"newData,omitempty" db:"new_data"`
        ChangeSummary string                 `json:"changeSummary" db:"change_summary"`
        ConflictData  map[string]interface{} `json:"conflictData,omitempty" db:"conflict_data"`
}

// CommentHistory represents historical changes to comments
type CommentHistory struct {
        ID            string                 `json:"id" db:"id"`
        CommentID     string                 `json:"commentId" db:"comment_id"`
        Version       int                    `json:"version" db:"version"`
        Action        string                 `json:"action" db:"action"`
        UserID        string                 `json:"userId" db:"user_id"`
        Timestamp     int64                  `json:"timestamp" db:"timestamp"`
        OldData       map[string]interface{} `json:"oldData,omitempty" db:"old_data"`
        NewData       map[string]interface{} `json:"newData,omitempty" db:"new_data"`
        ChangeSummary string                 `json:"changeSummary" db:"change_summary"`
        ConflictData  map[string]interface{} `json:"conflictData,omitempty" db:"conflict_data"`
}

// DashboardHistory represents historical changes to dashboards
type DashboardHistory struct {
        ID            string                 `json:"id" db:"id"`
        DashboardID   string                 `json:"dashboardId" db:"dashboard_id"`
        Version       int                    `json:"version" db:"version"`
        Action        string                 `json:"action" db:"action"`
        UserID        string                 `json:"userId" db:"user_id"`
        Timestamp     int64                  `json:"timestamp" db:"timestamp"`
        OldData       map[string]interface{} `json:"oldData,omitempty" db:"old_data"`
        NewData       map[string]interface{} `json:"newData,omitempty" db:"new_data"`
        ChangeSummary string                 `json:"changeSummary" db:"change_summary"`
        ConflictData  map[string]interface{} `json:"conflictData,omitempty" db:"conflict_data"`
}

// BoardHistory represents historical changes to boards
type BoardHistory struct {
        ID            string                 `json:"id" db:"id"`
        BoardID       string                 `json:"boardId" db:"board_id"`
        Version       int                    `json:"version" db:"version"`
        Action        string                 `json:"action" db:"action"`
        UserID        string                 `json:"userId" db:"user_id"`
        Timestamp     int64                  `json:"timestamp" db:"timestamp"`
        OldData       map[string]interface{} `json:"oldData,omitempty" db:"old_data"`
        NewData       map[string]interface{} `json:"newData,omitempty" db:"new_data"`
        ChangeSummary string                 `json:"changeSummary" db:"change_summary"`
        ConflictData  map[string]interface{} `json:"conflictData,omitempty" db:"conflict_data"`
}

// EntityLock represents a lock on an entity for collaborative editing
type EntityLock struct {
        ID         string                 `json:"id" db:"id"`
        EntityType string                 `json:"entityType" db:"entity_type"`
        EntityID   string                 `json:"entityId" db:"entity_id"`
        UserID     string                 `json:"userId" db:"user_id"`
        LockType   string                 `json:"lockType" db:"lock_type"` // 'optimistic', 'pessimistic'
        AcquiredAt int64                  `json:"acquiredAt" db:"acquired_at"`
        ExpiresAt  *int64                 `json:"expiresAt,omitempty" db:"expires_at"` // NULL for optimistic locks
        Metadata   map[string]interface{} `json:"metadata,omitempty" db:"metadata"`
}

// ConflictResolution represents how to resolve version conflicts
type ConflictResolution string

const (
        ConflictOverwrite ConflictResolution = "overwrite" // Overwrite with new changes
        ConflictMerge     ConflictResolution = "merge"     // Attempt to merge changes
        ConflictCancel    ConflictResolution = "cancel"    // Cancel the operation
)

// VersionConflictError represents a version conflict during optimistic locking
type VersionConflictError struct {
        EntityType      string
        EntityID        string
        ExpectedVersion int
        CurrentVersion  int
        CurrentData     map[string]interface{}
}

func (e *VersionConflictError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("version conflict on %s %s: expected version %d, got %d",
                e.EntityType, e.EntityID, e.ExpectedVersion, e.CurrentVersion)
}</span>

// NewVersionConflictError creates a new version conflict error
func NewVersionConflictError(entityType, entityID string, expectedVersion, currentVersion int, currentData map[string]interface{}) *VersionConflictError <span class="cov0" title="0">{
        return &amp;VersionConflictError{
                EntityType:      entityType,
                EntityID:        entityID,
                ExpectedVersion: expectedVersion,
                CurrentVersion:  currentVersion,
                CurrentData:     currentData,
        }
}</span>

// GenerateChangeSummary creates a human-readable summary of changes
func GenerateChangeSummary(action string, oldData, newData map[string]interface{}) string <span class="cov0" title="0">{
        switch action </span>{
        case ActionCreate:<span class="cov0" title="0">
                return "Entity created"</span>
        case ActionRemove:<span class="cov0" title="0">
                return "Entity deleted"</span>
        case ActionModify:<span class="cov0" title="0">
                changes := []string{}
                for key, newVal := range newData </span><span class="cov0" title="0">{
                        if oldVal, exists := oldData[key]; exists </span><span class="cov0" title="0">{
                                if oldVal != newVal </span><span class="cov0" title="0">{
                                        changes = append(changes, fmt.Sprintf("%s changed", key))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                changes = append(changes, fmt.Sprintf("%s added", key))
                        }</span>
                }
                <span class="cov0" title="0">for key := range oldData </span><span class="cov0" title="0">{
                        if _, exists := newData[key]; !exists </span><span class="cov0" title="0">{
                                changes = append(changes, fmt.Sprintf("%s removed", key))
                        }</span>
                }
                <span class="cov0" title="0">if len(changes) == 0 </span><span class="cov0" title="0">{
                        return "Entity updated (no field changes detected)"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Entity updated: %s", strings.Join(changes, ", "))</span>
        default:<span class="cov0" title="0">
                return "Unknown action"</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package models

import (
        "strings"

        "github.com/golang-jwt/jwt/v5"
)

// JWTClaims represents the JWT token claims structure
type JWTClaims struct {
        jwt.RegisteredClaims
        Name          string `json:"name"`
        Username      string `json:"username"`
        Email         string `json:"email"`
        Role          string `json:"role"`
        Permissions   string `json:"permissions"`
        HTCoreAddress string `json:"htCoreAddress"`
}

// PermissionLevel represents the access level for permissions
type PermissionLevel int

const (
        PermissionNone   PermissionLevel = 0
        PermissionRead   PermissionLevel = 1
        PermissionCreate PermissionLevel = 2
        PermissionUpdate PermissionLevel = 3
        PermissionDelete PermissionLevel = 5 // Also represents ALL permissions
)

// Permission represents a permission context and level
type Permission struct {
        ID          string          `json:"id" db:"id"`
        Title       string          `json:"title" db:"title"`
        Description string          `json:"description,omitempty" db:"description"`
        Context     string          `json:"context" db:"context"` // Hierarchical context (node  account  organization  team/project)
        Level       PermissionLevel `json:"level" db:"level"`     // Access level
        Created     int64           `json:"created" db:"created"`
        Modified    int64           `json:"modified" db:"modified"`
        Deleted     bool            `json:"deleted" db:"deleted"`
}

// PermissionContext represents a hierarchical permission context
type PermissionContext struct {
        Type       string // node, account, organization, team, project, ticket
        Identifier string // UUID of the entity
        Parent     *PermissionContext
}

// PermissionCheck represents a permission check request
type PermissionCheck struct {
        Username       string
        Context        string
        RequiredLevel  PermissionLevel
        EntityType     string // ticket, project, board, etc.
        EntityID       string
        Action         string // create, read, update, delete
}

// HasPermission checks if a permission level is sufficient
func (p PermissionLevel) HasPermission(required PermissionLevel) bool <span class="cov10" title="25">{
        return p &gt;= required
}</span>

// String returns the string representation of permission level
func (p PermissionLevel) String() string <span class="cov6" title="7">{
        switch p </span>{
        case PermissionNone:<span class="cov2" title="2">
                return "NONE"</span>
        case PermissionRead:<span class="cov1" title="1">
                return "READ"</span>
        case PermissionCreate:<span class="cov1" title="1">
                return "CREATE"</span>
        case PermissionUpdate:<span class="cov1" title="1">
                return "UPDATE"</span>
        case PermissionDelete:<span class="cov1" title="1">
                return "DELETE"</span>
        default:<span class="cov1" title="1">
                return "UNKNOWN"</span>
        }
}

// ParsePermissionLevel parses a string to PermissionLevel
func ParsePermissionLevel(level string) PermissionLevel <span class="cov7" title="12">{
        switch strings.ToUpper(level) </span>{
        case "READ":<span class="cov4" title="4">
                return PermissionRead</span>
        case "CREATE":<span class="cov1" title="1">
                return PermissionCreate</span>
        case "UPDATE":<span class="cov2" title="2">
                return PermissionUpdate</span>
        case "DELETE", "ALL":<span class="cov4" title="3">
                return PermissionDelete</span>
        default:<span class="cov2" title="2">
                return PermissionNone</span>
        }
}

// BuildContextPath builds a hierarchical context path
func BuildContextPath(contexts ...string) string <span class="cov4" title="4">{
        return strings.Join(contexts, "")
}</span>

// ParseContextPath parses a hierarchical context path
func ParseContextPath(path string) []string <span class="cov9" title="18">{
        return strings.Split(path, "")
}</span>

// IsParentContext checks if parent is a parent of child in hierarchy
func IsParentContext(parent, child string) bool <span class="cov6" title="7">{
        parentParts := ParseContextPath(parent)
        childParts := ParseContextPath(child)

        if len(parentParts) &gt;= len(childParts) </span><span class="cov4" title="3">{
                return false
        }</span>

        <span class="cov4" title="4">for i, part := range parentParts </span><span class="cov5" title="5">{
                if childParts[i] != part </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        <span class="cov4" title="3">return true</span>
}

// GetRequiredPermissionLevel returns the required permission level for an action
func GetRequiredPermissionLevel(action string) PermissionLevel <span class="cov8" title="15">{
        // Extract base action from compound actions like "priorityCreate"
        actionLower := strings.ToLower(action)

        if strings.Contains(actionLower, "create") </span><span class="cov4" title="3">{
                return PermissionCreate
        }</span>
        <span class="cov7" title="12">if strings.Contains(actionLower, "modify") || strings.Contains(actionLower, "update") || strings.Contains(actionLower, "edit") </span><span class="cov4" title="4">{
                return PermissionUpdate
        }</span>
        <span class="cov6" title="8">if strings.Contains(actionLower, "remove") || strings.Contains(actionLower, "delete") </span><span class="cov4" title="3">{
                return PermissionDelete
        }</span>
        // read, list, get, etc.
        <span class="cov5" title="5">return PermissionRead</span>
}

// HasPermission checks if the JWT claims contain a specific permission level
func (c *JWTClaims) HasPermission(required int) bool <span class="cov4" title="4">{
        if c == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Parse permissions string (e.g., "READ|CREATE|UPDATE|DELETE")
        <span class="cov4" title="4">permissionLevel := ParsePermissionLevel(c.Permissions)
        requiredLevel := PermissionLevel(required)

        return permissionLevel.HasPermission(requiredLevel)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package models

// Label represents a categorization tag that can be applied to various entities
type Label struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Color       string `json:"color,omitempty" db:"color"` // Hex color code for visual identification
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// LabelCategory represents a category for organizing labels
type LabelCategory struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// LabelLabelCategoryMapping represents the many-to-many relationship between labels and categories
type LabelLabelCategoryMapping struct {
        ID              string `json:"id" db:"id"`
        LabelID         string `json:"labelId" db:"label_id" binding:"required"`
        LabelCategoryID string `json:"labelCategoryId" db:"label_category_id" binding:"required"`
        Created         int64  `json:"created" db:"created"`
        Modified        int64  `json:"modified" db:"modified"`
        Deleted         bool   `json:"deleted" db:"deleted"`
}

// LabelTicketMapping represents the many-to-many relationship between labels and tickets
type LabelTicketMapping struct {
        ID       string `json:"id" db:"id"`
        LabelID  string `json:"labelId" db:"label_id" binding:"required"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// LabelAssetMapping represents the many-to-many relationship between labels and assets
type LabelAssetMapping struct {
        ID       string `json:"id" db:"id"`
        LabelID  string `json:"labelId" db:"label_id" binding:"required"`
        AssetID  string `json:"assetId" db:"asset_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// LabelTeamMapping represents the many-to-many relationship between labels and teams
type LabelTeamMapping struct {
        ID       string `json:"id" db:"id"`
        LabelID  string `json:"labelId" db:"label_id" binding:"required"`
        TeamID   string `json:"teamId" db:"team_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// LabelProjectMapping represents the many-to-many relationship between labels and projects
type LabelProjectMapping struct {
        ID        string `json:"id" db:"id"`
        LabelID   string `json:"labelId" db:"label_id" binding:"required"`
        ProjectID string `json:"projectId" db:"project_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// GetDisplayName returns a user-friendly display name
func (l *Label) GetDisplayName() string <span class="cov0" title="0">{
        if l.Title != "" </span><span class="cov0" title="0">{
                return l.Title
        }</span>
        <span class="cov0" title="0">return "Unknown Label"</span>
}

// IsValid checks if the label has required fields
func (l *Label) IsValid() bool <span class="cov0" title="0">{
        return l.Title != ""
}</span>

// GetDisplayName returns a user-friendly display name for the category
func (lc *LabelCategory) GetDisplayName() string <span class="cov0" title="0">{
        if lc.Title != "" </span><span class="cov0" title="0">{
                return lc.Title
        }</span>
        <span class="cov0" title="0">return "Unknown Category"</span>
}

// IsValid checks if the label category has required fields
func (lc *LabelCategory) IsValid() bool <span class="cov0" title="0">{
        return lc.Title != ""
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package models

// Mention represents a user mention in a comment
type Mention struct {
        ID              string `json:"id" db:"id"`
        CommentID       string `json:"commentId" db:"comment_id" binding:"required"`
        MentionedUserID string `json:"mentionedUserId" db:"mentioned_user_id" binding:"required"`
        Created         int64  `json:"created" db:"created"`
        Deleted         bool   `json:"deleted" db:"deleted"`
}

// MentionSummary provides a summary of mentions for a user or comment
type MentionSummary struct {
        CommentID       string   `json:"commentId,omitempty"`
        UserID          string   `json:"userId,omitempty"`
        MentionCount    int      `json:"mentionCount"`
        MentionedUserIDs []string `json:"mentionedUserIds,omitempty"`
}

// IsValid checks if the mention has valid data
func (m *Mention) IsValid() bool <span class="cov0" title="0">{
        return m.CommentID != "" &amp;&amp; m.MentionedUserID != ""
}</span>

// HasMentions checks if there are any mentions
func (ms *MentionSummary) HasMentions() bool <span class="cov0" title="0">{
        return ms.MentionCount &gt; 0
}</span>

// ContainsUser checks if a specific user is mentioned
func (ms *MentionSummary) ContainsUser(userID string) bool <span class="cov0" title="0">{
        for _, id := range ms.MentionedUserIDs </span><span class="cov0" title="0">{
                if id == userID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package models

// NotificationScheme represents a notification scheme for a project
type NotificationScheme struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title" binding:"required"`
        Description string  `json:"description,omitempty" db:"description"`
        ProjectID   *string `json:"projectId,omitempty" db:"project_id"` // NULL for global schemes
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// NotificationEvent represents a type of event that can trigger notifications
type NotificationEvent struct {
        ID          string `json:"id" db:"id"`
        EventType   string `json:"eventType" db:"event_type" binding:"required"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// NotificationRule represents a rule for sending notifications
type NotificationRule struct {
        ID                   string  `json:"id" db:"id"`
        NotificationSchemeID string  `json:"notificationSchemeId" db:"notification_scheme_id" binding:"required"`
        NotificationEventID  string  `json:"notificationEventId" db:"notification_event_id" binding:"required"`
        RecipientType        string  `json:"recipientType" db:"recipient_type" binding:"required"` // assignee, reporter, watcher, user, team, project_role
        RecipientID          *string `json:"recipientId,omitempty" db:"recipient_id"`              // user_id, team_id, or role_id (NULL for assignee/reporter/watcher)
        Created              int64   `json:"created" db:"created"`
        Deleted              bool    `json:"deleted" db:"deleted"`
}

// Notification event type constants (must match database seed data)
const (
        NotificationEventIssueCreated    = "issue_created"
        NotificationEventIssueUpdated    = "issue_updated"
        NotificationEventIssueDeleted    = "issue_deleted"
        NotificationEventCommentAdded    = "comment_added"
        NotificationEventCommentUpdated  = "comment_updated"
        NotificationEventCommentDeleted  = "comment_deleted"
        NotificationEventStatusChanged   = "status_changed"
        NotificationEventAssigneeChanged = "assignee_changed"
        NotificationEventPriorityChanged = "priority_changed"
        NotificationEventWorkLogged      = "work_logged"
        NotificationEventUserMentioned   = "user_mentioned"
)

// Recipient type constants
const (
        RecipientTypeAssignee    = "assignee"
        RecipientTypeReporter    = "reporter"
        RecipientTypeWatcher     = "watcher"
        RecipientTypeUser        = "user"
        RecipientTypeTeam        = "team"
        RecipientTypeProjectRole = "project_role"
)

// IsGlobal checks if the scheme is global (not project-specific)
func (ns *NotificationScheme) IsGlobal() bool <span class="cov0" title="0">{
        return ns.ProjectID == nil || *ns.ProjectID == ""
}</span>

// IsProjectSpecific checks if the scheme is project-specific
func (ns *NotificationScheme) IsProjectSpecific() bool <span class="cov0" title="0">{
        return !ns.IsGlobal()
}</span>

// IsValidEventType checks if the event type is valid
func (ne *NotificationEvent) IsValidEventType() bool <span class="cov0" title="0">{
        validEvents := map[string]bool{
                NotificationEventIssueCreated:    true,
                NotificationEventIssueUpdated:    true,
                NotificationEventIssueDeleted:    true,
                NotificationEventCommentAdded:    true,
                NotificationEventCommentUpdated:  true,
                NotificationEventCommentDeleted:  true,
                NotificationEventStatusChanged:   true,
                NotificationEventAssigneeChanged: true,
                NotificationEventPriorityChanged: true,
                NotificationEventWorkLogged:      true,
                NotificationEventUserMentioned:   true,
        }
        return validEvents[ne.EventType]
}</span>

// IsValidRecipientType checks if the recipient type is valid
func (nr *NotificationRule) IsValidRecipientType() bool <span class="cov0" title="0">{
        validRecipients := map[string]bool{
                RecipientTypeAssignee:    true,
                RecipientTypeReporter:    true,
                RecipientTypeWatcher:     true,
                RecipientTypeUser:        true,
                RecipientTypeTeam:        true,
                RecipientTypeProjectRole: true,
        }
        return validRecipients[nr.RecipientType]
}</span>

// RequiresRecipientID checks if the recipient type requires a recipient ID
func (nr *NotificationRule) RequiresRecipientID() bool <span class="cov0" title="0">{
        return nr.RecipientType == RecipientTypeUser ||
                nr.RecipientType == RecipientTypeTeam ||
                nr.RecipientType == RecipientTypeProjectRole
}</span>

// IsRoleBasedRecipient checks if the recipient is role-based (assignee, reporter, watcher)
func (nr *NotificationRule) IsRoleBasedRecipient() bool <span class="cov0" title="0">{
        return nr.RecipientType == RecipientTypeAssignee ||
                nr.RecipientType == RecipientTypeReporter ||
                nr.RecipientType == RecipientTypeWatcher
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package models

// PermissionEntity represents a permission type in the system (database model)
type PermissionEntity struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Value       int    `json:"value" db:"value" binding:"required"` // 1=READ, 2=CREATE, 3=UPDATE, 5=DELETE
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// PermissionContextEntity represents a context in which permissions can be applied (database model)
// Contexts form a hierarchy: node  account  organization  team/project
type PermissionContextEntity struct {
        ID       string `json:"id" db:"id"`
        Context  string `json:"context" db:"context" binding:"required"` // node, account, organization, team, project
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// PermissionUserMapping maps permissions to users within a specific context
type PermissionUserMapping struct {
        ID                  string `json:"id" db:"id"`
        PermissionID        string `json:"permissionId" db:"permission_id" binding:"required"`
        UserID              string `json:"userId" db:"user_id" binding:"required"`
        PermissionContextID string `json:"permissionContextId" db:"permission_context_id" binding:"required"`
        Created             int64  `json:"created" db:"created"`
        Deleted             bool   `json:"deleted" db:"deleted"`
}

// PermissionTeamMapping maps permissions to teams within a specific context
type PermissionTeamMapping struct {
        ID                  string `json:"id" db:"id"`
        PermissionID        string `json:"permissionId" db:"permission_id" binding:"required"`
        TeamID              string `json:"teamId" db:"team_id" binding:"required"`
        PermissionContextID string `json:"permissionContextId" db:"permission_context_id" binding:"required"`
        Created             int64  `json:"created" db:"created"`
        Deleted             bool   `json:"deleted" db:"deleted"`
}

// IsValidPermissionValue validates if the permission value is one of the allowed values
func (p *PermissionEntity) IsValidPermissionValue() bool <span class="cov0" title="0">{
        return p.Value == int(PermissionRead) || p.Value == int(PermissionCreate) ||
                p.Value == int(PermissionUpdate) || p.Value == int(PermissionDelete)
}</span>

// IsValidContext validates if the context is one of the allowed contexts
func (pc *PermissionContextEntity) IsValidContext() bool <span class="cov0" title="0">{
        validContexts := []string{"node", "account", "organization", "team", "project"}
        for _, ctx := range validContexts </span><span class="cov0" title="0">{
                if pc.Context == ctx </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package models

// Priority represents a ticket priority level (Lowest, Low, Medium, High, Highest)
type Priority struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Level       int    `json:"level" db:"level" binding:"required"` // 1 (Lowest) to 5 (Highest)
        Icon        string `json:"icon,omitempty" db:"icon"`
        Color       string `json:"color,omitempty" db:"color"` // Hex color code
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// Priority level constants
const (
        PriorityLevelLowest  = 1
        PriorityLevelLow     = 2
        PriorityLevelMedium  = 3
        PriorityLevelHigh    = 4
        PriorityLevelHighest = 5
)

// Default priority IDs
const (
        PriorityIDLowest  = "priority-lowest"
        PriorityIDLow     = "priority-low"
        PriorityIDMedium  = "priority-medium"
        PriorityIDHigh    = "priority-high"
        PriorityIDHighest = "priority-highest"
)

// IsValidLevel checks if the priority level is valid (1-5)
func (p *Priority) IsValidLevel() bool <span class="cov10" title="14">{
        return p.Level &gt;= PriorityLevelLowest &amp;&amp; p.Level &lt;= PriorityLevelHighest
}</span>

// GetDisplayName returns a user-friendly display name
func (p *Priority) GetDisplayName() string <span class="cov8" title="8">{
        if p.Title != "" </span><span class="cov7" title="7">{
                return p.Title
        }</span>
        <span class="cov1" title="1">return "Unknown Priority"</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package models

import "time"

// Project represents a project in the system
type Project struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title"`
        Description string `json:"description" db:"description"`
        Identifier  string `json:"identifier" db:"identifier"` // Short project key like "PROJ"
        WorkflowID  string `json:"workflowId" db:"workflow_id"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
        Version     int    `json:"version" db:"version"` // Optimistic locking version
}

// NewProject creates a new project with current timestamps
func NewProject(id, title, description, identifier, workflowID string) *Project <span class="cov0" title="0">{
        now := time.Now().Unix()
        return &amp;Project{
                ID:          id,
                Title:       title,
                Description: description,
                Identifier:  identifier,
                WorkflowID:  workflowID,
                Created:     now,
                Modified:    now,
                Deleted:     false,
                Version:     1,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package models

// ProjectCategory represents a category for organizing projects
type ProjectCategory struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// Common project category constants
const (
        CategorySoftware     = "Software Development"
        CategoryInfrastructure = "Infrastructure"
        CategoryMarketing    = "Marketing"
        CategorySales        = "Sales"
        CategorySupport      = "Customer Support"
        CategoryResearch     = "Research &amp; Development"
        CategoryInternal     = "Internal"
        CategoryExternal     = "External"
)

// IsValid checks if the category has valid data
func (pc *ProjectCategory) IsValid() bool <span class="cov0" title="0">{
        return pc.Title != ""
}</span>

// GetDisplayName returns a user-friendly display name
func (pc *ProjectCategory) GetDisplayName() string <span class="cov0" title="0">{
        if pc.Title != "" </span><span class="cov0" title="0">{
                return pc.Title
        }</span>
        <span class="cov0" title="0">return "Uncategorized"</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package models

// ProjectRole represents a role that can be assigned to users in a project
type ProjectRole struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title" binding:"required"`
        Description string  `json:"description,omitempty" db:"description"`
        ProjectID   *string `json:"projectId,omitempty" db:"project_id"` // NULL for global roles
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// ProjectRoleUserMapping represents the assignment of a role to a user in a project
type ProjectRoleUserMapping struct {
        ID            string `json:"id" db:"id"`
        ProjectRoleID string `json:"projectRoleId" db:"project_role_id" binding:"required"`
        ProjectID     string `json:"projectId" db:"project_id" binding:"required"`
        UserID        string `json:"userId" db:"user_id" binding:"required"`
        Created       int64  `json:"created" db:"created"`
        Deleted       bool   `json:"deleted" db:"deleted"`
}

// IsGlobal checks if the role is global (not project-specific)
func (pr *ProjectRole) IsGlobal() bool <span class="cov0" title="0">{
        return pr.ProjectID == nil || *pr.ProjectID == ""
}</span>

// IsProjectSpecific checks if the role is project-specific
func (pr *ProjectRole) IsProjectSpecific() bool <span class="cov0" title="0">{
        return !pr.IsGlobal()
}</span>

// Common project role titles (constants for default roles)
const (
        ProjectRoleAdmin      = "Project Administrator"
        ProjectRoleLead       = "Project Lead"
        ProjectRoleDeveloper  = "Developer"
        ProjectRoleTester     = "Tester"
        ProjectRoleViewer     = "Viewer"
        ProjectRoleContributor = "Contributor"
)
</pre>
		
		<pre class="file" id="file45" style="display: none">package models

// Report represents a saved report definition
type Report struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Query       string `json:"query" db:"query"`              // JSON query definition
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// ReportMetaData represents additional metadata for reports
type ReportMetaData struct {
        ID       string `json:"id" db:"id"`
        ReportID string `json:"reportId" db:"report_id" binding:"required"`
        Property string `json:"property" db:"property" binding:"required"`
        Value    string `json:"value" db:"value"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// IsValid validates if the report has required fields
func (r *Report) IsValid() bool <span class="cov0" title="0">{
        return r.Title != ""
}</span>

// HasQuery checks if the report has a query definition
func (r *Report) HasQuery() bool <span class="cov0" title="0">{
        return r.Query != ""
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package models

// Request represents the unified API request format for the /do endpoint
type Request struct {
        Action string                 `json:"action" binding:"required"` // authenticate, version, jwtCapable, dbCapable, health, create, modify, remove
        JWT    string                 `json:"jwt"`                       // Required for authenticated actions
        Locale string                 `json:"locale"`                    // Optional locale for localized responses
        Object string                 `json:"object"`                    // Required for CRUD operations (create, modify, remove)
        Data   map[string]interface{} `json:"data"`                      // Additional data for the action
}

// IsAuthenticationRequired returns true if the action requires JWT authentication
func (r *Request) IsAuthenticationRequired() bool <span class="cov10" title="11">{
        switch r.Action </span>{
        case ActionVersion, ActionJWTCapable, ActionDBCapable, ActionHealth, ActionAuthenticate:<span class="cov7" title="5">
                return false</span>
        default:<span class="cov7" title="6">
                return true</span>
        }
}

// IsCRUDOperation returns true if the action is a CRUD operation requiring an object
func (r *Request) IsCRUDOperation() bool <span class="cov8" title="7">{
        switch r.Action </span>{
        case ActionCreate, ActionModify, ActionRemove:<span class="cov5" title="3">
                return true</span>
        default:<span class="cov6" title="4">
                return false</span>
        }
}

// Action constants
const (
        // System actions
        ActionAuthenticate = "authenticate"
        ActionVersion      = "version"
        ActionJWTCapable   = "jwtCapable"
        ActionDBCapable    = "dbCapable"
        ActionHealth       = "health"

        // Generic CRUD actions
        ActionCreate = "create"
        ActionModify = "modify"
        ActionRemove = "remove"
        ActionRead   = "read"
        ActionList   = "list"

        // Priority actions
        ActionPriorityCreate = "priorityCreate"
        ActionPriorityRead   = "priorityRead"
        ActionPriorityList   = "priorityList"
        ActionPriorityModify = "priorityModify"
        ActionPriorityRemove = "priorityRemove"

        // Resolution actions
        ActionResolutionCreate = "resolutionCreate"
        ActionResolutionRead   = "resolutionRead"
        ActionResolutionList   = "resolutionList"
        ActionResolutionModify = "resolutionModify"
        ActionResolutionRemove = "resolutionRemove"

        // Version actions
        ActionVersionCreate  = "versionCreate"
        ActionVersionRead    = "versionRead"
        ActionVersionList    = "versionList"
        ActionVersionModify  = "versionModify"
        ActionVersionRemove  = "versionRemove"
        ActionVersionRelease = "versionRelease" // Mark version as released
        ActionVersionArchive = "versionArchive" // Archive a version

        // Version mapping actions
        ActionVersionAddAffected    = "versionAddAffected"    // Add affected version to ticket
        ActionVersionRemoveAffected = "versionRemoveAffected" // Remove affected version from ticket
        ActionVersionListAffected   = "versionListAffected"   // List affected versions for ticket
        ActionVersionAddFix         = "versionAddFix"         // Add fix version to ticket
        ActionVersionRemoveFix      = "versionRemoveFix"      // Remove fix version from ticket
        ActionVersionListFix        = "versionListFix"        // List fix versions for ticket

        // Watcher actions
        ActionWatcherAdd    = "watcherAdd"    // Start watching a ticket
        ActionWatcherRemove = "watcherRemove" // Stop watching a ticket
        ActionWatcherList   = "watcherList"   // List watchers for a ticket

        // Filter actions
        ActionFilterSave   = "filterSave"   // Create or update a saved filter
        ActionFilterLoad   = "filterLoad"   // Load a saved filter
        ActionFilterList   = "filterList"   // List user's filters
        ActionFilterShare  = "filterShare"  // Share a filter
        ActionFilterModify = "filterModify" // Modify a filter
        ActionFilterRemove = "filterRemove" // Delete a filter

        // Custom field actions
        ActionCustomFieldCreate = "customFieldCreate"
        ActionCustomFieldRead   = "customFieldRead"
        ActionCustomFieldList   = "customFieldList"
        ActionCustomFieldModify = "customFieldModify"
        ActionCustomFieldRemove = "customFieldRemove"

        // Custom field option actions
        ActionCustomFieldOptionCreate = "customFieldOptionCreate"
        ActionCustomFieldOptionModify = "customFieldOptionModify"
        ActionCustomFieldOptionRemove = "customFieldOptionRemove"
        ActionCustomFieldOptionList   = "customFieldOptionList"

        // Custom field value actions (for tickets)
        ActionCustomFieldValueSet    = "customFieldValueSet"    // Set custom field value for a ticket
        ActionCustomFieldValueGet    = "customFieldValueGet"    // Get custom field value for a ticket
        ActionCustomFieldValueList   = "customFieldValueList"   // List all custom field values for a ticket
        ActionCustomFieldValueRemove = "customFieldValueRemove" // Remove custom field value from a ticket

        // Workflow actions
        ActionWorkflowCreate = "workflowCreate"
        ActionWorkflowRead   = "workflowRead"
        ActionWorkflowList   = "workflowList"
        ActionWorkflowModify = "workflowModify"
        ActionWorkflowRemove = "workflowRemove"

        // Workflow step actions
        ActionWorkflowStepCreate = "workflowStepCreate"
        ActionWorkflowStepRead   = "workflowStepRead"
        ActionWorkflowStepList   = "workflowStepList"
        ActionWorkflowStepModify = "workflowStepModify"
        ActionWorkflowStepRemove = "workflowStepRemove"

        // Ticket status actions
        ActionTicketStatusCreate = "ticketStatusCreate"
        ActionTicketStatusRead   = "ticketStatusRead"
        ActionTicketStatusList   = "ticketStatusList"
        ActionTicketStatusModify = "ticketStatusModify"
        ActionTicketStatusRemove = "ticketStatusRemove"

        // Ticket type actions
        ActionTicketTypeCreate        = "ticketTypeCreate"
        ActionTicketTypeRead          = "ticketTypeRead"
        ActionTicketTypeList          = "ticketTypeList"
        ActionTicketTypeModify        = "ticketTypeModify"
        ActionTicketTypeRemove        = "ticketTypeRemove"
        ActionTicketTypeAssign        = "ticketTypeAssign"        // Assign type to project
        ActionTicketTypeUnassign      = "ticketTypeUnassign"      // Unassign type from project
        ActionTicketTypeListByProject = "ticketTypeListByProject" // List types assigned to a project

        // Board actions
        ActionBoardCreate = "boardCreate"
        ActionBoardRead   = "boardRead"
        ActionBoardList   = "boardList"
        ActionBoardModify = "boardModify"
        ActionBoardRemove = "boardRemove"

        // Board ticket assignment
        ActionBoardAddTicket    = "boardAddTicket"
        ActionBoardRemoveTicket = "boardRemoveTicket"
        ActionBoardListTickets  = "boardListTickets"

        // Board metadata
        ActionBoardSetMetadata    = "boardSetMetadata"
        ActionBoardGetMetadata    = "boardGetMetadata"
        ActionBoardListMetadata   = "boardListMetadata"
        ActionBoardRemoveMetadata = "boardRemoveMetadata"

        // Cycle actions (Sprint/Milestone/Release management)
        ActionCycleCreate = "cycleCreate"
        ActionCycleRead   = "cycleRead"
        ActionCycleList   = "cycleList"
        ActionCycleModify = "cycleModify"
        ActionCycleRemove = "cycleRemove"

        // Cycle-project mapping
        ActionCycleAssignProject   = "cycleAssignProject"   // Assign cycle to project
        ActionCycleUnassignProject = "cycleUnassignProject" // Unassign cycle from project
        ActionCycleListProjects    = "cycleListProjects"    // List projects assigned to cycle

        // Cycle-ticket mapping
        ActionCycleAddTicket    = "cycleAddTicket"    // Add ticket to cycle
        ActionCycleRemoveTicket = "cycleRemoveTicket" // Remove ticket from cycle
        ActionCycleListTickets  = "cycleListTickets"  // List tickets in cycle

        // Account actions (Multi-tenancy support)
        ActionAccountCreate = "accountCreate"
        ActionAccountRead   = "accountRead"
        ActionAccountList   = "accountList"
        ActionAccountModify = "accountModify"
        ActionAccountRemove = "accountRemove"

        // Organization actions
        ActionOrganizationCreate        = "organizationCreate"
        ActionOrganizationRead          = "organizationRead"
        ActionOrganizationList          = "organizationList"
        ActionOrganizationModify        = "organizationModify"
        ActionOrganizationRemove        = "organizationRemove"
        ActionOrganizationAssignAccount = "organizationAssignAccount" // Assign organization to account
        ActionOrganizationListAccounts  = "organizationListAccounts"  // List accounts for organization

        // Team actions
        ActionTeamCreate              = "teamCreate"
        ActionTeamRead                = "teamRead"
        ActionTeamList                = "teamList"
        ActionTeamModify              = "teamModify"
        ActionTeamRemove              = "teamRemove"
        ActionTeamAssignOrganization  = "teamAssignOrganization"  // Assign team to organization
        ActionTeamUnassignOrganization = "teamUnassignOrganization" // Unassign team from organization
        ActionTeamListOrganizations   = "teamListOrganizations"   // List organizations for team
        ActionTeamAssignProject       = "teamAssignProject"       // Assign team to project
        ActionTeamUnassignProject     = "teamUnassignProject"     // Unassign team from project
        ActionTeamListProjects        = "teamListProjects"        // List projects for team

        // User-Organization mapping
        ActionUserAssignOrganization = "userAssignOrganization" // Assign user to organization
        ActionUserListOrganizations  = "userListOrganizations"  // List organizations for user
        ActionOrganizationListUsers  = "organizationListUsers"  // List users in organization

        // User-Team mapping
        ActionUserAssignTeam = "userAssignTeam" // Assign user to team
        ActionUserListTeams  = "userListTeams"  // List teams for user
        ActionTeamListUsers  = "teamListUsers"  // List users in team

        // Component actions
        ActionComponentCreate = "componentCreate"
        ActionComponentRead   = "componentRead"
        ActionComponentList   = "componentList"
        ActionComponentModify = "componentModify"
        ActionComponentRemove = "componentRemove"

        // Component-ticket mapping
        ActionComponentAddTicket    = "componentAddTicket"    // Add component to ticket
        ActionComponentRemoveTicket = "componentRemoveTicket" // Remove component from ticket
        ActionComponentListTickets  = "componentListTickets"  // List tickets for component

        // Component metadata
        ActionComponentSetMetadata    = "componentSetMetadata"    // Set component metadata
        ActionComponentGetMetadata    = "componentGetMetadata"    // Get component metadata
        ActionComponentListMetadata   = "componentListMetadata"   // List all metadata for component
        ActionComponentRemoveMetadata = "componentRemoveMetadata" // Remove component metadata

        // Label actions
        ActionLabelCreate = "labelCreate"
        ActionLabelRead   = "labelRead"
        ActionLabelList   = "labelList"
        ActionLabelModify = "labelModify"
        ActionLabelRemove = "labelRemove"

        // Label category actions
        ActionLabelCategoryCreate = "labelCategoryCreate"
        ActionLabelCategoryRead   = "labelCategoryRead"
        ActionLabelCategoryList   = "labelCategoryList"
        ActionLabelCategoryModify = "labelCategoryModify"
        ActionLabelCategoryRemove = "labelCategoryRemove"

        // Label-ticket mapping
        ActionLabelAddTicket    = "labelAddTicket"    // Add label to ticket
        ActionLabelRemoveTicket = "labelRemoveTicket" // Remove label from ticket
        ActionLabelListTickets  = "labelListTickets"  // List tickets for label

        // Label-category mapping
        ActionLabelAssignCategory   = "labelAssignCategory"   // Assign label to category
        ActionLabelUnassignCategory = "labelUnassignCategory" // Unassign label from category
        ActionLabelListCategories   = "labelListCategories"   // List categories for label

        // Asset actions
        ActionAssetCreate = "assetCreate"
        ActionAssetRead   = "assetRead"
        ActionAssetList   = "assetList"
        ActionAssetModify = "assetModify"
        ActionAssetRemove = "assetRemove"

        // Asset-ticket mapping
        ActionAssetAddTicket    = "assetAddTicket"    // Add asset to ticket
        ActionAssetRemoveTicket = "assetRemoveTicket" // Remove asset from ticket
        ActionAssetListTickets  = "assetListTickets"  // List tickets for asset

        // Asset-comment mapping
        ActionAssetAddComment    = "assetAddComment"    // Add asset to comment
        ActionAssetRemoveComment = "assetRemoveComment" // Remove asset from comment
        ActionAssetListComments  = "assetListComments"  // List comments for asset

        // Asset-project mapping
        ActionAssetAddProject    = "assetAddProject"    // Add asset to project
        ActionAssetRemoveProject = "assetRemoveProject" // Remove asset from project
        ActionAssetListProjects  = "assetListProjects"  // List projects for asset

        // Permission actions
        ActionPermissionCreate = "permissionCreate"
        ActionPermissionRead   = "permissionRead"
        ActionPermissionList   = "permissionList"
        ActionPermissionModify = "permissionModify"
        ActionPermissionRemove = "permissionRemove"

        // Permission context actions
        ActionPermissionContextCreate = "permissionContextCreate"
        ActionPermissionContextRead   = "permissionContextRead"
        ActionPermissionContextList   = "permissionContextList"
        ActionPermissionContextModify = "permissionContextModify"
        ActionPermissionContextRemove = "permissionContextRemove"

        // Permission-user mapping actions
        ActionPermissionAssignUser   = "permissionAssignUser"   // Assign permission to user
        ActionPermissionUnassignUser = "permissionUnassignUser" // Unassign permission from user

        // Permission-team mapping actions
        ActionPermissionAssignTeam   = "permissionAssignTeam"   // Assign permission to team
        ActionPermissionUnassignTeam = "permissionUnassignTeam" // Unassign permission from team

        // Permission query action
        ActionPermissionCheck = "permissionCheck" // Check if user has permission

        // Audit actions
        ActionAuditCreate  = "auditCreate"  // Create audit entry
        ActionAuditRead    = "auditRead"    // Read audit entry
        ActionAuditList    = "auditList"    // List audit entries
        ActionAuditQuery   = "auditQuery"   // Query audit entries with filters
        ActionAuditAddMeta = "auditAddMeta" // Add metadata to audit entry

        // Report actions
        ActionReportCreate  = "reportCreate"  // Create report
        ActionReportRead    = "reportRead"    // Read report
        ActionReportList    = "reportList"    // List reports
        ActionReportModify  = "reportModify"  // Modify report
        ActionReportRemove  = "reportRemove"  // Remove report
        ActionReportExecute = "reportExecute" // Execute/run report

        // Report metadata actions
        ActionReportSetMetadata    = "reportSetMetadata"    // Set report metadata
        ActionReportGetMetadata    = "reportGetMetadata"    // Get report metadata
        ActionReportRemoveMetadata = "reportRemoveMetadata" // Remove report metadata

        // Extension actions
        ActionExtensionCreate  = "extensionCreate"  // Create/register extension
        ActionExtensionRead    = "extensionRead"    // Read extension
        ActionExtensionList    = "extensionList"    // List extensions
        ActionExtensionModify  = "extensionModify"  // Modify extension
        ActionExtensionRemove  = "extensionRemove"  // Remove extension
        ActionExtensionEnable  = "extensionEnable"  // Enable extension
        ActionExtensionDisable = "extensionDisable" // Disable extension

        // Extension metadata actions
        ActionExtensionSetMetadata = "extensionSetMetadata" // Set extension metadata

        // Repository actions
        ActionRepositoryCreate = "repositoryCreate"
        ActionRepositoryRead   = "repositoryRead"
        ActionRepositoryList   = "repositoryList"
        ActionRepositoryModify = "repositoryModify"
        ActionRepositoryRemove = "repositoryRemove"

        // Repository type actions
        ActionRepositoryTypeCreate = "repositoryTypeCreate"
        ActionRepositoryTypeRead   = "repositoryTypeRead"
        ActionRepositoryTypeList   = "repositoryTypeList"
        ActionRepositoryTypeModify = "repositoryTypeModify"
        ActionRepositoryTypeRemove = "repositoryTypeRemove"

        // Repository-project mapping
        ActionRepositoryAssignProject   = "repositoryAssignProject"   // Assign repository to project
        ActionRepositoryUnassignProject = "repositoryUnassignProject" // Unassign repository from project
        ActionRepositoryListProjects    = "repositoryListProjects"    // List projects for repository

        // Repository-commit-ticket mapping
        ActionRepositoryAddCommit    = "repositoryAddCommit"    // Add commit to ticket
        ActionRepositoryRemoveCommit = "repositoryRemoveCommit" // Remove commit from ticket
        ActionRepositoryListCommits  = "repositoryListCommits"  // List commits for ticket
        ActionRepositoryGetCommit    = "repositoryGetCommit"    // Get commit details

        // Ticket relationship type actions
        ActionTicketRelationshipTypeCreate = "ticketRelationshipTypeCreate"
        ActionTicketRelationshipTypeRead   = "ticketRelationshipTypeRead"
        ActionTicketRelationshipTypeList   = "ticketRelationshipTypeList"
        ActionTicketRelationshipTypeModify = "ticketRelationshipTypeModify"
        ActionTicketRelationshipTypeRemove = "ticketRelationshipTypeRemove"

        // Ticket relationship actions
        ActionTicketRelationshipCreate = "ticketRelationshipCreate" // Create relationship between tickets
        ActionTicketRelationshipRemove = "ticketRelationshipRemove" // Remove relationship between tickets
        ActionTicketRelationshipList   = "ticketRelationshipList"   // List relationships for a ticket

        // =======================================================================
        // PHASE 2: AGILE ENHANCEMENTS
        // =======================================================================

        // Epic actions
        ActionEpicCreate      = "epicCreate"      // Create epic ticket
        ActionEpicRead        = "epicRead"        // Read epic
        ActionEpicList        = "epicList"        // List all epics
        ActionEpicModify      = "epicModify"      // Update epic
        ActionEpicRemove      = "epicRemove"      // Delete epic
        ActionEpicAddStory    = "epicAddStory"    // Add story to epic
        ActionEpicRemoveStory = "epicRemoveStory" // Remove story from epic
        ActionEpicListStories = "epicListStories" // List stories in epic

        // Subtask actions
        ActionSubtaskCreate        = "subtaskCreate"        // Create subtask
        ActionSubtaskList          = "subtaskList"          // List subtasks
        ActionSubtaskMoveToParent  = "subtaskMoveToParent"  // Change parent
        ActionSubtaskConvertToIssue = "subtaskConvertToIssue" // Convert to regular issue
        ActionSubtaskListByParent  = "subtaskListByParent"  // List all subtasks of parent

        // Work log actions
        ActionWorkLogAdd         = "workLogAdd"         // Add work log
        ActionWorkLogModify      = "workLogModify"      // Update work log
        ActionWorkLogRemove      = "workLogRemove"      // Delete work log
        ActionWorkLogList        = "workLogList"        // List work logs
        ActionWorkLogListByTicket = "workLogListByTicket" // List work logs for ticket
        ActionWorkLogListByUser  = "workLogListByUser"  // List work logs by user
        ActionWorkLogGetTotalTime = "workLogGetTotalTime" // Get total time spent

        // Project role actions
        ActionProjectRoleCreate      = "projectRoleCreate"      // Create project role
        ActionProjectRoleRead        = "projectRoleRead"        // Read project role
        ActionProjectRoleList        = "projectRoleList"        // List project roles
        ActionProjectRoleModify      = "projectRoleModify"      // Update project role
        ActionProjectRoleRemove      = "projectRoleRemove"      // Delete project role
        ActionProjectRoleAssignUser  = "projectRoleAssignUser"  // Assign user to role
        ActionProjectRoleUnassignUser = "projectRoleUnassignUser" // Remove user from role
        ActionProjectRoleListUsers   = "projectRoleListUsers"   // List users in role

        // Security level actions
        ActionSecurityLevelCreate = "securityLevelCreate" // Create security level
        ActionSecurityLevelRead   = "securityLevelRead"   // Read security level
        ActionSecurityLevelList   = "securityLevelList"   // List security levels
        ActionSecurityLevelModify = "securityLevelModify" // Update security level
        ActionSecurityLevelRemove = "securityLevelRemove" // Delete security level
        ActionSecurityLevelGrant  = "securityLevelGrant"  // Grant access to user/team/role
        ActionSecurityLevelRevoke = "securityLevelRevoke" // Revoke access
        ActionSecurityLevelCheck  = "securityLevelCheck"  // Check if user has access

        // Dashboard actions
        ActionDashboardCreate       = "dashboardCreate"       // Create dashboard
        ActionDashboardRead         = "dashboardRead"         // Read dashboard
        ActionDashboardList         = "dashboardList"         // List dashboards
        ActionDashboardModify       = "dashboardModify"       // Update dashboard
        ActionDashboardRemove       = "dashboardRemove"       // Delete dashboard
        ActionDashboardShare        = "dashboardShare"        // Share dashboard
        ActionDashboardUnshare      = "dashboardUnshare"      // Unshare dashboard
        ActionDashboardAddWidget    = "dashboardAddWidget"    // Add widget
        ActionDashboardRemoveWidget = "dashboardRemoveWidget" // Remove widget
        ActionDashboardModifyWidget = "dashboardModifyWidget" // Update widget
        ActionDashboardListWidgets  = "dashboardListWidgets"  // List widgets
        ActionDashboardSetLayout    = "dashboardSetLayout"    // Update layout

        // Advanced board configuration actions
        ActionBoardConfigureColumns = "boardConfigureColumns" // Configure columns
        ActionBoardAddColumn        = "boardAddColumn"        // Add column
        ActionBoardRemoveColumn     = "boardRemoveColumn"     // Remove column
        ActionBoardModifyColumn     = "boardModifyColumn"     // Update column
        ActionBoardListColumns      = "boardListColumns"      // List columns
        ActionBoardAddSwimlane      = "boardAddSwimlane"      // Add swimlane
        ActionBoardRemoveSwimlane   = "boardRemoveSwimlane"   // Remove swimlane
        ActionBoardListSwimlanes    = "boardListSwimlanes"    // List swimlanes
        ActionBoardAddQuickFilter   = "boardAddQuickFilter"   // Add quick filter
        ActionBoardRemoveQuickFilter = "boardRemoveQuickFilter" // Remove quick filter
        ActionBoardListQuickFilters = "boardListQuickFilters" // List quick filters
        ActionBoardSetType          = "boardSetType"          // Set board type (scrum/kanban)

        // =======================================================================
        // PHASE 3: COLLABORATION FEATURES
        // =======================================================================

        // Vote actions
        ActionVoteAdd    = "voteAdd"    // Add vote
        ActionVoteRemove = "voteRemove" // Remove vote
        ActionVoteCount  = "voteCount"  // Get vote count
        ActionVoteList   = "voteList"   // List voters
        ActionVoteCheck  = "voteCheck"  // Check if user voted

        // Project category actions
        ActionProjectCategoryCreate = "projectCategoryCreate" // Create category
        ActionProjectCategoryRead   = "projectCategoryRead"   // Read category
        ActionProjectCategoryList   = "projectCategoryList"   // List categories
        ActionProjectCategoryModify = "projectCategoryModify" // Update category
        ActionProjectCategoryRemove = "projectCategoryRemove" // Delete category
        ActionProjectCategoryAssign = "projectCategoryAssign" // Assign to project

        // Notification scheme actions
        ActionNotificationSchemeCreate     = "notificationSchemeCreate"     // Create scheme
        ActionNotificationSchemeRead       = "notificationSchemeRead"       // Read scheme
        ActionNotificationSchemeList       = "notificationSchemeList"       // List schemes
        ActionNotificationSchemeModify     = "notificationSchemeModify"     // Update scheme
        ActionNotificationSchemeRemove     = "notificationSchemeRemove"     // Delete scheme
        ActionNotificationSchemeAddRule    = "notificationSchemeAddRule"    // Add rule
        ActionNotificationSchemeRemoveRule = "notificationSchemeRemoveRule" // Remove rule
        ActionNotificationSchemeListRules  = "notificationSchemeListRules"  // List rules
        ActionNotificationEventList        = "notificationEventList"        // List event types
        ActionNotificationSend             = "notificationSend"             // Send notification (manual trigger)

        // Activity stream actions (enhancements to audit)
        ActionActivityStreamGet          = "activityStreamGet"          // Get activity stream
        ActionActivityStreamGetByProject = "activityStreamGetByProject" // Get project activity
        ActionActivityStreamGetByUser    = "activityStreamGetByUser"    // Get user activity
        ActionActivityStreamGetByTicket  = "activityStreamGetByTicket"  // Get ticket activity
        ActionActivityStreamFilter       = "activityStreamFilter"       // Filter by activity type

        // Comment mention actions
        ActionCommentMention       = "commentMention"       // Add mention to comment
        ActionCommentUnmention     = "commentUnmention"     // Remove mention
        ActionCommentListMentions  = "commentListMentions"  // List mentioned users
        ActionCommentGetMentions   = "commentGetMentions"   // Get mentions for user
        ActionCommentParseMentions = "commentParseMentions" // Parse @mentions from text

        // =======================================================================
        // CHAT EXTENSION: REAL-TIME MESSAGING
        // =======================================================================

        // User presence actions
        ActionPresenceUpdate      = "presenceUpdate"      // Update user presence status
        ActionPresenceGet         = "presenceGet"         // Get user presence
        ActionPresenceList        = "presenceList"        // List presence for multiple users
        ActionPresenceGetByStatus = "presenceGetByStatus" // Get users by presence status

        // Chat room management actions
        ActionChatRoomCreate        = "chatRoomCreate"        // Create chat room
        ActionChatRoomRead          = "chatRoomRead"          // Get chat room details
        ActionChatRoomList          = "chatRoomList"          // List accessible chat rooms
        ActionChatRoomModify        = "chatRoomModify"        // Modify chat room
        ActionChatRoomRemove        = "chatRoomRemove"        // Delete chat room
        ActionChatRoomArchive       = "chatRoomArchive"       // Archive chat room
        ActionChatRoomUnarchive     = "chatRoomUnarchive"     // Unarchive chat room
        ActionChatRoomGetByEntity   = "chatRoomGetByEntity"   // Get chat room for entity (project, ticket, etc.)
        ActionChatRoomListByType    = "chatRoomListByType"    // List rooms by type
        ActionChatRoomSearch        = "chatRoomSearch"        // Search chat rooms

        // Chat participant actions
        ActionChatParticipantAdd       = "chatParticipantAdd"       // Add participant to room
        ActionChatParticipantRemove    = "chatParticipantRemove"    // Remove participant from room
        ActionChatParticipantList      = "chatParticipantList"      // List participants in room
        ActionChatParticipantSetRole   = "chatParticipantSetRole"   // Change participant role
        ActionChatParticipantMute      = "chatParticipantMute"      // Mute chat room for user
        ActionChatParticipantUnmute    = "chatParticipantUnmute"    // Unmute chat room for user
        ActionChatParticipantLeave     = "chatParticipantLeave"     // Leave chat room
        ActionChatParticipantGetRooms  = "chatParticipantGetRooms"  // Get all rooms for user

        // Message management actions
        ActionMessageCreate       = "messageCreate"       // Send message
        ActionMessageRead         = "messageRead"         // Get message details
        ActionMessageList         = "messageList"         // List messages in room
        ActionMessageModify       = "messageModify"       // Edit message
        ActionMessageRemove       = "messageRemove"       // Delete message
        ActionMessagePin          = "messagePin"          // Pin message
        ActionMessageUnpin        = "messageUnpin"        // Unpin message
        ActionMessageGetPinned    = "messageGetPinned"    // Get pinned messages
        ActionMessageReply        = "messageReply"        // Reply to message (threading)
        ActionMessageQuote        = "messageQuote"        // Quote message
        ActionMessageGetThread    = "messageGetThread"    // Get message thread (replies)
        ActionMessageSearch       = "messageSearch"       // Full-text search messages
        ActionMessageGetRecent    = "messageGetRecent"    // Get recent messages
        ActionMessageMarkAsRead   = "messageMarkAsRead"   // Mark message as read
        ActionMessageGetUnread    = "messageGetUnread"    // Get unread messages count

        // Typing indicator actions
        ActionTypingStart  = "typingStart"  // User starts typing
        ActionTypingStop   = "typingStop"   // User stops typing
        ActionTypingGetAll = "typingGetAll" // Get all typing users in room

        // Read receipt actions
        ActionReadReceiptCreate = "readReceiptCreate" // Create read receipt
        ActionReadReceiptList   = "readReceiptList"   // List read receipts for message
        ActionReadReceiptGet    = "readReceiptGet"    // Get read status for user

        // Message attachment actions
        ActionAttachmentUpload = "attachmentUpload" // Upload file attachment
        ActionAttachmentList   = "attachmentList"   // List attachments for message
        ActionAttachmentRemove = "attachmentRemove" // Remove attachment
        ActionAttachmentGet    = "attachmentGet"    // Get attachment details

        // Message reaction actions
        ActionReactionAdd    = "reactionAdd"    // Add emoji reaction
        ActionReactionRemove = "reactionRemove" // Remove emoji reaction
        ActionReactionList   = "reactionList"   // List reactions for message
        ActionReactionGet    = "reactionGet"    // Get reactions grouped by emoji

        // External chat integration actions
        ActionChatIntegrationCreate = "chatIntegrationCreate" // Create external integration
        ActionChatIntegrationRead   = "chatIntegrationRead"   // Get integration details
        ActionChatIntegrationList   = "chatIntegrationList"   // List integrations for room
        ActionChatIntegrationModify = "chatIntegrationModify" // Modify integration
        ActionChatIntegrationRemove = "chatIntegrationRemove" // Remove integration
        ActionChatIntegrationSync   = "chatIntegrationSync"   // Sync with external provider

        // ========================================================================
        // DOCUMENTS EXTENSION V2 ACTIONS (90 actions)
        // Requires: Documents Extension V2 + Core V5
        // ========================================================================

        // Core document actions (22)
        ActionDocumentCreate          = "documentCreate"          // Create new document
        ActionDocumentRead            = "documentRead"            // Get document by ID
        ActionDocumentList            = "documentList"            // List documents (filtered)
        ActionDocumentModify          = "documentModify"          // Update document
        ActionDocumentUpdate          = "documentModify"          // Alias for Modify (backwards compatibility)
        ActionDocumentRemove          = "documentRemove"          // Delete document (soft)
        ActionDocumentDelete          = "documentRemove"          // Alias for Remove (backwards compatibility)
        ActionDocumentRestore         = "documentRestore"         // Restore deleted document
        ActionDocumentArchive         = "documentArchive"         // Archive document
        ActionDocumentUnarchive       = "documentUnarchive"       // Unarchive document
        ActionDocumentDuplicate       = "documentDuplicate"       // Duplicate document
        ActionDocumentMove            = "documentMove"            // Move to different space
        ActionDocumentGetHierarchy    = "documentGetHierarchy"    // Get document tree
        ActionDocumentSearch          = "documentSearch"          // Full-text search
        ActionDocumentGetRelated      = "documentGetRelated"      // Get related documents
        ActionDocumentSetParent       = "documentSetParent"       // Set parent document
        ActionDocumentGetChildren     = "documentGetChildren"     // Get child documents
        ActionDocumentGetBreadcrumb   = "documentGetBreadcrumb"   // Get breadcrumb trail
        ActionDocumentGenerateTOC     = "documentGenerateTOC"     // Generate table of contents
        ActionDocumentGetMetadata     = "documentGetMetadata"     // Get document metadata
        ActionDocumentPublish            = "documentPublish"            // Publish document
        ActionDocumentUnpublish          = "documentUnpublish"          // Unpublish document
        ActionDocumentContentGet         = "documentContentGet"         // Get document content
        ActionDocumentContentUpdate      = "documentContentUpdate"      // Update document content
        ActionDocumentContentGetVersion  = "documentContentGetVersion"  // Get specific version content
        ActionDocumentContentGetLatest   = "documentContentGetLatest"   // Get latest version content

        // Document versioning actions (16)
        ActionDocumentVersionCreate     = "documentVersionCreate"     // Create new version
        ActionDocumentVersionList       = "documentVersionList"       // List all versions
        ActionDocumentVersionGet        = "documentVersionGet"        // Get specific version
        ActionDocumentVersionCompare    = "documentVersionCompare"    // Compare two versions
        ActionDocumentVersionRestore    = "documentVersionRestore"    // Rollback to version
        ActionDocumentVersionLabel         = "documentVersionLabel"         // Add label to version
        ActionDocumentVersionLabelCreate   = "documentVersionLabel"         // Alias for Label (backwards compatibility)
        ActionDocumentVersionLabelList     = "documentVersionLabelList"     // List labels for version
        ActionDocumentVersionComment       = "documentVersionComment"       // Add comment to version
        ActionDocumentVersionCommentCreate = "documentVersionComment"       // Alias for Comment (backwards compatibility)
        ActionDocumentVersionCommentList   = "documentVersionCommentList"   // List comments for version
        ActionDocumentVersionTag           = "documentVersionTag"           // Tag a version
        ActionDocumentVersionTagCreate     = "documentVersionTag"           // Alias for Tag (backwards compatibility)
        ActionDocumentVersionTagList       = "documentVersionTagList"       // List tags for version
        ActionDocumentVersionMention       = "documentVersionMention"       // Mention users in version
        ActionDocumentVersionMentionCreate = "documentVersionMention"       // Alias for Mention (backwards compatibility)
        ActionDocumentVersionMentionList   = "documentVersionMentionList"   // List mentions for version
        ActionDocumentVersionGetDiff       = "documentVersionGetDiff"       // Get diff between versions
        ActionDocumentVersionDiffGet       = "documentVersionGetDiff"       // Alias for GetDiff (backwards compatibility)
        ActionDocumentVersionDiffCreate    = "documentVersionDiffCreate"    // Create/store version diff
        ActionDocumentVersionGetHistory  = "documentVersionGetHistory"  // Get full version history
        ActionDocumentVersionSetMajor   = "documentVersionSetMajor"   // Mark as major version
        ActionDocumentVersionSetMinor   = "documentVersionSetMinor"   // Mark as minor version
        ActionDocumentVersionGetLabels  = "documentVersionGetLabels"  // Get version labels
        ActionDocumentVersionGetComments = "documentVersionGetComments" // Get version comments
        ActionDocumentVersionGetTags    = "documentVersionGetTags"    // Get version tags

        // Document collaboration actions (12) - uses core entities
        ActionDocumentCommentAdd           = "documentCommentAdd"           // Add comment (uses core comment)
        ActionDocumentCommentReply         = "documentCommentReply"         // Reply to comment
        ActionDocumentCommentEdit          = "documentCommentEdit"          // Edit comment
        ActionDocumentCommentRemove        = "documentCommentRemove"        // Delete comment
        ActionDocumentCommentList            = "documentCommentList"            // List all comments
        ActionDocumentInlineCommentAdd       = "documentInlineCommentAdd"       // Add inline comment
        ActionDocumentInlineCommentCreate    = "documentInlineCommentAdd"       // Alias for Add (backwards compatibility)
        ActionDocumentInlineCommentResolve   = "documentInlineCommentResolve"   // Resolve inline comment
        ActionDocumentInlineCommentList      = "documentInlineCommentList"      // List inline comments
        ActionDocumentMention                = "documentMention"                // Mention user in document
        ActionDocumentReact                  = "documentReact"                  // Add reaction/like (uses core vote)
        ActionDocumentVoteAdd                = "documentReact"                  // Alias for React (backwards compatibility)
        ActionDocumentVoteRemove             = "documentVoteRemove"             // Remove vote/reaction
        ActionDocumentVoteCount              = "documentVoteCount"              // Get vote count
        ActionDocumentGetReactions           = "documentGetReactions"           // Get all reactions
        ActionDocumentWatch                  = "documentWatch"                  // Start watching document
        ActionDocumentWatcherAdd             = "documentWatch"                  // Alias for Watch (backwards compatibility)
        ActionDocumentUnwatch                = "documentUnwatch"                // Stop watching document
        ActionDocumentWatcherRemove          = "documentUnwatch"                // Alias for Unwatch (backwards compatibility)
        ActionDocumentWatcherList            = "documentWatcherList"            // List watchers

        // Document organization actions (10) - tags + core labels
        ActionDocumentLabelAdd    = "documentLabelAdd"    // Add label (uses core label)
        ActionDocumentLabelRemove = "documentLabelRemove" // Remove label
        ActionDocumentLabelList   = "documentLabelList"   // List document labels
        ActionDocumentTagAdd                = "documentTagAdd"      // Add tag to document
        ActionDocumentTagCreate             = "documentTagCreate"   // Create new tag
        ActionDocumentTagAddToDocument      = "documentTagAdd"      // Alias for Add (backwards compatibility)
        ActionDocumentTagGet                = "documentTagGet"      // Get tag details
        ActionDocumentTagRemove             = "documentTagRemove"   // Remove tag
        ActionDocumentTagRemoveFromDocument = "documentTagRemove"   // Alias for Remove (backwards compatibility)
        ActionDocumentTagList               = "documentTagList"     // List document tags
        ActionDocumentCategoryAssign        = "documentCategoryAssign" // Assign document to category
        ActionDocumentCategoryList          = "documentCategoryList"   // List document categories
        ActionDocumentSpaceCreate = "documentSpaceCreate" // Create document space
        ActionDocumentSpaceRead   = "documentSpaceRead"   // Read/get space
        ActionDocumentSpaceList   = "documentSpaceList"   // List spaces
        ActionDocumentSpaceModify = "documentSpaceModify" // Modify space
        ActionDocumentSpaceUpdate = "documentSpaceModify" // Alias for Modify (backwards compatibility)
        ActionDocumentSpaceRemove = "documentSpaceRemove" // Remove space
        ActionDocumentSpaceDelete = "documentSpaceRemove" // Alias for Remove (backwards compatibility)

        // Document export actions (8)
        ActionDocumentExportPDF             = "documentExportPDF"             // Export to PDF
        ActionDocumentExportWord            = "documentExportWord"            // Export to Word (DOCX)
        ActionDocumentExportHTML            = "documentExportHTML"            // Export to HTML
        ActionDocumentExportXML             = "documentExportXML"             // Export to XML
        ActionDocumentExportMarkdown        = "documentExportMarkdown"        // Export to Markdown
        ActionDocumentExportPlainText       = "documentExportPlainText"       // Export to plain text
        ActionDocumentExportText            = "documentExportPlainText"       // Alias for Plain Text export
        ActionDocumentBulkExport            = "documentBulkExport"            // Bulk export documents
        ActionDocumentExportWithAttachments = "documentExportWithAttachments" // Export with attachments
        ActionDocumentExportStatus          = "documentExportStatus"          // Get export job status
        ActionDocumentExportDownload        = "documentExportDownload"        // Download exported file
        ActionDocumentExportCancel          = "documentExportCancel"          // Cancel export job
        ActionDocumentExportList            = "documentExportList"            // List export jobs

        // Document entity connection actions (10)
        ActionDocumentLinkToTicket       = "documentLinkToTicket"       // Link to ticket
        ActionDocumentLinkToProject      = "documentLinkToProject"      // Link to project
        ActionDocumentLinkToUser         = "documentLinkToUser"         // Link to user
        ActionDocumentLinkToLabel        = "documentLinkToLabel"        // Link to label
        ActionDocumentLinkToAny          = "documentLinkToAny"          // Link to any entity
        ActionDocumentEntityLinkCreate   = "documentLinkToAny"          // Alias for generic link creation
        ActionDocumentUnlink             = "documentUnlink"             // Remove link
        ActionDocumentEntityLinkDelete   = "documentUnlink"             // Alias for generic link deletion
        ActionDocumentEntityLinkRemove   = "documentUnlink"             // Another alias for removing link
        ActionDocumentGetLinks           = "documentGetLinks"           // Get all links
        ActionDocumentEntityLinkList       = "documentGetLinks"              // Alias for GetLinks
        ActionDocumentGetLinkedBy          = "documentGetLinkedBy"           // Get entities linking to doc
        ActionDocumentRelationshipCreate   = "documentRelationshipCreate"    // Create document relationship
        ActionDocumentRelationshipList     = "documentRelationshipList"      // List document relationships
        ActionDocumentRelationshipRemove   = "documentRelationshipRemove"    // Remove document relationship
        ActionDocumentEntityDocumentsList  = "documentEntityDocumentsList"   // List entity documents
        ActionDocumentProjectWikiGet       = "documentProjectWikiGet"        // Get project wiki

        // Document template &amp; blueprint actions (11)
        ActionDocumentTemplateCreate     = "documentTemplateCreate"     // Create template
        ActionDocumentTemplateRead       = "documentTemplateGet"        // Read template (alias)
        ActionDocumentTemplateList       = "documentTemplateList"       // List templates
        ActionDocumentTemplateGet        = "documentTemplateGet"        // Get template
        ActionDocumentTemplateModify     = "documentTemplateModify"     // Modify template
        ActionDocumentTemplateUpdate     = "documentTemplateModify"     // Alias for Modify (backwards compatibility)
        ActionDocumentTemplateRemove     = "documentTemplateRemove"     // Remove template
        ActionDocumentTemplateDelete     = "documentTemplateRemove"     // Alias for Remove (backwards compatibility)
        ActionDocumentCreateFromTemplate = "documentCreateFromTemplate" // Create from template
        ActionDocumentBlueprintCreate    = "documentBlueprintCreate"    // Create blueprint
        ActionDocumentBlueprintList      = "documentBlueprintList"      // List blueprints
        ActionDocumentBlueprintGet       = "documentBlueprintGet"       // Get blueprint

        // Document analytics actions (9)
        ActionDocumentGetViews         = "documentGetViews"         // Get view count/history
        ActionDocumentGetPopular       = "documentGetPopular"       // Get popular documents
        ActionDocumentPopularGet       = "documentGetPopular"       // Alias for GetPopular
        ActionDocumentGetActivity      = "documentGetActivity"      // Get activity stream
        ActionDocumentTrackView        = "documentTrackView"        // Track document view
        ActionDocumentViewRecord       = "documentTrackView"        // Alias for TrackView
        ActionDocumentGetStatistics    = "documentGetStatistics"    // Get document statistics
        ActionDocumentAnalyticsGet     = "documentAnalyticsGet"     // Get analytics data
        ActionDocumentAnalyticsUpdate  = "documentAnalyticsUpdate"  // Update analytics
        ActionDocumentViewHistoryGet   = "documentViewHistoryGet"   // Get view history

        // Document attachment actions (7)
        ActionDocumentAttachmentAdd    = "documentAttachmentAdd"    // Add attachment
        ActionDocumentAttachmentUpload = "documentAttachmentAdd"    // Alias for Add (backwards compatibility)
        ActionDocumentAttachmentRemove = "documentAttachmentRemove" // Remove attachment
        ActionDocumentAttachmentDelete = "documentAttachmentRemove" // Alias for Remove (backwards compatibility)
        ActionDocumentAttachmentList   = "documentAttachmentList"   // List attachments
        ActionDocumentAttachmentGet    = "documentAttachmentGet"    // Get attachment
        ActionDocumentAttachmentUpdate = "documentAttachmentUpdate" // Update attachment
)
</pre>
		
		<pre class="file" id="file47" style="display: none">package models

// Resolution represents how a ticket was resolved
type Resolution struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// Default resolution IDs
const (
        ResolutionIDFixed            = "resolution-fixed"
        ResolutionIDWontFix          = "resolution-wont-fix"
        ResolutionIDDuplicate        = "resolution-duplicate"
        ResolutionIDIncomplete       = "resolution-incomplete"
        ResolutionIDCannotReproduce  = "resolution-cannot-reproduce"
        ResolutionIDDone             = "resolution-done"
)

// GetDisplayName returns a user-friendly display name
func (r *Resolution) GetDisplayName() string <span class="cov10" title="9">{
        if r.Title != "" </span><span class="cov9" title="8">{
                return r.Title
        }</span>
        <span class="cov1" title="1">return "Unknown Resolution"</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package models

// Response represents the unified API response format
type Response struct {
        ErrorCode              int                    `json:"errorCode"`                        // -1 means no error
        ErrorMessage           string                 `json:"errorMessage,omitempty"`           // Error message in English
        ErrorMessageLocalised  string                 `json:"errorMessageLocalised,omitempty"`  // Localized error message
        Data                   map[string]interface{} `json:"data,omitempty"`                   // Response data
}

// NewSuccessResponse creates a successful response with optional data
func NewSuccessResponse(data map[string]interface{}) *Response <span class="cov7" title="3">{
        return &amp;Response{
                ErrorCode: ErrorCodeNoError,
                Data:      data,
        }
}</span>

// NewErrorResponse creates an error response
func NewErrorResponse(code int, message string, localisedMessage string) *Response <span class="cov4" title="2">{
        return &amp;Response{
                ErrorCode:             code,
                ErrorMessage:          message,
                ErrorMessageLocalised: localisedMessage,
        }
}</span>

// IsSuccess returns true if the response indicates success
func (r *Response) IsSuccess() bool <span class="cov10" title="5">{
        return r.ErrorCode == ErrorCodeNoError
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package models

// SecurityLevel represents an enterprise security level for controlling ticket access
type SecurityLevel struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        ProjectID   string `json:"projectId" db:"project_id" binding:"required"`
        Level       int    `json:"level" db:"level" binding:"required"` // Numeric level for hierarchy
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// SecurityLevelPermissionMapping represents access grants for a security level
type SecurityLevelPermissionMapping struct {
        ID              string  `json:"id" db:"id"`
        SecurityLevelID string  `json:"securityLevelId" db:"security_level_id" binding:"required"`
        UserID          *string `json:"userId,omitempty" db:"user_id"`           // NULL if not user-specific
        TeamID          *string `json:"teamId,omitempty" db:"team_id"`           // NULL if not team-specific
        ProjectRoleID   *string `json:"projectRoleId,omitempty" db:"project_role_id"` // NULL if not role-specific
        Created         int64   `json:"created" db:"created"`
        Deleted         bool    `json:"deleted" db:"deleted"`
}

// Security level constants
const (
        SecurityLevelNone      = 0
        SecurityLevelPublic    = 1
        SecurityLevelInternal  = 2
        SecurityLevelConfidential = 3
        SecurityLevelRestricted   = 4
        SecurityLevelSecret    = 5
)

// IsValidLevel checks if the security level value is valid
func (sl *SecurityLevel) IsValidLevel() bool <span class="cov0" title="0">{
        return sl.Level &gt;= SecurityLevelNone &amp;&amp; sl.Level &lt;= SecurityLevelSecret
}</span>

// GetRecipientType returns the type of recipient (user, team, or role)
func (slp *SecurityLevelPermissionMapping) GetRecipientType() string <span class="cov0" title="0">{
        if slp.UserID != nil &amp;&amp; *slp.UserID != "" </span><span class="cov0" title="0">{
                return "user"
        }</span>
        <span class="cov0" title="0">if slp.TeamID != nil &amp;&amp; *slp.TeamID != "" </span><span class="cov0" title="0">{
                return "team"
        }</span>
        <span class="cov0" title="0">if slp.ProjectRoleID != nil &amp;&amp; *slp.ProjectRoleID != "" </span><span class="cov0" title="0">{
                return "role"
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package models

import (
        "crypto/sha256"
        "encoding/hex"
        "time"
)

// ServiceType represents the type of service
type ServiceType string

const (
        ServiceTypeAuthentication ServiceType = "authentication"
        ServiceTypePermissions    ServiceType = "permissions"
        ServiceTypeLokalization   ServiceType = "lokalisation"
        ServiceTypeExtension      ServiceType = "extension"
)

// ServiceRole represents the role of a service in failover scenarios
type ServiceRole string

const (
        ServiceRolePrimary ServiceRole = "primary"
        ServiceRoleBackup  ServiceRole = "backup"
)

// ServiceStatus represents the current status of a service
type ServiceStatus string

const (
        ServiceStatusHealthy      ServiceStatus = "healthy"
        ServiceStatusUnhealthy    ServiceStatus = "unhealthy"
        ServiceStatusRegistering  ServiceStatus = "registering"
        ServiceStatusRotating     ServiceStatus = "rotating"
        ServiceStatusDecommission ServiceStatus = "decommissioned"
)

// ServiceRegistration represents a registered service in the system
type ServiceRegistration struct {
        ID                string        `json:"id"`                  // Unique service ID (UUID)
        Name              string        `json:"name"`                // Service name
        Type              ServiceType   `json:"type"`                // Service type
        Version           string        `json:"version"`             // Service version
        URL               string        `json:"url"`                 // Service base URL
        HealthCheckURL    string        `json:"health_check_url"`    // Health check endpoint
        PublicKey         string        `json:"public_key"`          // RSA public key for verification
        Signature         string        `json:"signature"`           // Service metadata signature
        Certificate       string        `json:"certificate"`         // TLS certificate (PEM format)
        Status            ServiceStatus `json:"status"`              // Current status
        Role              ServiceRole   `json:"role"`                // Service role (primary/backup)
        FailoverGroup     string        `json:"failover_group"`      // Failover group identifier
        IsActive          bool          `json:"is_active"`           // Currently active service for its group
        Priority          int           `json:"priority"`            // Service priority (higher = preferred)
        Metadata          string        `json:"metadata"`            // JSON metadata
        RegisteredBy      string        `json:"registered_by"`       // Username who registered
        RegisteredAt      time.Time     `json:"registered_at"`       // Registration timestamp
        LastHealthCheck   time.Time     `json:"last_health_check"`   // Last health check timestamp
        HealthCheckCount  int           `json:"health_check_count"`  // Total health checks performed
        FailedHealthCount int           `json:"failed_health_count"` // Failed health check count
        LastFailoverAt    time.Time     `json:"last_failover_at"`    // Last failover timestamp
        Deleted           bool          `json:"deleted"`             // Soft delete flag
}

// ServiceHealthCheck represents a health check record
type ServiceHealthCheck struct {
        ID            string        `json:"id"`              // Unique check ID
        ServiceID     string        `json:"service_id"`      // Service being checked
        Timestamp     time.Time     `json:"timestamp"`       // Check timestamp
        Status        ServiceStatus `json:"status"`          // Health status result
        ResponseTime  int64         `json:"response_time"`   // Response time in milliseconds
        StatusCode    int           `json:"status_code"`     // HTTP status code
        ErrorMessage  string        `json:"error_message"`   // Error message if unhealthy
        CheckedBy     string        `json:"checked_by"`      // System/user performing check
}

// ServiceRotationRequest represents a request to rotate a service
type ServiceRotationRequest struct {
        CurrentServiceID string              `json:"current_service_id"` // Service to be replaced
        NewService       ServiceRegistration `json:"new_service"`        // New service to replace with
        Reason           string              `json:"reason"`             // Reason for rotation
        RequestedBy      string              `json:"requested_by"`       // User requesting rotation
        AdminToken       string              `json:"admin_token"`        // Admin authorization token
        VerificationCode string              `json:"verification_code"`  // Additional verification code
}

// ServiceRotationResponse represents the response to a rotation request
type ServiceRotationResponse struct {
        Success          bool      `json:"success"`
        OldServiceID     string    `json:"old_service_id"`
        NewServiceID     string    `json:"new_service_id"`
        RotationTime     time.Time `json:"rotation_time"`
        VerificationHash string    `json:"verification_hash"` // Hash for audit trail
        Message          string    `json:"message"`
}

// ServiceDiscoveryRequest represents a request to discover services
type ServiceDiscoveryRequest struct {
        Type       ServiceType `json:"type"`        // Type of service to discover
        MinVersion string      `json:"min_version"` // Minimum version required
        OnlyHealthy bool       `json:"only_healthy"` // Return only healthy services
}

// ServiceDiscoveryResponse represents the response with discovered services
type ServiceDiscoveryResponse struct {
        Services   []ServiceRegistration `json:"services"`
        TotalCount int                   `json:"total_count"`
        Timestamp  time.Time             `json:"timestamp"`
}

// ComputeServiceSignature computes a signature for service metadata
func (s *ServiceRegistration) ComputeServiceSignature() string <span class="cov0" title="0">{
        data := s.ID + s.Name + string(s.Type) + s.Version + s.URL + s.PublicKey
        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

// VerifySignature verifies the service signature matches the computed signature
func (s *ServiceRegistration) VerifySignature() bool <span class="cov0" title="0">{
        expectedSignature := s.ComputeServiceSignature()
        return s.Signature == expectedSignature
}</span>

// IsHealthy returns whether the service is currently healthy
func (s *ServiceRegistration) IsHealthy() bool <span class="cov0" title="0">{
        return s.Status == ServiceStatusHealthy
}</span>

// CanRotate returns whether the service can be rotated
func (s *ServiceRegistration) CanRotate() bool <span class="cov0" title="0">{
        return s.Status != ServiceStatusRotating &amp;&amp; s.Status != ServiceStatusDecommission
}</span>

// ServiceFailoverEvent represents a failover event
type ServiceFailoverEvent struct {
        ID              string        `json:"id"`               // Unique event ID
        FailoverGroup   string        `json:"failover_group"`   // Failover group
        ServiceType     ServiceType   `json:"service_type"`     // Type of service
        OldServiceID    string        `json:"old_service_id"`   // Previous active service
        NewServiceID    string        `json:"new_service_id"`   // New active service
        FailoverReason  string        `json:"failover_reason"`  // Reason for failover
        FailoverType    string        `json:"failover_type"`    // "failover" or "failback"
        Timestamp       time.Time     `json:"timestamp"`        // When failover occurred
        Automatic       bool          `json:"automatic"`        // Was it automatic or manual
}

// ServiceRegistrationRequest represents a request to register a new service
type ServiceRegistrationRequest struct {
        Name           string      `json:"name"`
        Type           ServiceType `json:"type"`
        Version        string      `json:"version"`
        URL            string      `json:"url"`
        HealthCheckURL string      `json:"health_check_url"`
        PublicKey      string      `json:"public_key"`
        Certificate    string      `json:"certificate"`
        Role           ServiceRole `json:"role"`            // primary or backup
        FailoverGroup  string      `json:"failover_group"`  // Failover group (optional)
        Priority       int         `json:"priority"`
        Metadata       string      `json:"metadata"`
        AdminToken     string      `json:"admin_token"` // Required for registration
}

// ServiceUpdateRequest represents a request to update service metadata
type ServiceUpdateRequest struct {
        ServiceID      string `json:"service_id"`
        Version        string `json:"version,omitempty"`
        URL            string `json:"url,omitempty"`
        HealthCheckURL string `json:"health_check_url,omitempty"`
        Priority       int    `json:"priority,omitempty"`
        Metadata       string `json:"metadata,omitempty"`
        AdminToken     string `json:"admin_token"` // Required for update
}

// ServiceDecommissionRequest represents a request to decommission a service
type ServiceDecommissionRequest struct {
        ServiceID  string `json:"service_id"`
        Reason     string `json:"reason"`
        AdminToken string `json:"admin_token"` // Required for decommission
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package models

// Subtask represents a subtask - a smaller task that belongs to a parent ticket
// Subtasks are implemented as a special type of ticket with parent reference
type Subtask struct {
        ID             string `json:"id" db:"id"`
        TicketID       string `json:"ticketId" db:"ticket_id"`         // References ticket table
        ParentTicketID string `json:"parentTicketId" db:"parent_ticket_id"` // Parent ticket
        IsSubtask      bool   `json:"isSubtask" db:"is_subtask"`
}

// SubtaskSummary provides a summary of subtasks for a parent ticket
type SubtaskSummary struct {
        ParentTicketID string `json:"parentTicketId"`
        TotalSubtasks  int    `json:"totalSubtasks"`
        CompletedSubtasks int `json:"completedSubtasks"`
        PercentComplete float64 `json:"percentComplete"`
}

// IsSubtaskTicket checks if this represents a subtask ticket
func (s *Subtask) IsSubtaskTicket() bool <span class="cov0" title="0">{
        return s.IsSubtask
}</span>

// HasParent checks if the subtask has a parent ticket assigned
func (s *Subtask) HasParent() bool <span class="cov0" title="0">{
        return s.ParentTicketID != ""
}</span>

// CalculatePercentComplete calculates the completion percentage for subtasks
func (ss *SubtaskSummary) CalculatePercentComplete() <span class="cov0" title="0">{
        if ss.TotalSubtasks == 0 </span><span class="cov0" title="0">{
                ss.PercentComplete = 0
                return
        }</span>
        <span class="cov0" title="0">ss.PercentComplete = float64(ss.CompletedSubtasks) / float64(ss.TotalSubtasks) * 100.0</span>
}

// IsComplete checks if all subtasks are complete
func (ss *SubtaskSummary) IsComplete() bool <span class="cov0" title="0">{
        return ss.TotalSubtasks &gt; 0 &amp;&amp; ss.CompletedSubtasks == ss.TotalSubtasks
}</span>

// HasSubtasks checks if there are any subtasks
func (ss *SubtaskSummary) HasSubtasks() bool <span class="cov0" title="0">{
        return ss.TotalSubtasks &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package models

import "time"

// Ticket represents a ticket/issue in the system
type Ticket struct {
        ID             string `json:"id" db:"id"`
        TicketNumber   int    `json:"ticketNumber" db:"ticket_number"`
        Title          string `json:"title" db:"title"`
        Description    string `json:"description" db:"description"`
        TicketTypeID   string `json:"ticketTypeId" db:"ticket_type_id"`
        TicketStatusID string `json:"ticketStatusId" db:"ticket_status_id"`
        ProjectID      string `json:"projectId" db:"project_id"`
        UserID         string `json:"userId" db:"user_id"`        // Assignee
        Creator        string `json:"creator" db:"creator"`       // Creator username
        Estimation     *int   `json:"estimation" db:"estimation"` // In hours
        StoryPoints    *int   `json:"storyPoints" db:"story_points"`
        Created        int64  `json:"created" db:"created"`
        Modified       int64  `json:"modified" db:"modified"`
        Deleted        bool   `json:"deleted" db:"deleted"`
        Version        int    `json:"version" db:"version"` // Optimistic locking version
}

// NewTicket creates a new ticket with current timestamps
func NewTicket(id, title, description, ticketTypeID, ticketStatusID, projectID, userID, creator string, ticketNumber int) *Ticket <span class="cov0" title="0">{
        now := time.Now().Unix()
        return &amp;Ticket{
                ID:             id,
                TicketNumber:   ticketNumber,
                Title:          title,
                Description:    description,
                TicketTypeID:   ticketTypeID,
                TicketStatusID: ticketStatusID,
                ProjectID:      projectID,
                UserID:         userID,
                Creator:        creator,
                Created:        now,
                Modified:       now,
                Deleted:        false,
                Version:        1, // Start with version 1
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package models

// Version represents a product version/release
type Version struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        ProjectID   string `json:"projectId" db:"project_id" binding:"required"`
        StartDate   *int64 `json:"startDate,omitempty" db:"start_date"`   // Unix timestamp, pointer for nullable
        ReleaseDate *int64 `json:"releaseDate,omitempty" db:"release_date"` // Unix timestamp, pointer for nullable
        Released    bool   `json:"released" db:"released"`
        Archived    bool   `json:"archived" db:"archived"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// TicketVersionMapping represents the relationship between a ticket and a version
type TicketVersionMapping struct {
        ID        string `json:"id" db:"id"`
        TicketID  string `json:"ticketId" db:"ticket_id" binding:"required"`
        VersionID string `json:"versionId" db:"version_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// IsReleased checks if the version has been released
func (v *Version) IsReleased() bool <span class="cov9" title="8">{
        return v.Released
}</span>

// IsArchived checks if the version is archived
func (v *Version) IsArchived() bool <span class="cov5" title="3">{
        return v.Archived
}</span>

// IsActive checks if the version is active (not archived and not deleted)
func (v *Version) IsActive() bool <span class="cov10" title="10">{
        return !v.Archived &amp;&amp; !v.Deleted
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package models

// Vote represents a user's vote on a ticket
type Vote struct {
        ID       string `json:"id" db:"id"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        UserID   string `json:"userId" db:"user_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// VoteSummary provides voting statistics for a ticket
type VoteSummary struct {
        TicketID   string   `json:"ticketId"`
        VoteCount  int      `json:"voteCount"`
        VoterIDs   []string `json:"voterIds,omitempty"`
        HasVoted   bool     `json:"hasVoted"` // Whether the current user has voted
}

// IsValid checks if the vote has valid data
func (v *Vote) IsValid() bool <span class="cov0" title="0">{
        return v.TicketID != "" &amp;&amp; v.UserID != ""
}</span>

// HasVotes checks if there are any votes
func (vs *VoteSummary) HasVotes() bool <span class="cov0" title="0">{
        return vs.VoteCount &gt; 0
}</span>

// IsPopular checks if the ticket has a significant number of votes
func (vs *VoteSummary) IsPopular(threshold int) bool <span class="cov0" title="0">{
        return vs.VoteCount &gt;= threshold
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package models

// TicketWatcherMapping represents a user watching a ticket for notifications
type TicketWatcherMapping struct {
        ID       string `json:"id" db:"id"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        UserID   string `json:"userId" db:"user_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// IsWatching checks if a user is watching a specific ticket
func IsWatching(userID, ticketID string, watchers []TicketWatcherMapping) bool <span class="cov7" title="11">{
        for _, watcher := range watchers </span><span class="cov10" title="27">{
                if watcher.UserID == userID &amp;&amp; watcher.TicketID == ticketID &amp;&amp; !watcher.Deleted </span><span class="cov5" title="6">{
                        return true
                }</span>
        }
        <span class="cov5" title="5">return false</span>
}

// GetWatcherCount returns the number of active watchers for a ticket
func GetWatcherCount(ticketID string, watchers []TicketWatcherMapping) int <span class="cov4" title="4">{
        count := 0
        for _, watcher := range watchers </span><span class="cov7" title="12">{
                if watcher.TicketID == ticketID &amp;&amp; !watcher.Deleted </span><span class="cov4" title="3">{
                        count++
                }</span>
        }
        <span class="cov4" title="4">return count</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package models

import (
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

// Client represents a WebSocket client connection
type Client struct {
        ID           string              // Unique client ID
        Conn         *websocket.Conn     // WebSocket connection
        Username     string              // Authenticated username
        Claims       *JWTClaims          // JWT claims from authentication
        Subscription *Subscription       // Current subscription preferences
        Send         chan []byte         // Buffered channel for outbound messages
        Manager      ClientManager       // Reference to the manager (for unregister)
        mu           sync.RWMutex        // Mutex for thread-safe operations
        Connected    time.Time           // Connection timestamp
        LastPing     time.Time           // Last ping timestamp
        LastActivity time.Time           // Last activity timestamp
        Metadata     map[string]string   // Additional client metadata
}

// ClientManager interface for managing clients (to avoid circular dependency)
type ClientManager interface {
        UnregisterClient(*Client)
}

// NewClient creates a new WebSocket client
func NewClient(id string, conn *websocket.Conn, username string, claims *JWTClaims, manager ClientManager) *Client <span class="cov6" title="14">{
        now := time.Now()
        return &amp;Client{
                ID:           id,
                Conn:         conn,
                Username:     username,
                Claims:       claims,
                Subscription: &amp;Subscription{
                        EventTypes:   []EventType{},
                        EntityTypes:  []string{},
                        EntityIDs:    []string{},
                        Filters:      make(map[string]string),
                        IncludeReads: false,
                },
                Send:         make(chan []byte, 256), // Buffer size of 256 messages
                Manager:      manager,
                Connected:    now,
                LastPing:     now,
                LastActivity: now,
                Metadata:     make(map[string]string),
        }
}</span>

// UpdateSubscription safely updates the client's subscription
func (c *Client) UpdateSubscription(sub *Subscription) <span class="cov9" title="101">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.Subscription = sub
}</span>

// GetSubscription safely gets the client's subscription
func (c *Client) GetSubscription() *Subscription <span class="cov10" title="103">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Subscription
}</span>

// UpdateActivity updates the last activity timestamp
func (c *Client) UpdateActivity() <span class="cov9" title="101">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.LastActivity = time.Now()
}</span>

// UpdatePing updates the last ping timestamp
func (c *Client) UpdatePing() <span class="cov9" title="101">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.LastPing = time.Now()
}</span>

// GetLastActivity gets the last activity timestamp
func (c *Client) GetLastActivity() time.Time <span class="cov3" title="4">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.LastActivity
}</span>

// GetLastPing gets the last ping timestamp
func (c *Client) GetLastPing() time.Time <span class="cov3" title="4">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.LastPing
}</span>

// Close closes the client connection and channels
func (c *Client) Close() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Close the send channel
        select </span>{
        case &lt;-c.Send:<span class="cov0" title="0"></span>
                // Channel already closed
        default:<span class="cov0" title="0">
                close(c.Send)</span>
        }

        // Close the WebSocket connection
        <span class="cov0" title="0">if c.Conn != nil </span><span class="cov0" title="0">{
                c.Conn.Close()
        }</span>
}

// HasPermission checks if the client has a specific permission
func (c *Client) HasPermission(permission int) bool <span class="cov4" title="5">{
        if c.Claims == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov3" title="4">return c.Claims.HasPermission(permission)</span>
}

// WebSocketMessage represents a message sent/received via WebSocket
type WebSocketMessage struct {
        Type    string                 `json:"type"`    // Message type (subscribe, unsubscribe, event, ping, pong, error)
        Action  string                 `json:"action"`  // Action for the message
        Data    map[string]interface{} `json:"data"`    // Message data
        EventID string                 `json:"eventId"` // Event ID if this is an event message
        Error   string                 `json:"error"`   // Error message if applicable
}

// WebSocketMessageType constants
const (
        WSMessageTypeSubscribe   = "subscribe"   // Client subscribes to events
        WSMessageTypeUnsubscribe = "unsubscribe" // Client unsubscribes from events
        WSMessageTypeEvent       = "event"       // Server sends an event
        WSMessageTypePing        = "ping"        // Ping message
        WSMessageTypePong        = "pong"        // Pong response
        WSMessageTypeError       = "error"       // Error message
        WSMessageTypeAck         = "ack"         // Acknowledgment
        WSMessageTypeAuth        = "auth"        // Authentication message
)

// NewWebSocketMessage creates a new WebSocket message
func NewWebSocketMessage(msgType, action string, data map[string]interface{}) *WebSocketMessage <span class="cov1" title="1">{
        return &amp;WebSocketMessage{
                Type:   msgType,
                Action: action,
                Data:   data,
        }
}</span>

// NewErrorMessage creates an error message
func NewErrorMessage(errorMsg string) *WebSocketMessage <span class="cov1" title="1">{
        return &amp;WebSocketMessage{
                Type:  WSMessageTypeError,
                Error: errorMsg,
        }
}</span>

// NewEventMessage creates an event message
func NewEventMessage(event *Event) *WebSocketMessage <span class="cov1" title="1">{
        return &amp;WebSocketMessage{
                Type:    WSMessageTypeEvent,
                Action:  event.Action,
                EventID: event.ID,
                Data: map[string]interface{}{
                        "event": event,
                },
        }
}</span>

// WebSocketConfig represents WebSocket configuration
type WebSocketConfig struct {
        Enabled             bool          `json:"enabled"`              // Whether WebSocket is enabled
        Path                string        `json:"path"`                 // WebSocket endpoint path (default: /ws)
        ReadBufferSize      int           `json:"readBufferSize"`       // Read buffer size in bytes
        WriteBufferSize     int           `json:"writeBufferSize"`      // Write buffer size in bytes
        MaxMessageSize      int64         `json:"maxMessageSize"`       // Maximum message size in bytes
        WriteWait           time.Duration `json:"writeWait"`            // Time allowed to write a message
        PongWait            time.Duration `json:"pongWait"`             // Time allowed to read pong
        PingPeriod          time.Duration `json:"pingPeriod"`           // Period for sending pings
        MaxClients          int           `json:"maxClients"`           // Maximum number of concurrent clients
        RequireAuth         bool          `json:"requireAuth"`          // Whether authentication is required
        AllowOrigins        []string      `json:"allowOrigins"`         // Allowed origins for CORS
        EnableCompression   bool          `json:"enableCompression"`    // Enable per-message compression
        HandshakeTimeout    time.Duration `json:"handshakeTimeout"`     // WebSocket handshake timeout
}

// DefaultWebSocketConfig returns default WebSocket configuration
func DefaultWebSocketConfig() WebSocketConfig <span class="cov2" title="2">{
        return WebSocketConfig{
                Enabled:           true,
                Path:              "/ws",
                ReadBufferSize:    1024,
                WriteBufferSize:   1024,
                MaxMessageSize:    512 * 1024, // 512KB
                WriteWait:         10 * time.Second,
                PongWait:          60 * time.Second,
                PingPeriod:        54 * time.Second, // Must be less than pongWait
                MaxClients:        1000,
                RequireAuth:       true,
                AllowOrigins:      []string{"*"},
                EnableCompression: true,
                HandshakeTimeout:  10 * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package models

// WorkLog represents a detailed time tracking entry for a ticket
type WorkLog struct {
        ID          string `json:"id" db:"id"`
        TicketID    string `json:"ticketId" db:"ticket_id" binding:"required"`
        UserID      string `json:"userId" db:"user_id" binding:"required"`
        TimeSpent   int    `json:"timeSpent" db:"time_spent" binding:"required"` // In minutes
        WorkDate    int64  `json:"workDate" db:"work_date" binding:"required"`   // Unix timestamp
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// GetTimeSpentHours returns the time spent in hours
func (w *WorkLog) GetTimeSpentHours() float64 <span class="cov0" title="0">{
        return float64(w.TimeSpent) / 60.0
}</span>

// GetTimeSpentDays returns the time spent in days (assuming 8-hour workday)
func (w *WorkLog) GetTimeSpentDays() float64 <span class="cov0" title="0">{
        return float64(w.TimeSpent) / (8.0 * 60.0)
}</span>

// IsValid checks if the work log has valid data
func (w *WorkLog) IsValid() bool <span class="cov0" title="0">{
        return w.TicketID != "" &amp;&amp; w.UserID != "" &amp;&amp; w.TimeSpent &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package security

import (
        "fmt"
        "sync"
        "time"
)

// SecurityEvent represents a security-related event
type SecurityEvent struct {
        Timestamp   time.Time
        EventType   string
        IP          string
        UserAgent   string
        Details     string
        Severity    string // INFO, WARNING, CRITICAL
        Action      string // ALLOWED, BLOCKED, SUSPICIOUS
}

// SecurityAuditLog manages security event logging
type SecurityAuditLog struct {
        events    []SecurityEvent
        mu        sync.RWMutex
        maxEvents int
        callbacks []func(SecurityEvent)
}

// Global audit log
var globalAuditLog = &amp;SecurityAuditLog{
        events:    make([]SecurityEvent, 0, 10000),
        maxEvents: 10000,
        callbacks: make([]func(SecurityEvent), 0),
}

// LogSecurityEvent logs a security event
func LogSecurityEvent(eventType, ip, details string) <span class="cov9" title="157">{
        event := SecurityEvent{
                Timestamp: time.Now(),
                EventType: eventType,
                IP:        ip,
                Details:   details,
                Severity:  determineSeverity(eventType),
                Action:    determineAction(eventType),
        }

        globalAuditLog.mu.Lock()
        defer globalAuditLog.mu.Unlock()

        // Add event
        globalAuditLog.events = append(globalAuditLog.events, event)

        // Trim if over limit
        if len(globalAuditLog.events) &gt; globalAuditLog.maxEvents </span><span class="cov0" title="0">{
                globalAuditLog.events = globalAuditLog.events[len(globalAuditLog.events)-globalAuditLog.maxEvents:]
        }</span>

        // Call callbacks
        <span class="cov9" title="157">for _, callback := range globalAuditLog.callbacks </span><span class="cov9" title="130">{
                go callback(event)
        }</span>

        // Print critical events
        <span class="cov9" title="157">if event.Severity == "CRITICAL" </span><span class="cov5" title="10">{
                fmt.Printf("[SECURITY CRITICAL] %s from %s: %s\n", eventType, ip, details)
        }</span>
}

// RegisterCallback registers a callback for security events
func RegisterCallback(callback func(SecurityEvent)) <span class="cov1" title="1">{
        globalAuditLog.mu.Lock()
        defer globalAuditLog.mu.Unlock()
        globalAuditLog.callbacks = append(globalAuditLog.callbacks, callback)
}</span>

// GetRecentEvents returns recent security events
func GetRecentEvents(limit int) []SecurityEvent <span class="cov4" title="6">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        if limit &gt; len(globalAuditLog.events) </span><span class="cov3" title="4">{
                limit = len(globalAuditLog.events)
        }</span>

        <span class="cov4" title="6">events := make([]SecurityEvent, limit)
        copy(events, globalAuditLog.events[len(globalAuditLog.events)-limit:])
        return events</span>
}

// GetEventsByIP returns events for a specific IP
func GetEventsByIP(ip string, limit int) []SecurityEvent <span class="cov1" title="1">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        var events []SecurityEvent
        for i := len(globalAuditLog.events) - 1; i &gt;= 0 &amp;&amp; len(events) &lt; limit; i-- </span><span class="cov3" title="4">{
                if globalAuditLog.events[i].IP == ip </span><span class="cov2" title="2">{
                        events = append(events, globalAuditLog.events[i])
                }</span>
        }
        <span class="cov1" title="1">return events</span>
}

// GetEventsByType returns events of a specific type
func GetEventsByType(eventType string, limit int) []SecurityEvent <span class="cov1" title="1">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        var events []SecurityEvent
        for i := len(globalAuditLog.events) - 1; i &gt;= 0 &amp;&amp; len(events) &lt; limit; i-- </span><span class="cov2" title="3">{
                if globalAuditLog.events[i].EventType == eventType </span><span class="cov2" title="2">{
                        events = append(events, globalAuditLog.events[i])
                }</span>
        }
        <span class="cov1" title="1">return events</span>
}

// ClearAuditLog clears all events
func ClearAuditLog() <span class="cov5" title="11">{
        globalAuditLog.mu.Lock()
        defer globalAuditLog.mu.Unlock()
        globalAuditLog.events = make([]SecurityEvent, 0, globalAuditLog.maxEvents)
}</span>

// determineSeverity determines event severity
func determineSeverity(eventType string) string <span class="cov10" title="166">{
        critical := map[string]bool{
                "IP_BLOCKED":           true,
                "BRUTE_FORCE_DETECTED": true,
                "SQL_INJECTION":        true,
                "XSS_ATTEMPT":          true,
                "CSRF_DETECTED":        true,
                "MALICIOUS_PAYLOAD":    true,
                "INVALID_TOKEN":        true,
        }

        warning := map[string]bool{
                "REQUEST_BLOCKED":      true,
                "RATE_LIMIT_EXCEEDED":  true,
                "SUSPICIOUS_ACTIVITY":  true,
                "REQUEST_TOO_LARGE":    true,
                "URI_TOO_LONG":         true,
                "INVALID_INPUT":        true,
        }

        if critical[eventType] </span><span class="cov5" title="15">{
                return "CRITICAL"
        }</span>
        <span class="cov9" title="151">if warning[eventType] </span><span class="cov5" title="14">{
                return "WARNING"
        }</span>
        <span class="cov9" title="137">return "INFO"</span>
}

// determineAction determines the action taken
func determineAction(eventType string) string <span class="cov9" title="164">{
        blocked := map[string]bool{
                "IP_BLOCKED":           true,
                "REQUEST_BLOCKED":      true,
                "RATE_LIMIT_EXCEEDED":  true,
                "SQL_INJECTION":        true,
                "XSS_ATTEMPT":          true,
                "CSRF_DETECTED":        true,
                "MALICIOUS_PAYLOAD":    true,
        }

        suspicious := map[string]bool{
                "SUSPICIOUS_ACTIVITY":  true,
                "INVALID_INPUT":        true,
                "REQUEST_TOO_LARGE":    true,
                "URI_TOO_LONG":         true,
        }

        if blocked[eventType] </span><span class="cov6" title="19">{
                return "BLOCKED"
        }</span>
        <span class="cov9" title="145">if suspicious[eventType] </span><span class="cov4" title="7">{
                return "SUSPICIOUS"
        }</span>
        <span class="cov9" title="138">return "ALLOWED"</span>
}

// SecurityStatistics contains security statistics
type SecurityStatistics struct {
        TotalEvents       int
        CriticalEvents    int
        WarningEvents     int
        InfoEvents        int
        BlockedEvents     int
        SuspiciousEvents  int
        AllowedEvents     int
        UniqueIPs         int
        RecentEvents      []SecurityEvent
}

// GetSecurityStatistics returns security statistics
func GetSecurityStatistics(recentCount int) *SecurityStatistics <span class="cov2" title="2">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        stats := &amp;SecurityStatistics{
                TotalEvents:  len(globalAuditLog.events),
                RecentEvents: make([]SecurityEvent, 0),
        }

        uniqueIPs := make(map[string]bool)

        for _, event := range globalAuditLog.events </span><span class="cov4" title="9">{
                uniqueIPs[event.IP] = true

                switch event.Severity </span>{
                case "CRITICAL":<span class="cov2" title="2">
                        stats.CriticalEvents++</span>
                case "WARNING":<span class="cov2" title="2">
                        stats.WarningEvents++</span>
                case "INFO":<span class="cov3" title="5">
                        stats.InfoEvents++</span>
                }

                <span class="cov4" title="9">switch event.Action </span>{
                case "BLOCKED":<span class="cov2" title="3">
                        stats.BlockedEvents++</span>
                case "SUSPICIOUS":<span class="cov1" title="1">
                        stats.SuspiciousEvents++</span>
                case "ALLOWED":<span class="cov3" title="5">
                        stats.AllowedEvents++</span>
                }
        }

        <span class="cov2" title="2">stats.UniqueIPs = len(uniqueIPs)

        // Get recent events
        if recentCount &gt; 0 </span><span class="cov2" title="2">{
                start := len(globalAuditLog.events) - recentCount
                if start &lt; 0 </span><span class="cov2" title="2">{
                        start = 0
                }</span>
                <span class="cov2" title="2">stats.RecentEvents = make([]SecurityEvent, len(globalAuditLog.events[start:]))
                copy(stats.RecentEvents, globalAuditLog.events[start:])</span>
        }

        <span class="cov2" title="2">return stats</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package security

import (
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// BruteForceProtectionConfig contains brute force protection configuration
type BruteForceProtectionConfig struct {
        // Failure tracking
        MaxFailedAttempts    int           // Maximum failed attempts before blocking
        FailureWindow        time.Duration // Time window for counting failures
        BlockDuration        time.Duration // Duration to block after max failures
        PermanentBlockThreshold int        // Failures before permanent block

        // Progressive delays
        EnableProgressiveDelay bool          // Enable progressive delays
        BaseDelay              time.Duration // Base delay (increases exponentially)
        MaxDelay               time.Duration // Maximum delay

        // Account lockout
        EnableAccountLockout   bool          // Enable account lockout
        LockoutDuration        time.Duration // Duration to lock account
        NotifyOnLockout        bool          // Notify on account lockout

        // IP tracking
        TrackByIP              bool          // Track failures by IP
        TrackByUsername        bool          // Track failures by username
        TrackByIPAndUsername   bool          // Track failures by IP+username combination

        // Whitelist
        WhitelistedIPs         []string      // IPs exempt from protection
        WhitelistedUsernames   []string      // Usernames exempt from protection

        // CAPTCHA integration
        EnableCAPTCHA          bool          // Enable CAPTCHA after failures
        CAPTCHAThreshold       int           // Failures before requiring CAPTCHA

        // Cleanup
        CleanupInterval        time.Duration // Cleanup interval for old entries
}

// DefaultBruteForceProtectionConfig returns secure default settings
func DefaultBruteForceProtectionConfig() BruteForceProtectionConfig <span class="cov5" title="12">{
        return BruteForceProtectionConfig{
                MaxFailedAttempts:       5,
                FailureWindow:           15 * time.Minute,
                BlockDuration:           30 * time.Minute,
                PermanentBlockThreshold: 20,
                EnableProgressiveDelay:  true,
                BaseDelay:               1 * time.Second,
                MaxDelay:                30 * time.Second,
                EnableAccountLockout:    true,
                LockoutDuration:         1 * time.Hour,
                NotifyOnLockout:         true,
                TrackByIP:               true,
                TrackByUsername:         true,
                TrackByIPAndUsername:    true,
                WhitelistedIPs:          []string{},
                WhitelistedUsernames:    []string{},
                EnableCAPTCHA:           false,
                CAPTCHAThreshold:        3,
                CleanupInterval:         5 * time.Minute,
        }
}</span>

// StrictBruteForceProtectionConfig returns very strict settings
func StrictBruteForceProtectionConfig() BruteForceProtectionConfig <span class="cov0" title="0">{
        cfg := DefaultBruteForceProtectionConfig()
        cfg.MaxFailedAttempts = 3
        cfg.BlockDuration = 1 * time.Hour
        cfg.PermanentBlockThreshold = 10
        cfg.LockoutDuration = 24 * time.Hour
        cfg.EnableCAPTCHA = true
        cfg.CAPTCHAThreshold = 2
        return cfg
}</span>

// failureRecord tracks failed login attempts
type failureRecord struct {
        Attempts      int
        FirstAttempt  time.Time
        LastAttempt   time.Time
        BlockedUntil  time.Time
        PermanentBlock bool
        TotalFailures int
}

// bruteForceProtector implements brute force protection
type bruteForceProtector struct {
        config           BruteForceProtectionConfig
        ipFailures       map[string]*failureRecord
        usernameFailures map[string]*failureRecord
        combinedFailures map[string]*failureRecord // IP+Username
        mu               sync.RWMutex
        stopCleanup      chan struct{}
        cleanupDone      sync.WaitGroup
}

// newBruteForceProtector creates a new brute force protector
func newBruteForceProtector(cfg BruteForceProtectionConfig) *bruteForceProtector <span class="cov5" title="12">{
        bp := &amp;bruteForceProtector{
                config:           cfg,
                ipFailures:       make(map[string]*failureRecord),
                usernameFailures: make(map[string]*failureRecord),
                combinedFailures: make(map[string]*failureRecord),
                stopCleanup:      make(chan struct{}),
        }

        // Start background cleanup
        bp.cleanupDone.Add(1)
        go bp.cleanupLoop()

        return bp
}</span>

// checkAttempt checks if an attempt should be allowed
func (bp *bruteForceProtector) checkAttempt(ip, username string) (allowed bool, reason string, delay time.Duration) <span class="cov6" title="20">{
        // Check whitelists
        if bp.isWhitelisted(ip, username) </span><span class="cov2" title="2">{
                return true, "", 0
        }</span>

        <span class="cov6" title="18">bp.mu.Lock()
        defer bp.mu.Unlock()

        now := time.Now()
        blocked := false
        var blockReason string
        maxDelay := time.Duration(0)

        // Check IP-based failures
        if bp.config.TrackByIP </span><span class="cov6" title="18">{
                if record, exists := bp.ipFailures[ip]; exists </span><span class="cov5" title="11">{
                        isBlocked, reason, delay := bp.checkRecord(record, now, "IP")
                        if isBlocked </span><span class="cov5" title="8">{
                                blocked = true
                                blockReason = reason
                        }</span>
                        <span class="cov5" title="11">if delay &gt; maxDelay </span><span class="cov2" title="2">{
                                maxDelay = delay
                        }</span>
                }
        }

        // Check username-based failures
        <span class="cov6" title="18">if bp.config.TrackByUsername &amp;&amp; username != "" </span><span class="cov6" title="13">{
                if record, exists := bp.usernameFailures[username]; exists </span><span class="cov5" title="8">{
                        isBlocked, reason, delay := bp.checkRecord(record, now, "username")
                        if isBlocked </span><span class="cov4" title="6">{
                                blocked = true
                                blockReason = reason
                        }</span>
                        <span class="cov5" title="8">if delay &gt; maxDelay </span><span class="cov0" title="0">{
                                maxDelay = delay
                        }</span>
                }
        }

        // Check combined IP+username failures
        <span class="cov6" title="18">if bp.config.TrackByIPAndUsername &amp;&amp; username != "" </span><span class="cov6" title="15">{
                key := fmt.Sprintf("%s:%s", ip, username)
                if record, exists := bp.combinedFailures[key]; exists </span><span class="cov5" title="9">{
                        isBlocked, reason, delay := bp.checkRecord(record, now, "IP+username")
                        if isBlocked </span><span class="cov4" title="7">{
                                blocked = true
                                blockReason = reason
                        }</span>
                        <span class="cov5" title="9">if delay &gt; maxDelay </span><span class="cov0" title="0">{
                                maxDelay = delay
                        }</span>
                }
        }

        <span class="cov6" title="18">if blocked </span><span class="cov5" title="8">{
                return false, blockReason, maxDelay
        }</span>

        <span class="cov5" title="10">return true, "", maxDelay</span>
}

// checkRecord checks if a failure record indicates blocking
func (bp *bruteForceProtector) checkRecord(record *failureRecord, now time.Time, recordType string) (blocked bool, reason string, delay time.Duration) <span class="cov7" title="28">{
        // Check permanent block
        if record.PermanentBlock </span><span class="cov4" title="6">{
                return true, fmt.Sprintf("Permanently blocked (%s)", recordType), 0
        }</span>

        // Check temporary block
        <span class="cov7" title="22">if now.Before(record.BlockedUntil) </span><span class="cov6" title="15">{
                remaining := record.BlockedUntil.Sub(now)
                return true, fmt.Sprintf("Temporarily blocked (%s) - %v remaining", recordType, remaining.Round(time.Second)), 0
        }</span>

        // If block has expired, reset attempts
        <span class="cov4" title="7">if !record.BlockedUntil.IsZero() &amp;&amp; now.After(record.BlockedUntil) </span><span class="cov3" title="3">{
                record.Attempts = 0
                record.BlockedUntil = time.Time{} // Clear block time
                return false, "", 0
        }</span>

        // Check if we're in the failure window
        <span class="cov3" title="4">if now.Sub(record.FirstAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                // Outside window, reset
                record.Attempts = 0
                record.FirstAttempt = now
                return false, "", 0
        }</span>

        // Check if we've exceeded max attempts
        <span class="cov3" title="4">if record.Attempts &gt;= bp.config.MaxFailedAttempts </span><span class="cov0" title="0">{
                return true, fmt.Sprintf("Too many failed attempts (%s)", recordType), 0
        }</span>

        // Calculate progressive delay if enabled
        <span class="cov3" title="4">if bp.config.EnableProgressiveDelay &amp;&amp; record.Attempts &gt; 0 </span><span class="cov3" title="4">{
                delay = bp.calculateDelay(record.Attempts)
                return false, "", delay
        }</span>

        <span class="cov0" title="0">return false, "", 0</span>
}

// recordFailure records a failed attempt
func (bp *bruteForceProtector) recordFailure(ip, username string) <span class="cov9" title="71">{
        // Check whitelists
        if bp.isWhitelisted(ip, username) </span><span class="cov8" title="40">{
                return
        }</span>

        <span class="cov7" title="31">bp.mu.Lock()
        defer bp.mu.Unlock()

        now := time.Now()

        // Record IP failure
        if bp.config.TrackByIP </span><span class="cov7" title="31">{
                bp.updateFailureRecord(bp.ipFailures, ip, now)
        }</span>

        // Record username failure
        <span class="cov7" title="31">if bp.config.TrackByUsername &amp;&amp; username != "" </span><span class="cov7" title="26">{
                bp.updateFailureRecord(bp.usernameFailures, username, now)
        }</span>

        // Record combined failure
        <span class="cov7" title="31">if bp.config.TrackByIPAndUsername &amp;&amp; username != "" </span><span class="cov7" title="29">{
                key := fmt.Sprintf("%s:%s", ip, username)
                bp.updateFailureRecord(bp.combinedFailures, key, now)
        }</span>
}

// updateFailureRecord updates a failure record
func (bp *bruteForceProtector) updateFailureRecord(records map[string]*failureRecord, key string, now time.Time) <span class="cov9" title="86">{
        record, exists := records[key]
        if !exists </span><span class="cov8" title="36">{
                record = &amp;failureRecord{
                        FirstAttempt: now,
                }
                records[key] = record
        }</span>

        // Reset if outside failure window
        <span class="cov9" title="86">if now.Sub(record.FirstAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                record.Attempts = 0
                record.FirstAttempt = now
        }</span>

        <span class="cov9" title="86">record.Attempts++
        record.LastAttempt = now
        record.TotalFailures++

        // Check if we should block
        if record.Attempts &gt;= bp.config.MaxFailedAttempts </span><span class="cov8" title="41">{
                record.BlockedUntil = now.Add(bp.config.BlockDuration)

                // Check for permanent block
                if record.TotalFailures &gt;= bp.config.PermanentBlockThreshold </span><span class="cov4" title="6">{
                        record.PermanentBlock = true
                }</span>
        }
}

// recordSuccess records a successful attempt (resets counters)
func (bp *bruteForceProtector) recordSuccess(ip, username string) <span class="cov2" title="2">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        // Reset IP failures
        if bp.config.TrackByIP </span><span class="cov2" title="2">{
                delete(bp.ipFailures, ip)
        }</span>

        // Reset username failures
        <span class="cov2" title="2">if bp.config.TrackByUsername &amp;&amp; username != "" </span><span class="cov2" title="2">{
                delete(bp.usernameFailures, username)
        }</span>

        // Reset combined failures
        <span class="cov2" title="2">if bp.config.TrackByIPAndUsername &amp;&amp; username != "" </span><span class="cov2" title="2">{
                key := fmt.Sprintf("%s:%s", ip, username)
                delete(bp.combinedFailures, key)
        }</span>
}

// isWhitelisted checks if IP or username is whitelisted
func (bp *bruteForceProtector) isWhitelisted(ip, username string) bool <span class="cov10" title="91">{
        // Check IP whitelist
        for _, whitelistedIP := range bp.config.WhitelistedIPs </span><span class="cov8" title="42">{
                if ip == whitelistedIP </span><span class="cov7" title="21">{
                        return true
                }</span>
        }

        // Check username whitelist
        <span class="cov9" title="70">for _, whitelistedUsername := range bp.config.WhitelistedUsernames </span><span class="cov7" title="21">{
                if username == whitelistedUsername </span><span class="cov7" title="21">{
                        return true
                }</span>
        }

        <span class="cov8" title="49">return false</span>
}

// calculateDelay calculates progressive delay based on attempt count
func (bp *bruteForceProtector) calculateDelay(attempts int) time.Duration <span class="cov3" title="4">{
        // Exponential backoff: baseDelay * 2^(attempts-1)
        delay := bp.config.BaseDelay * time.Duration(1&lt;&lt;uint(attempts-1))

        if delay &gt; bp.config.MaxDelay </span><span class="cov0" title="0">{
                delay = bp.config.MaxDelay
        }</span>

        <span class="cov3" title="4">return delay</span>
}

// cleanupLoop runs background cleanup
func (bp *bruteForceProtector) cleanupLoop() <span class="cov5" title="12">{
        defer bp.cleanupDone.Done()

        ticker := time.NewTicker(bp.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov5" title="12">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        bp.cleanup()</span>
                case &lt;-bp.stopCleanup:<span class="cov5" title="10">
                        return</span>
                }
        }
}

// cleanup removes old entries
func (bp *bruteForceProtector) cleanup() <span class="cov0" title="0">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        now := time.Now()

        // Cleanup IP failures
        for ip, record := range bp.ipFailures </span><span class="cov0" title="0">{
                if !record.PermanentBlock &amp;&amp; now.After(record.BlockedUntil) &amp;&amp;
                        now.Sub(record.LastAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                        delete(bp.ipFailures, ip)
                }</span>
        }

        // Cleanup username failures
        <span class="cov0" title="0">for username, record := range bp.usernameFailures </span><span class="cov0" title="0">{
                if !record.PermanentBlock &amp;&amp; now.After(record.BlockedUntil) &amp;&amp;
                        now.Sub(record.LastAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                        delete(bp.usernameFailures, username)
                }</span>
        }

        // Cleanup combined failures
        <span class="cov0" title="0">for key, record := range bp.combinedFailures </span><span class="cov0" title="0">{
                if !record.PermanentBlock &amp;&amp; now.After(record.BlockedUntil) &amp;&amp;
                        now.Sub(record.LastAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                        delete(bp.combinedFailures, key)
                }</span>
        }
}

// close stops the brute force protector
func (bp *bruteForceProtector) close() <span class="cov5" title="10">{
        close(bp.stopCleanup)
        bp.cleanupDone.Wait()
}</span>

// getStatistics returns statistics
func (bp *bruteForceProtector) getStatistics() *BruteForceStatistics <span class="cov1" title="1">{
        bp.mu.RLock()
        defer bp.mu.RUnlock()

        stats := &amp;BruteForceStatistics{
                TrackedIPs:       len(bp.ipFailures),
                TrackedUsernames: len(bp.usernameFailures),
                TrackedCombined:  len(bp.combinedFailures),
        }

        now := time.Now()

        // Count blocked entries
        for _, record := range bp.ipFailures </span><span class="cov3" title="3">{
                if record.PermanentBlock </span><span class="cov0" title="0">{
                        stats.PermanentlyBlockedIPs++
                }</span> else<span class="cov3" title="3"> if now.Before(record.BlockedUntil) </span><span class="cov0" title="0">{
                        stats.BlockedIPs++
                }</span>
        }

        <span class="cov1" title="1">for _, record := range bp.usernameFailures </span><span class="cov3" title="3">{
                if record.PermanentBlock </span><span class="cov0" title="0">{
                        stats.PermanentlyBlockedUsernames++
                }</span> else<span class="cov3" title="3"> if now.Before(record.BlockedUntil) </span><span class="cov0" title="0">{
                        stats.BlockedUsernames++
                }</span>
        }

        <span class="cov1" title="1">return stats</span>
}

// Global brute force protector
var globalBruteForceProtector *bruteForceProtector

// InitBruteForceProtection initializes brute force protection
func InitBruteForceProtection(cfg BruteForceProtectionConfig) <span class="cov4" title="5">{
        if globalBruteForceProtector != nil </span><span class="cov3" title="4">{
                globalBruteForceProtector.close()
        }</span>
        <span class="cov4" title="5">globalBruteForceProtector = newBruteForceProtector(cfg)</span>
}

// BruteForceProtectionMiddleware creates brute force protection middleware
func BruteForceProtectionMiddleware(cfg BruteForceProtectionConfig) gin.HandlerFunc <span class="cov1" title="1">{
        protector := newBruteForceProtector(cfg)

        return func(c *gin.Context) </span><span class="cov3" title="3">{
                // Only protect authentication endpoints
                // This should be applied to login/authentication routes only

                ip := c.ClientIP()

                // Try to get username from request
                username := ""
                if user, exists := c.Get("username"); exists </span><span class="cov0" title="0">{
                        username = user.(string)
                }</span> else<span class="cov3" title="3"> {
                        // Try to extract from request body
                        var body map[string]interface{}
                        if err := c.ShouldBindJSON(&amp;body); err == nil </span><span class="cov0" title="0">{
                                if u, ok := body["username"].(string); ok </span><span class="cov0" title="0">{
                                        username = u
                                }</span> else<span class="cov0" title="0"> if u, ok := body["email"].(string); ok </span><span class="cov0" title="0">{
                                        username = u
                                }</span>
                        }
                }

                // Check if attempt should be allowed
                <span class="cov3" title="3">allowed, reason, delay := protector.checkAttempt(ip, username)

                if !allowed </span><span class="cov1" title="1">{
                        LogSecurityEvent("BRUTE_FORCE_DETECTED", ip,
                                fmt.Sprintf("Brute force attempt blocked for username '%s': %s",
                                        username, reason))

                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "Too many failed attempts",
                                "reason":      reason,
                                "retry_after": cfg.BlockDuration.String(),
                        })
                        c.Abort()
                        return
                }</span>

                // Apply progressive delay if needed
                <span class="cov2" title="2">if delay &gt; 0 </span><span class="cov1" title="1">{
                        time.Sleep(delay)
                }</span>

                // Process request
                <span class="cov2" title="2">c.Next()

                // Check if authentication was successful
                statusCode := c.Writer.Status()

                if statusCode == http.StatusOK || statusCode == http.StatusCreated </span><span class="cov0" title="0">{
                        // Successful authentication
                        protector.recordSuccess(ip, username)
                }</span> else<span class="cov2" title="2"> if statusCode == http.StatusUnauthorized || statusCode == http.StatusForbidden </span><span class="cov2" title="2">{
                        // Failed authentication
                        protector.recordFailure(ip, username)

                        LogSecurityEvent("FAILED_LOGIN_ATTEMPT", ip,
                                fmt.Sprintf("Failed login attempt for username '%s'", username))
                }</span>
        }
}

// RecordLoginFailure manually records a login failure
func RecordLoginFailure(ip, username string) <span class="cov6" title="14">{
        if globalBruteForceProtector != nil </span><span class="cov6" title="14">{
                globalBruteForceProtector.recordFailure(ip, username)
        }</span>
}

// RecordLoginSuccess manually records a login success
func RecordLoginSuccess(ip, username string) <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                globalBruteForceProtector.recordSuccess(ip, username)
        }</span>
}

// IsBlocked checks if IP or username is currently blocked
func IsBlocked(ip, username string) (bool, string) <span class="cov4" title="5">{
        if globalBruteForceProtector != nil </span><span class="cov4" title="5">{
                allowed, reason, _ := globalBruteForceProtector.checkAttempt(ip, username)
                return !allowed, reason
        }</span>
        <span class="cov0" title="0">return false, ""</span>
}

// UnblockIP unblocks an IP address
func UnblockIP(ip string) <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                globalBruteForceProtector.mu.Lock()
                defer globalBruteForceProtector.mu.Unlock()

                // Delete IP-specific record
                delete(globalBruteForceProtector.ipFailures, ip)

                // Delete all combined IP+username records for this IP
                for key := range globalBruteForceProtector.combinedFailures </span><span class="cov1" title="1">{
                        // Combined key format is "ip:username"
                        if len(key) &gt; len(ip) &amp;&amp; key[:len(ip)] == ip &amp;&amp; key[len(ip)] == ':' </span><span class="cov1" title="1">{
                                delete(globalBruteForceProtector.combinedFailures, key)
                        }</span>
                }
        }
}

// UnblockUsername unblocks a username
func UnblockUsername(username string) <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                globalBruteForceProtector.mu.Lock()
                defer globalBruteForceProtector.mu.Unlock()

                // Delete username-specific record
                delete(globalBruteForceProtector.usernameFailures, username)

                // Delete all combined IP+username records for this username
                for key := range globalBruteForceProtector.combinedFailures </span><span class="cov1" title="1">{
                        // Combined key format is "ip:username"
                        // Find the colon and check if username matches
                        colonIdx := -1
                        for i := range key </span><span class="cov5" title="12">{
                                if key[i] == ':' </span><span class="cov1" title="1">{
                                        colonIdx = i
                                        break</span>
                                }
                        }
                        <span class="cov1" title="1">if colonIdx &gt;= 0 &amp;&amp; colonIdx+1 &lt; len(key) &amp;&amp; key[colonIdx+1:] == username </span><span class="cov1" title="1">{
                                delete(globalBruteForceProtector.combinedFailures, key)
                        }</span>
                }
        }
}

// BruteForceStatistics contains brute force protection statistics
type BruteForceStatistics struct {
        TrackedIPs                  int `json:"tracked_ips"`
        TrackedUsernames            int `json:"tracked_usernames"`
        TrackedCombined             int `json:"tracked_combined"`
        BlockedIPs                  int `json:"blocked_ips"`
        BlockedUsernames            int `json:"blocked_usernames"`
        PermanentlyBlockedIPs       int `json:"permanently_blocked_ips"`
        PermanentlyBlockedUsernames int `json:"permanently_blocked_usernames"`
}

// GetBruteForceStatistics returns brute force protection statistics
func GetBruteForceStatistics() *BruteForceStatistics <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                return globalBruteForceProtector.getStatistics()
        }</span>
        <span class="cov0" title="0">return &amp;BruteForceStatistics{}</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package security

import (
        "crypto/rand"
        "crypto/subtle"
        "encoding/base64"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// CSRFProtectionConfig contains CSRF protection configuration
type CSRFProtectionConfig struct {
        // Token configuration
        TokenLength       int           // Length of CSRF token in bytes (default: 32)
        TokenLifetime     time.Duration // Lifetime of CSRF token (default: 1 hour)
        CookieName        string        // Name of CSRF cookie (default: "csrf_token")
        HeaderName        string        // Name of CSRF header (default: "X-CSRF-Token")
        FormFieldName     string        // Name of form field (default: "csrf_token")

        // Cookie configuration
        CookiePath        string        // Cookie path (default: "/")
        CookieDomain      string        // Cookie domain (default: "")
        CookieSecure      bool          // Secure cookie (HTTPS only, default: true)
        CookieHTTPOnly    bool          // HTTPOnly cookie (default: true)
        CookieSameSite    http.SameSite // SameSite cookie attribute (default: Strict)

        // Protection options
        RequireTokenRefresh bool          // Require token refresh on each request
        EnableDoubleSubmit  bool          // Enable double-submit cookie pattern
        TrustedOrigins      []string      // List of trusted origins
        ExcludePaths        []string      // Paths to exclude from CSRF protection
        ExcludeMethods      []string      // HTTP methods to exclude (default: GET, HEAD, OPTIONS)

        // Error handling
        ErrorHandler      func(*gin.Context) // Custom error handler
        RegenerateOnError bool               // Regenerate token on validation error
}

// DefaultCSRFProtectionConfig returns secure default settings
func DefaultCSRFProtectionConfig() CSRFProtectionConfig <span class="cov4" title="3">{
        return CSRFProtectionConfig{
                TokenLength:         32,
                TokenLifetime:       1 * time.Hour,
                CookieName:          "csrf_token",
                HeaderName:          "X-CSRF-Token",
                FormFieldName:       "csrf_token",
                CookiePath:          "/",
                CookieSecure:        true,
                CookieHTTPOnly:      true,
                CookieSameSite:      http.SameSiteLaxMode,
                RequireTokenRefresh: false,
                EnableDoubleSubmit:  true,
                TrustedOrigins:      []string{},
                ExcludePaths:        []string{},
                ExcludeMethods:      []string{"GET", "HEAD", "OPTIONS"},
                RegenerateOnError:   true,
        }
}</span>

// StrictCSRFProtectionConfig returns very strict CSRF protection settings
func StrictCSRFProtectionConfig() CSRFProtectionConfig <span class="cov0" title="0">{
        cfg := DefaultCSRFProtectionConfig()
        cfg.TokenLifetime = 15 * time.Minute
        cfg.CookieSameSite = http.SameSiteStrictMode
        cfg.RequireTokenRefresh = true
        cfg.RegenerateOnError = true
        return cfg
}</span>

// csrfToken represents a CSRF token with metadata
type csrfToken struct {
        Value      string
        CreatedAt  time.Time
        ExpiresAt  time.Time
        Used       bool
        IPAddress  string
        UserAgent  string
}

// csrfTokenStore manages CSRF tokens
type csrfTokenStore struct {
        tokens    map[string]*csrfToken
        mu        sync.RWMutex
        maxTokens int
}

// newCSRFTokenStore creates a new token store
func newCSRFTokenStore(maxTokens int) *csrfTokenStore <span class="cov6" title="7">{
        store := &amp;csrfTokenStore{
                tokens:    make(map[string]*csrfToken),
                maxTokens: maxTokens,
        }

        // Start cleanup goroutine
        go store.cleanupExpired()

        return store
}</span>

// generateToken generates a new CSRF token
func (store *csrfTokenStore) generateToken(length int, lifetime time.Duration, ip, userAgent string) (*csrfToken, error) <span class="cov10" title="22">{
        // Generate random bytes
        tokenBytes := make([]byte, length)
        if _, err := rand.Read(tokenBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Encode to base64
        <span class="cov10" title="22">tokenValue := base64.URLEncoding.EncodeToString(tokenBytes)

        // Create token
        now := time.Now()
        token := &amp;csrfToken{
                Value:     tokenValue,
                CreatedAt: now,
                ExpiresAt: now.Add(lifetime),
                Used:      false,
                IPAddress: ip,
                UserAgent: userAgent,
        }

        // Store token
        store.mu.Lock()
        defer store.mu.Unlock()

        // Check if we need to cleanup
        if len(store.tokens) &gt;= store.maxTokens </span><span class="cov0" title="0">{
                store.removeOldest()
        }</span>

        <span class="cov10" title="22">store.tokens[tokenValue] = token

        return token, nil</span>
}

// validateToken validates a CSRF token
func (store *csrfTokenStore) validateToken(tokenValue, ip, userAgent string, requireMatch bool) bool <span class="cov7" title="8">{
        store.mu.RLock()
        token, exists := store.tokens[tokenValue]
        store.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check if token is expired
        <span class="cov6" title="7">if time.Now().After(token.ExpiresAt) </span><span class="cov1" title="1">{
                store.removeToken(tokenValue)
                return false
        }</span>

        // Check if token was already used (one-time use)
        <span class="cov6" title="6">if token.Used </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check IP address match if required
        <span class="cov5" title="5">if requireMatch &amp;&amp; token.IPAddress != ip </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check user agent match if required
        <span class="cov5" title="4">if requireMatch &amp;&amp; token.UserAgent != userAgent </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov4" title="3">return true</span>
}

// markTokenUsed marks a token as used
func (store *csrfTokenStore) markTokenUsed(tokenValue string) <span class="cov1" title="1">{
        store.mu.Lock()
        defer store.mu.Unlock()

        if token, exists := store.tokens[tokenValue]; exists </span><span class="cov1" title="1">{
                token.Used = true
        }</span>
}

// removeToken removes a token from the store
func (store *csrfTokenStore) removeToken(tokenValue string) <span class="cov1" title="1">{
        store.mu.Lock()
        defer store.mu.Unlock()
        delete(store.tokens, tokenValue)
}</span>

// removeOldest removes the oldest token
func (store *csrfTokenStore) removeOldest() <span class="cov0" title="0">{
        var oldestKey string
        var oldestTime time.Time

        for key, token := range store.tokens </span><span class="cov0" title="0">{
                if oldestKey == "" || token.CreatedAt.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestKey = key
                        oldestTime = token.CreatedAt
                }</span>
        }

        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(store.tokens, oldestKey)
        }</span>
}

// cleanupExpired removes expired tokens
func (store *csrfTokenStore) cleanupExpired() <span class="cov6" title="7">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                store.mu.Lock()
                now := time.Now()
                for key, token := range store.tokens </span><span class="cov0" title="0">{
                        if now.After(token.ExpiresAt) </span><span class="cov0" title="0">{
                                delete(store.tokens, key)
                        }</span>
                }
                <span class="cov0" title="0">store.mu.Unlock()</span>
        }
}

// getStats returns token store statistics
func (store *csrfTokenStore) getStats() map[string]interface{} <span class="cov1" title="1">{
        store.mu.RLock()
        defer store.mu.RUnlock()

        totalTokens := len(store.tokens)
        usedTokens := 0
        expiredTokens := 0
        now := time.Now()

        for _, token := range store.tokens </span><span class="cov7" title="10">{
                if token.Used </span><span class="cov0" title="0">{
                        usedTokens++
                }</span>
                <span class="cov7" title="10">if now.After(token.ExpiresAt) </span><span class="cov0" title="0">{
                        expiredTokens++
                }</span>
        }

        <span class="cov1" title="1">return map[string]interface{}{
                "total_tokens":   totalTokens,
                "used_tokens":    usedTokens,
                "expired_tokens": expiredTokens,
                "active_tokens":  totalTokens - usedTokens - expiredTokens,
        }</span>
}

// Global token store
var globalCSRFStore = newCSRFTokenStore(10000)

// CSRFProtectionMiddleware creates CSRF protection middleware
func CSRFProtectionMiddleware(cfg CSRFProtectionConfig) gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov5" title="4">{
                // Check if path is excluded
                for _, path := range cfg.ExcludePaths </span><span class="cov0" title="0">{
                        if c.Request.URL.Path == path </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>
                }

                // Check if method is excluded (GET, HEAD, OPTIONS are safe)
                <span class="cov5" title="4">for _, method := range cfg.ExcludeMethods </span><span class="cov7" title="8">{
                        if c.Request.Method == method </span><span class="cov3" title="2">{
                                // Generate and set token for safe methods
                                token, err := generateAndSetCSRFToken(c, cfg)
                                if err != nil </span><span class="cov0" title="0">{
                                        LogSecurityEvent("CSRF_TOKEN_GENERATION_FAILED", c.ClientIP(),
                                                fmt.Sprintf("Failed to generate CSRF token: %v", err))
                                }</span> else<span class="cov3" title="2"> {
                                        // Make token available to response
                                        c.Set("csrf_token", token)
                                }</span>
                                <span class="cov3" title="2">c.Next()
                                return</span>
                        }
                }

                // For state-changing methods (POST, PUT, DELETE, PATCH), validate token
                <span class="cov3" title="2">valid := validateCSRFToken(c, cfg)

                if !valid </span><span class="cov1" title="1">{
                        LogSecurityEvent("CSRF_DETECTED", c.ClientIP(),
                                fmt.Sprintf("CSRF token validation failed for %s %s",
                                        c.Request.Method, c.Request.URL.Path))

                        // Call custom error handler if provided
                        if cfg.ErrorHandler != nil </span><span class="cov0" title="0">{
                                cfg.ErrorHandler(c)
                        }</span> else<span class="cov1" title="1"> {
                                c.JSON(http.StatusForbidden, gin.H{
                                        "error": "CSRF token validation failed",
                                })
                        }</span>

                        <span class="cov1" title="1">c.Abort()
                        return</span>
                }

                // Token is valid, mark as used if one-time use is enabled
                <span class="cov1" title="1">if cfg.RequireTokenRefresh </span><span class="cov0" title="0">{
                        tokenValue := getCSRFTokenFromRequest(c, cfg)
                        globalCSRFStore.markTokenUsed(tokenValue)
                }</span>

                // Generate new token for response
                <span class="cov1" title="1">newToken, err := generateAndSetCSRFToken(c, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        LogSecurityEvent("CSRF_TOKEN_GENERATION_FAILED", c.ClientIP(),
                                fmt.Sprintf("Failed to generate new CSRF token: %v", err))
                }</span> else<span class="cov1" title="1"> {
                        c.Set("csrf_token", newToken)
                }</span>

                <span class="cov1" title="1">c.Next()</span>
        }
}

// generateAndSetCSRFToken generates a new CSRF token and sets it in cookie
func generateAndSetCSRFToken(c *gin.Context, cfg CSRFProtectionConfig) (string, error) <span class="cov4" title="3">{
        ip := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        token, err := globalCSRFStore.generateToken(cfg.TokenLength, cfg.TokenLifetime, ip, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Set cookie
        <span class="cov4" title="3">c.SetCookie(
                cfg.CookieName,
                token.Value,
                int(cfg.TokenLifetime.Seconds()),
                cfg.CookiePath,
                cfg.CookieDomain,
                cfg.CookieSecure,
                cfg.CookieHTTPOnly,
        )

        // Also set SameSite attribute
        // Note: Gin's SetCookie doesn't support SameSite directly,
        // so we need to set it manually
        if cfg.CookieSameSite != http.SameSiteDefaultMode </span><span class="cov4" title="3">{
                sameSite := "Lax"
                if cfg.CookieSameSite == http.SameSiteStrictMode </span><span class="cov0" title="0">{
                        sameSite = "Strict"
                }</span> else<span class="cov4" title="3"> if cfg.CookieSameSite == http.SameSiteNoneMode </span><span class="cov0" title="0">{
                        sameSite = "None"
                }</span>

                <span class="cov4" title="3">cookie := fmt.Sprintf("%s=%s; Path=%s; Max-Age=%d; SameSite=%s",
                        cfg.CookieName, token.Value, cfg.CookiePath,
                        int(cfg.TokenLifetime.Seconds()), sameSite)

                if cfg.CookieSecure </span><span class="cov4" title="3">{
                        cookie += "; Secure"
                }</span>
                <span class="cov4" title="3">if cfg.CookieHTTPOnly </span><span class="cov4" title="3">{
                        cookie += "; HttpOnly"
                }</span>
                <span class="cov4" title="3">if cfg.CookieDomain != "" </span><span class="cov0" title="0">{
                        cookie += fmt.Sprintf("; Domain=%s", cfg.CookieDomain)
                }</span>

                <span class="cov4" title="3">c.Header("Set-Cookie", cookie)</span>
        }

        <span class="cov4" title="3">return token.Value, nil</span>
}

// validateCSRFToken validates the CSRF token from request
func validateCSRFToken(c *gin.Context, cfg CSRFProtectionConfig) bool <span class="cov3" title="2">{
        // Get token from request
        requestToken := getCSRFTokenFromRequest(c, cfg)
        if requestToken == "" </span><span class="cov1" title="1">{
                return false
        }</span>

        // Get token from cookie
        <span class="cov1" title="1">cookieToken, err := c.Cookie(cfg.CookieName)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Double-submit cookie pattern: compare request token with cookie token
        <span class="cov1" title="1">if cfg.EnableDoubleSubmit </span><span class="cov1" title="1">{
                // Use constant-time comparison to prevent timing attacks
                if subtle.ConstantTimeCompare([]byte(requestToken), []byte(cookieToken)) != 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Validate token in store
        <span class="cov1" title="1">ip := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        return globalCSRFStore.validateToken(requestToken, ip, userAgent, true)</span>
}

// getCSRFTokenFromRequest extracts CSRF token from request
func getCSRFTokenFromRequest(c *gin.Context, cfg CSRFProtectionConfig) string <span class="cov3" title="2">{
        // Try header first
        token := c.GetHeader(cfg.HeaderName)
        if token != "" </span><span class="cov1" title="1">{
                return token
        }</span>

        // Try form field
        <span class="cov1" title="1">token = c.PostForm(cfg.FormFieldName)
        if token != "" </span><span class="cov0" title="0">{
                return token
        }</span>

        // Try JSON body
        <span class="cov1" title="1">var body map[string]interface{}
        if err := c.ShouldBindJSON(&amp;body); err == nil </span><span class="cov0" title="0">{
                if tokenValue, ok := body[cfg.FormFieldName].(string); ok </span><span class="cov0" title="0">{
                        return tokenValue
                }</span>
        }

        <span class="cov1" title="1">return ""</span>
}

// GetCSRFToken returns the current CSRF token for the request
func GetCSRFToken(c *gin.Context) string <span class="cov4" title="3">{
        if token, exists := c.Get("csrf_token"); exists </span><span class="cov3" title="2">{
                if tokenStr, ok := token.(string); ok </span><span class="cov3" title="2">{
                        return tokenStr
                }</span>
        }
        <span class="cov1" title="1">return ""</span>
}

// CSRFTokenResponse adds CSRF token to response
func CSRFTokenResponse() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Add CSRF token to response headers
                if token := GetCSRFToken(c); token != "" </span><span class="cov0" title="0">{
                        c.Header("X-CSRF-Token", token)
                }</span>
        }
}

// OriginValidationMiddleware validates the Origin header
func OriginValidationMiddleware(trustedOrigins []string) gin.HandlerFunc <span class="cov0" title="0">{
        trustedMap := make(map[string]bool)
        for _, origin := range trustedOrigins </span><span class="cov0" title="0">{
                trustedMap[origin] = true
        }</span>

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.GetHeader("Origin")
                if origin == "" </span><span class="cov0" title="0">{
                        // No Origin header, allow (might be same-origin request)
                        c.Next()
                        return
                }</span>

                // Check if origin is trusted
                <span class="cov0" title="0">if !trustedMap[origin] </span><span class="cov0" title="0">{
                        LogSecurityEvent("UNTRUSTED_ORIGIN", c.ClientIP(),
                                fmt.Sprintf("Request from untrusted origin: %s", origin))

                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Untrusted origin",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RefererValidationMiddleware validates the Referer header
func RefererValidationMiddleware(trustedDomains []string) gin.HandlerFunc <span class="cov0" title="0">{
        trustedMap := make(map[string]bool)
        for _, domain := range trustedDomains </span><span class="cov0" title="0">{
                trustedMap[domain] = true
        }</span>

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                referer := c.GetHeader("Referer")
                if referer == "" </span><span class="cov0" title="0">{
                        // No Referer header for state-changing methods
                        if c.Request.Method != "GET" &amp;&amp; c.Request.Method != "HEAD" &amp;&amp; c.Request.Method != "OPTIONS" </span><span class="cov0" title="0">{
                                LogSecurityEvent("MISSING_REFERER", c.ClientIP(),
                                        fmt.Sprintf("State-changing request without Referer: %s %s",
                                                c.Request.Method, c.Request.URL.Path))

                                c.JSON(http.StatusForbidden, gin.H{
                                        "error": "Missing Referer header",
                                })
                                c.Abort()
                                return
                        }</span>
                        <span class="cov0" title="0">c.Next()
                        return</span>
                }

                // Extract domain from referer
                // Simple validation - can be enhanced
                <span class="cov0" title="0">trusted := false
                for domain := range trustedMap </span><span class="cov0" title="0">{
                        if len(referer) &gt;= len(domain) &amp;&amp; referer[:len(domain)] == domain </span><span class="cov0" title="0">{
                                trusted = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !trusted </span><span class="cov0" title="0">{
                        LogSecurityEvent("UNTRUSTED_REFERER", c.ClientIP(),
                                fmt.Sprintf("Request from untrusted referer: %s", referer))

                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Untrusted referer",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// CSRFStatistics contains CSRF protection statistics
type CSRFStatistics struct {
        TotalTokens       int `json:"total_tokens"`
        ActiveTokens      int `json:"active_tokens"`
        UsedTokens        int `json:"used_tokens"`
        ExpiredTokens     int `json:"expired_tokens"`
        ValidationsFailed int `json:"validations_failed"`
        ValidationsSucceeded int `json:"validations_succeeded"`
}

// GetCSRFStatistics returns CSRF protection statistics
func GetCSRFStatistics() *CSRFStatistics <span class="cov1" title="1">{
        stats := globalCSRFStore.getStats()

        return &amp;CSRFStatistics{
                TotalTokens:   stats["total_tokens"].(int),
                ActiveTokens:  stats["active_tokens"].(int),
                UsedTokens:    stats["used_tokens"].(int),
                ExpiredTokens: stats["expired_tokens"].(int),
        }
}</span>

// ClearExpiredCSRFTokens manually clears expired tokens
func ClearExpiredCSRFTokens() int <span class="cov1" title="1">{
        globalCSRFStore.mu.Lock()
        defer globalCSRFStore.mu.Unlock()

        count := 0
        now := time.Now()

        for key, token := range globalCSRFStore.tokens </span><span class="cov5" title="5">{
                if now.After(token.ExpiresAt) </span><span class="cov5" title="5">{
                        delete(globalCSRFStore.tokens, key)
                        count++
                }</span>
        }

        <span class="cov1" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package security

import (
        "net"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// DDoSProtectionConfig contains DDoS protection configuration
type DDoSProtectionConfig struct {
        // Rate limiting (per IP)
        MaxRequestsPerSecond  int           // Maximum requests per second per IP
        MaxRequestsPerMinute  int           // Maximum requests per minute per IP
        MaxRequestsPerHour    int           // Maximum requests per hour per IP
        BurstSize             int           // Maximum burst size

        // Connection limits
        MaxConcurrentPerIP    int           // Maximum concurrent connections per IP
        MaxTotalConcurrent    int           // Maximum total concurrent connections

        // Request size limits
        MaxRequestSize        int64         // Maximum request size in bytes
        MaxHeaderSize         int           // Maximum header size in bytes
        MaxURILength          int           // Maximum URI length

        // Timeouts
        RequestTimeout        time.Duration // Maximum request processing time
        SlowlorisTimeout      time.Duration // Timeout for slow requests (Slowloris attack)
        ReadTimeout           time.Duration // Read timeout
        WriteTimeout          time.Duration // Write timeout

        // Protection features
        EnableIPBlocking      bool          // Enable automatic IP blocking
        BlockDuration         time.Duration // Duration to block IP
        SuspiciousThreshold   int           // Requests before marking as suspicious
        BanThreshold          int           // Failed attempts before banning

        // Cleanup
        CleanupInterval       time.Duration // Cleanup interval for old entries
}

// DefaultDDoSProtectionConfig returns secure default settings
func DefaultDDoSProtectionConfig() DDoSProtectionConfig <span class="cov5" title="9">{
        return DDoSProtectionConfig{
                // Rate limiting
                MaxRequestsPerSecond: 100,              // 100 req/sec per IP
                MaxRequestsPerMinute: 3000,             // 3000 req/min per IP
                MaxRequestsPerHour:   50000,            // 50k req/hour per IP
                BurstSize:            200,              // Allow short bursts

                // Connection limits
                MaxConcurrentPerIP:   50,               // 50 concurrent per IP
                MaxTotalConcurrent:   10000,            // 10k total concurrent

                // Request size limits
                MaxRequestSize:       10 * 1024 * 1024, // 10MB max request
                MaxHeaderSize:        8192,             // 8KB max headers
                MaxURILength:         4096,             // 4KB max URI

                // Timeouts
                RequestTimeout:       30 * time.Second,
                SlowlorisTimeout:     10 * time.Second,
                ReadTimeout:          10 * time.Second,
                WriteTimeout:         10 * time.Second,

                // Protection
                EnableIPBlocking:     true,
                BlockDuration:        15 * time.Minute, // Block for 15 minutes
                SuspiciousThreshold:  500,              // 500 req/sec is suspicious
                BanThreshold:         10,               // 10 failed attempts = ban

                // Cleanup
                CleanupInterval:      1 * time.Minute,
        }
}</span>

// ipStats tracks statistics for an IP address
type ipStats struct {
        // Request counts
        requestsLastSecond   int
        requestsLastMinute   int
        requestsLastHour     int
        lastSecond           time.Time
        lastMinute           time.Time
        lastHour             time.Time

        // Connection tracking
        concurrentRequests   int

        // Blocking
        blocked              bool
        blockExpiry          time.Time
        failedAttempts       int
        suspiciousActivity   bool

        // Timing
        lastRequest          time.Time
        firstRequest         time.Time

        mu                   sync.RWMutex
}

// ddosProtector implements DDoS protection
type ddosProtector struct {
        config              DDoSProtectionConfig
        ipStats             map[string]*ipStats
        ipStatsMu           sync.RWMutex

        // Global statistics
        totalConcurrent     int
        totalConcurrentMu   sync.RWMutex

        // Blocked IPs
        blockedIPs          map[string]time.Time
        blockedIPsMu        sync.RWMutex

        // Whitelisted IPs
        whitelistedIPs      map[string]bool
        whitelistedIPsMu    sync.RWMutex

        // Cleanup
        stopCleanup         chan struct{}
        cleanupDone         sync.WaitGroup
}

// newDDoSProtector creates a new DDoS protector
func newDDoSProtector(cfg DDoSProtectionConfig) *ddosProtector <span class="cov6" title="10">{
        dp := &amp;ddosProtector{
                config:         cfg,
                ipStats:        make(map[string]*ipStats),
                blockedIPs:     make(map[string]time.Time),
                whitelistedIPs: make(map[string]bool),
                stopCleanup:    make(chan struct{}),
        }

        // Start background cleanup
        dp.cleanupDone.Add(1)
        go dp.cleanupLoop()

        return dp
}</span>

// checkRequest checks if a request should be allowed
func (dp *ddosProtector) checkRequest(ip string) (allowed bool, reason string) <span class="cov10" title="61">{
        // Check if IP is whitelisted
        dp.whitelistedIPsMu.RLock()
        if dp.whitelistedIPs[ip] </span><span class="cov7" title="20">{
                dp.whitelistedIPsMu.RUnlock()
                return true, ""
        }</span>
        <span class="cov9" title="41">dp.whitelistedIPsMu.RUnlock()

        // Check if IP is blocked
        dp.blockedIPsMu.RLock()
        if blockExpiry, blocked := dp.blockedIPs[ip]; blocked </span><span class="cov2" title="2">{
                if time.Now().Before(blockExpiry) </span><span class="cov1" title="1">{
                        dp.blockedIPsMu.RUnlock()
                        return false, "IP address is blocked"
                }</span>
                // Block expired, remove it
                <span class="cov1" title="1">dp.blockedIPsMu.RUnlock()
                dp.blockedIPsMu.Lock()
                delete(dp.blockedIPs, ip)
                dp.blockedIPsMu.Unlock()</span>
        } else<span class="cov9" title="39"> {
                dp.blockedIPsMu.RUnlock()
        }</span>

        // Check global concurrent limit
        <span class="cov9" title="40">dp.totalConcurrentMu.RLock()
        if dp.totalConcurrent &gt;= dp.config.MaxTotalConcurrent </span><span class="cov0" title="0">{
                dp.totalConcurrentMu.RUnlock()
                return false, "Server at maximum capacity"
        }</span>
        <span class="cov9" title="40">dp.totalConcurrentMu.RUnlock()

        // Get or create IP stats
        stats := dp.getOrCreateIPStats(ip)
        stats.mu.Lock()
        defer stats.mu.Unlock()

        now := time.Now()

        // Check if IP is blocked
        if stats.blocked &amp;&amp; now.Before(stats.blockExpiry) </span><span class="cov0" title="0">{
                return false, "IP address is temporarily blocked"
        }</span>
        <span class="cov9" title="40">if stats.blocked &amp;&amp; now.After(stats.blockExpiry) </span><span class="cov0" title="0">{
                stats.blocked = false
                stats.failedAttempts = 0
        }</span>

        // Update rate counters
        <span class="cov9" title="40">if now.Sub(stats.lastSecond) &gt;= time.Second </span><span class="cov0" title="0">{
                stats.requestsLastSecond = 0
                stats.lastSecond = now
        }</span>
        <span class="cov9" title="40">if now.Sub(stats.lastMinute) &gt;= time.Minute </span><span class="cov0" title="0">{
                stats.requestsLastMinute = 0
                stats.lastMinute = now
        }</span>
        <span class="cov9" title="40">if now.Sub(stats.lastHour) &gt;= time.Hour </span><span class="cov0" title="0">{
                stats.requestsLastHour = 0
                stats.lastHour = now
        }</span>

        // Check rate limits
        <span class="cov9" title="40">if stats.requestsLastSecond &gt;= dp.config.MaxRequestsPerSecond </span><span class="cov4" title="6">{
                stats.suspiciousActivity = true
                if stats.requestsLastSecond &gt;= dp.config.SuspiciousThreshold </span><span class="cov0" title="0">{
                        dp.blockIP(ip, "Excessive requests per second")
                        return false, "Rate limit exceeded - IP blocked"
                }</span>
                <span class="cov4" title="6">return false, "Rate limit exceeded (per second)"</span>
        }

        <span class="cov8" title="34">if stats.requestsLastMinute &gt;= dp.config.MaxRequestsPerMinute </span><span class="cov0" title="0">{
                return false, "Rate limit exceeded (per minute)"
        }</span>

        <span class="cov8" title="34">if stats.requestsLastHour &gt;= dp.config.MaxRequestsPerHour </span><span class="cov0" title="0">{
                return false, "Rate limit exceeded (per hour)"
        }</span>

        // Check concurrent connections
        <span class="cov8" title="34">if stats.concurrentRequests &gt;= dp.config.MaxConcurrentPerIP </span><span class="cov1" title="1">{
                return false, "Too many concurrent connections"
        }</span>

        // Increment counters
        <span class="cov8" title="33">stats.requestsLastSecond++
        stats.requestsLastMinute++
        stats.requestsLastHour++
        stats.concurrentRequests++
        stats.lastRequest = now

        if stats.firstRequest.IsZero() </span><span class="cov7" title="20">{
                stats.firstRequest = now
        }</span>

        // Increment global counter
        <span class="cov8" title="33">dp.totalConcurrentMu.Lock()
        dp.totalConcurrent++
        dp.totalConcurrentMu.Unlock()

        return true, ""</span>
}

// releaseRequest releases a concurrent request slot
func (dp *ddosProtector) releaseRequest(ip string) <span class="cov5" title="9">{
        stats := dp.getIPStats(ip)
        if stats != nil </span><span class="cov5" title="9">{
                stats.mu.Lock()
                if stats.concurrentRequests &gt; 0 </span><span class="cov5" title="9">{
                        stats.concurrentRequests--
                }</span>
                <span class="cov5" title="9">stats.mu.Unlock()</span>
        }

        <span class="cov5" title="9">dp.totalConcurrentMu.Lock()
        if dp.totalConcurrent &gt; 0 </span><span class="cov5" title="9">{
                dp.totalConcurrent--
        }</span>
        <span class="cov5" title="9">dp.totalConcurrentMu.Unlock()</span>
}

// blockIP blocks an IP address
func (dp *ddosProtector) blockIP(ip, reason string) <span class="cov2" title="2">{
        if !dp.config.EnableIPBlocking </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">stats := dp.getIPStats(ip)
        if stats != nil </span><span class="cov0" title="0">{
                stats.mu.Lock()
                stats.blocked = true
                stats.blockExpiry = time.Now().Add(dp.config.BlockDuration)
                stats.failedAttempts++
                stats.mu.Unlock()
        }</span>

        <span class="cov2" title="2">dp.blockedIPsMu.Lock()
        dp.blockedIPs[ip] = time.Now().Add(dp.config.BlockDuration)
        dp.blockedIPsMu.Unlock()

        LogSecurityEvent("IP_BLOCKED", ip, reason)</span>
}

// whitelistIP adds an IP to whitelist
func (dp *ddosProtector) whitelistIP(ip string) <span class="cov2" title="2">{
        dp.whitelistedIPsMu.Lock()
        dp.whitelistedIPs[ip] = true
        dp.whitelistedIPsMu.Unlock()
}</span>

// removeWhitelistIP removes an IP from whitelist
func (dp *ddosProtector) removeWhitelistIP(ip string) <span class="cov0" title="0">{
        dp.whitelistedIPsMu.Lock()
        delete(dp.whitelistedIPs, ip)
        dp.whitelistedIPsMu.Unlock()
}</span>

// unblockIP unblocks an IP address
func (dp *ddosProtector) unblockIP(ip string) <span class="cov0" title="0">{
        stats := dp.getIPStats(ip)
        if stats != nil </span><span class="cov0" title="0">{
                stats.mu.Lock()
                stats.blocked = false
                stats.failedAttempts = 0
                stats.mu.Unlock()
        }</span>

        <span class="cov0" title="0">dp.blockedIPsMu.Lock()
        delete(dp.blockedIPs, ip)
        dp.blockedIPsMu.Unlock()</span>
}

// getOrCreateIPStats gets or creates IP statistics
func (dp *ddosProtector) getOrCreateIPStats(ip string) *ipStats <span class="cov9" title="40">{
        dp.ipStatsMu.RLock()
        stats, exists := dp.ipStats[ip]
        dp.ipStatsMu.RUnlock()

        if exists </span><span class="cov7" title="20">{
                return stats
        }</span>

        <span class="cov7" title="20">dp.ipStatsMu.Lock()
        // Double-check after acquiring write lock
        stats, exists = dp.ipStats[ip]
        if !exists </span><span class="cov7" title="20">{
                stats = &amp;ipStats{
                        lastSecond: time.Now(),
                        lastMinute: time.Now(),
                        lastHour:   time.Now(),
                }
                dp.ipStats[ip] = stats
        }</span>
        <span class="cov7" title="20">dp.ipStatsMu.Unlock()

        return stats</span>
}

// getIPStats gets IP statistics if they exist
func (dp *ddosProtector) getIPStats(ip string) *ipStats <span class="cov6" title="11">{
        dp.ipStatsMu.RLock()
        defer dp.ipStatsMu.RUnlock()
        return dp.ipStats[ip]
}</span>

// cleanupLoop runs background cleanup
func (dp *ddosProtector) cleanupLoop() <span class="cov6" title="10">{
        defer dp.cleanupDone.Done()

        ticker := time.NewTicker(dp.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov6" title="11">{
                select </span>{
                case &lt;-ticker.C:<span class="cov1" title="1">
                        dp.cleanup()</span>
                case &lt;-dp.stopCleanup:<span class="cov4" title="6">
                        return</span>
                }
        }
}

// cleanup removes old entries
func (dp *ddosProtector) cleanup() <span class="cov1" title="1">{
        now := time.Now()

        // Cleanup IP stats
        dp.ipStatsMu.Lock()
        for ip, stats := range dp.ipStats </span><span class="cov6" title="10">{
                stats.mu.RLock()
                inactive := now.Sub(stats.lastRequest) &gt; 5*time.Minute
                stats.mu.RUnlock()

                if inactive </span><span class="cov0" title="0">{
                        delete(dp.ipStats, ip)
                }</span>
        }
        <span class="cov1" title="1">dp.ipStatsMu.Unlock()

        // Cleanup expired blocks
        dp.blockedIPsMu.Lock()
        for ip, expiry := range dp.blockedIPs </span><span class="cov0" title="0">{
                if now.After(expiry) </span><span class="cov0" title="0">{
                        delete(dp.blockedIPs, ip)
                }</span>
        }
        <span class="cov1" title="1">dp.blockedIPsMu.Unlock()</span>
}

// close stops the DDoS protector
func (dp *ddosProtector) close() <span class="cov4" title="6">{
        close(dp.stopCleanup)
        dp.cleanupDone.Wait()
}</span>

// DDoSProtectionMiddleware creates DDoS protection middleware
func DDoSProtectionMiddleware(cfg DDoSProtectionConfig) gin.HandlerFunc <span class="cov4" title="4">{
        protector := newDDoSProtector(cfg)

        return func(c *gin.Context) </span><span class="cov6" title="15">{
                // Get client IP
                ip := c.ClientIP()

                // Check request size
                if c.Request.ContentLength &gt; cfg.MaxRequestSize </span><span class="cov1" title="1">{
                        LogSecurityEvent("REQUEST_TOO_LARGE", ip, "Request size exceeded limit")
                        c.JSON(http.StatusRequestEntityTooLarge, gin.H{
                                "error": "Request entity too large",
                        })
                        c.Abort()
                        return
                }</span>

                // Check URI length
                <span class="cov6" title="14">if len(c.Request.RequestURI) &gt; cfg.MaxURILength </span><span class="cov1" title="1">{
                        LogSecurityEvent("URI_TOO_LONG", ip, "URI length exceeded limit")
                        c.JSON(http.StatusRequestURITooLong, gin.H{
                                "error": "Request URI too long",
                        })
                        c.Abort()
                        return
                }</span>

                // Check if request should be allowed
                <span class="cov6" title="13">allowed, reason := protector.checkRequest(ip)
                if !allowed </span><span class="cov4" title="5">{
                        LogSecurityEvent("REQUEST_BLOCKED", ip, reason)
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": reason,
                                "retry_after": cfg.BlockDuration.String(),
                        })
                        c.Abort()
                        return
                }</span>

                // Process request
                <span class="cov5" title="8">c.Next()

                // Release concurrent request slot
                protector.releaseRequest(ip)

                // Check for failed authentication (401, 403)
                if c.Writer.Status() == http.StatusUnauthorized || c.Writer.Status() == http.StatusForbidden </span><span class="cov0" title="0">{
                        stats := protector.getIPStats(ip)
                        if stats != nil </span><span class="cov0" title="0">{
                                stats.mu.Lock()
                                stats.failedAttempts++
                                if stats.failedAttempts &gt;= cfg.BanThreshold </span><span class="cov0" title="0">{
                                        protector.blockIP(ip, "Too many failed authentication attempts")
                                }</span>
                                <span class="cov0" title="0">stats.mu.Unlock()</span>
                        }
                }
        }
}

// extractIPFromContext extracts IP address from request
func extractIPFromContext(c *gin.Context) string <span class="cov3" title="3">{
        // Try X-Forwarded-For header first
        forwarded := c.GetHeader("X-Forwarded-For")
        if forwarded != "" </span><span class="cov1" title="1">{
                // Take first IP in the list
                if ip := net.ParseIP(forwarded); ip != nil </span><span class="cov1" title="1">{
                        return ip.String()
                }</span>
        }

        // Try X-Real-IP header
        <span class="cov2" title="2">realIP := c.GetHeader("X-Real-IP")
        if realIP != "" </span><span class="cov1" title="1">{
                if ip := net.ParseIP(realIP); ip != nil </span><span class="cov1" title="1">{
                        return ip.String()
                }</span>
        }

        // Fall back to RemoteAddr
        <span class="cov1" title="1">ip, _, _ := net.SplitHostPort(c.Request.RemoteAddr)
        return ip</span>
}

// DDoSStatistics contains DDoS protection statistics
type DDoSStatistics struct {
        TotalRequests     int64
        BlockedRequests   int64
        BlockedIPs        int
        WhitelistedIPs    int
        ActiveConnections int
        TrackedIPs        int
}

// GetStatistics returns DDoS protection statistics
func (dp *ddosProtector) GetStatistics() *DDoSStatistics <span class="cov1" title="1">{
        dp.ipStatsMu.RLock()
        trackedIPs := len(dp.ipStats)
        dp.ipStatsMu.RUnlock()

        dp.blockedIPsMu.RLock()
        blockedIPs := len(dp.blockedIPs)
        dp.blockedIPsMu.RUnlock()

        dp.whitelistedIPsMu.RLock()
        whitelistedIPs := len(dp.whitelistedIPs)
        dp.whitelistedIPsMu.RUnlock()

        dp.totalConcurrentMu.RLock()
        activeConnections := dp.totalConcurrent
        dp.totalConcurrentMu.RUnlock()

        return &amp;DDoSStatistics{
                TrackedIPs:        trackedIPs,
                BlockedIPs:        blockedIPs,
                WhitelistedIPs:    whitelistedIPs,
                ActiveConnections: activeConnections,
        }
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package security

import (
        "fmt"
        "html"
        "net/http"
        "regexp"
        "strings"
        "unicode"

        "github.com/gin-gonic/gin"
)

// InputValidationConfig contains input validation configuration
type InputValidationConfig struct {
        // SQL Injection Protection
        EnableSQLInjectionCheck   bool
        BlockSQLKeywords          bool

        // XSS Protection
        EnableXSSCheck            bool
        SanitizeHTML              bool
        AllowedHTMLTags           []string

        // Path Traversal Protection
        EnablePathTraversalCheck  bool

        // Command Injection Protection
        EnableCommandInjectionCheck bool

        // LDAP Injection Protection
        EnableLDAPInjectionCheck  bool

        // Max lengths
        MaxStringLength           int
        MaxArrayLength            int
        MaxJSONDepth              int

        // Character restrictions
        AllowUnicode              bool
        AllowSpecialChars         bool
        AllowedSpecialChars       string
}

// DefaultInputValidationConfig returns secure default settings
func DefaultInputValidationConfig() InputValidationConfig <span class="cov3" title="4">{
        return InputValidationConfig{
                EnableSQLInjectionCheck:     true,
                BlockSQLKeywords:            true,
                EnableXSSCheck:              true,
                SanitizeHTML:                true,
                AllowedHTMLTags:             []string{}, // No HTML allowed by default
                EnablePathTraversalCheck:    true,
                EnableCommandInjectionCheck: true,
                EnableLDAPInjectionCheck:    true,
                MaxStringLength:             10000,
                MaxArrayLength:              1000,
                MaxJSONDepth:                10,
                AllowUnicode:                true,
                AllowSpecialChars:           true,
                AllowedSpecialChars:         "!@#$%^&amp;*()_+-=[]{}|;:',.&lt;&gt;?/~` ",
        }
}</span>

// SQL injection patterns
var sqlInjectionPatterns = []*regexp.Regexp{
        regexp.MustCompile(`(?i)(union.*select)`),
        regexp.MustCompile(`(?i)(select.*from)`),
        regexp.MustCompile(`(?i)(insert.*into)`),
        regexp.MustCompile(`(?i)(delete.*from)`),
        regexp.MustCompile(`(?i)(drop.*table)`),
        regexp.MustCompile(`(?i)(update.*set)`),
        regexp.MustCompile(`(?i)(exec(ute)?)`),
        regexp.MustCompile(`(?i)(--)`),
        regexp.MustCompile(`(?i)(;.*--)`),
        regexp.MustCompile(`(?i)('.*or.*'.*=.*')`),
        regexp.MustCompile(`(?i)(or.*1.*=.*1)`),
        regexp.MustCompile(`(?i)(and.*1.*=.*1)`),
        regexp.MustCompile(`(?i)(having)`),
        regexp.MustCompile(`(?i)(group.*by)`),
        regexp.MustCompile(`(?i)(order.*by)`),
        regexp.MustCompile(`(?i)(waitfor.*delay)`),
        regexp.MustCompile(`(?i)(benchmark)`),
        regexp.MustCompile(`(?i)(sleep\()`),
}

// XSS patterns
var xssPatterns = []*regexp.Regexp{
        regexp.MustCompile(`(?i)&lt;script`),
        regexp.MustCompile(`(?i)&lt;/script&gt;`),
        regexp.MustCompile(`(?i)javascript:`),
        regexp.MustCompile(`(?i)onerror\s*=`),
        regexp.MustCompile(`(?i)onload\s*=`),
        regexp.MustCompile(`(?i)onclick\s*=`),
        regexp.MustCompile(`(?i)onmouseover\s*=`),
        regexp.MustCompile(`(?i)&lt;iframe`),
        regexp.MustCompile(`(?i)&lt;object`),
        regexp.MustCompile(`(?i)&lt;embed`),
        regexp.MustCompile(`(?i)&lt;img.*src`),
        regexp.MustCompile(`(?i)eval\(`),
        regexp.MustCompile(`(?i)expression\(`),
        regexp.MustCompile(`(?i)vbscript:`),
        regexp.MustCompile(`(?i)data:text/html`),
}

// Path traversal patterns
var pathTraversalPatterns = []*regexp.Regexp{
        regexp.MustCompile(`\.\.\/`),
        regexp.MustCompile(`\.\.\\`),
        regexp.MustCompile(`%2e%2e%2f`),
        regexp.MustCompile(`%2e%2e\\`),
        regexp.MustCompile(`\.\.%2f`),
        regexp.MustCompile(`\.\.%5c`),
}

// Command injection patterns
var commandInjectionPatterns = []*regexp.Regexp{
        regexp.MustCompile(`[;&amp;|]`),
        regexp.MustCompile(`\$\(`),
        regexp.MustCompile("`.*`"),
        regexp.MustCompile(`&gt;\s*/dev/null`),
        regexp.MustCompile(`&amp;&amp;`),
        regexp.MustCompile(`\|\|`),
}

// LDAP injection patterns
var ldapInjectionPatterns = []*regexp.Regexp{
        regexp.MustCompile(`\*`),
        regexp.MustCompile(`\(\)`),
        regexp.MustCompile(`\|\|`),
        regexp.MustCompile(`&amp;&amp;`),
}

// ValidateString validates a string input
func ValidateString(input string, cfg InputValidationConfig) (valid bool, sanitized string, reason string) <span class="cov5" title="18">{
        // Check length
        if len(input) &gt; cfg.MaxStringLength </span><span class="cov1" title="1">{
                return false, "", fmt.Sprintf("String exceeds maximum length of %d", cfg.MaxStringLength)
        }</span>

        // Check for SQL injection
        <span class="cov5" title="17">if cfg.EnableSQLInjectionCheck </span><span class="cov5" title="17">{
                for _, pattern := range sqlInjectionPatterns </span><span class="cov10" title="251">{
                        if pattern.MatchString(input) </span><span class="cov3" title="4">{
                                return false, "", "Potential SQL injection detected"
                        }</span>
                }
        }

        // Check for XSS
        <span class="cov5" title="13">if cfg.EnableXSSCheck </span><span class="cov5" title="13">{
                for _, pattern := range xssPatterns </span><span class="cov9" title="144">{
                        if pattern.MatchString(input) </span><span class="cov3" title="4">{
                                return false, "", "Potential XSS attack detected"
                        }</span>
                }
        }

        // Check for path traversal
        <span class="cov4" title="9">if cfg.EnablePathTraversalCheck </span><span class="cov4" title="9">{
                for _, pattern := range pathTraversalPatterns </span><span class="cov7" title="46">{
                        if pattern.MatchString(input) </span><span class="cov2" title="2">{
                                return false, "", "Potential path traversal detected"
                        }</span>
                }
        }

        // Check for command injection
        <span class="cov4" title="7">if cfg.EnableCommandInjectionCheck </span><span class="cov4" title="7">{
                for _, pattern := range commandInjectionPatterns </span><span class="cov6" title="29">{
                        if pattern.MatchString(input) </span><span class="cov2" title="3">{
                                return false, "", "Potential command injection detected"
                        }</span>
                }
        }

        // Check for LDAP injection
        <span class="cov3" title="4">if cfg.EnableLDAPInjectionCheck </span><span class="cov3" title="4">{
                for _, pattern := range ldapInjectionPatterns </span><span class="cov5" title="13">{
                        if pattern.MatchString(input) </span><span class="cov1" title="1">{
                                return false, "", "Potential LDAP injection detected"
                        }</span>
                }
        }

        // Sanitize HTML if enabled
        <span class="cov2" title="3">sanitized = input
        if cfg.SanitizeHTML </span><span class="cov2" title="3">{
                sanitized = html.EscapeString(input)
        }</span>

        // Check character restrictions
        <span class="cov2" title="3">if !cfg.AllowUnicode || !cfg.AllowSpecialChars </span><span class="cov0" title="0">{
                for _, r := range input </span><span class="cov0" title="0">{
                        if !cfg.AllowUnicode &amp;&amp; r &gt; unicode.MaxASCII </span><span class="cov0" title="0">{
                                return false, "", "Unicode characters not allowed"
                        }</span>

                        <span class="cov0" title="0">if !cfg.AllowSpecialChars </span><span class="cov0" title="0">{
                                if !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r) &amp;&amp; r != ' ' </span><span class="cov0" title="0">{
                                        if !strings.ContainsRune(cfg.AllowedSpecialChars, r) </span><span class="cov0" title="0">{
                                                return false, "", fmt.Sprintf("Special character not allowed: %c", r)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov2" title="3">return true, sanitized, ""</span>
}

// SanitizeInput sanitizes input by removing dangerous characters
func SanitizeInput(input string) string <span class="cov2" title="3">{
        // Remove null bytes
        input = strings.ReplaceAll(input, "\x00", "")

        // Trim whitespace
        input = strings.TrimSpace(input)

        // Escape HTML
        input = html.EscapeString(input)

        return input
}</span>

// SanitizeFilename sanitizes a filename
func SanitizeFilename(filename string) string <span class="cov3" title="4">{
        // Remove path separators
        filename = strings.ReplaceAll(filename, "/", "")
        filename = strings.ReplaceAll(filename, "\\", "")

        // Remove null bytes
        filename = strings.ReplaceAll(filename, "\x00", "")

        // Remove dangerous characters
        dangerousChars := []string{"&lt;", "&gt;", ":", "\"", "|", "?", "*"}
        for _, char := range dangerousChars </span><span class="cov6" title="28">{
                filename = strings.ReplaceAll(filename, char, "")
        }</span>

        // Remove leading dots (path traversal sequences)
        <span class="cov3" title="4">filename = strings.TrimLeft(filename, ".")

        return filename</span>
}

// SanitizeURL sanitizes a URL
func SanitizeURL(url string) (string, error) <span class="cov3" title="5">{
        // Check for javascript: protocol
        if strings.HasPrefix(strings.ToLower(url), "javascript:") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("javascript: protocol not allowed")
        }</span>

        // Check for data: protocol
        <span class="cov3" title="4">if strings.HasPrefix(strings.ToLower(url), "data:") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("data: protocol not allowed")
        }</span>

        // Only allow http: and https:
        <span class="cov2" title="3">if !strings.HasPrefix(strings.ToLower(url), "http://") &amp;&amp;
                !strings.HasPrefix(strings.ToLower(url), "https://") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("only http: and https: protocols allowed")
        }</span>

        <span class="cov2" title="2">return url, nil</span>
}

// ValidateEmail validates an email address
func ValidateEmail(email string) bool <span class="cov4" title="7">{
        emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
        return emailRegex.MatchString(email)
}</span>

// ValidateUsername validates a username
func ValidateUsername(username string) (bool, string) <span class="cov3" title="6">{
        if len(username) &lt; 3 </span><span class="cov1" title="1">{
                return false, "Username must be at least 3 characters"
        }</span>
        <span class="cov3" title="5">if len(username) &gt; 50 </span><span class="cov1" title="1">{
                return false, "Username must be at most 50 characters"
        }</span>

        // Allow only alphanumeric and underscore
        <span class="cov3" title="4">usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
        if !usernameRegex.MatchString(username) </span><span class="cov2" title="2">{
                return false, "Username can only contain letters, numbers, and underscores"
        }</span>

        <span class="cov2" title="2">return true, ""</span>
}

// ValidatePassword validates a password
func ValidatePassword(password string) (bool, string) <span class="cov4" title="7">{
        if len(password) &lt; 8 </span><span class="cov1" title="1">{
                return false, "Password must be at least 8 characters"
        }</span>
        <span class="cov3" title="6">if len(password) &gt; 128 </span><span class="cov0" title="0">{
                return false, "Password must be at most 128 characters"
        }</span>

        // Check for at least one uppercase, one lowercase, one digit
        <span class="cov3" title="6">hasUpper := false
        hasLower := false
        hasDigit := false
        hasSpecial := false

        for _, r := range password </span><span class="cov7" title="70">{
                if unicode.IsUpper(r) </span><span class="cov5" title="13">{
                        hasUpper = true
                }</span>
                <span class="cov7" title="70">if unicode.IsLower(r) </span><span class="cov6" title="35">{
                        hasLower = true
                }</span>
                <span class="cov7" title="70">if unicode.IsDigit(r) </span><span class="cov5" title="17">{
                        hasDigit = true
                }</span>
                <span class="cov7" title="70">if !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r) </span><span class="cov3" title="5">{
                        hasSpecial = true
                }</span>
        }

        <span class="cov3" title="6">if !hasUpper </span><span class="cov1" title="1">{
                return false, "Password must contain at least one uppercase letter"
        }</span>
        <span class="cov3" title="5">if !hasLower </span><span class="cov1" title="1">{
                return false, "Password must contain at least one lowercase letter"
        }</span>
        <span class="cov3" title="4">if !hasDigit </span><span class="cov1" title="1">{
                return false, "Password must contain at least one digit"
        }</span>
        <span class="cov2" title="3">if !hasSpecial </span><span class="cov1" title="1">{
                return false, "Password must contain at least one special character"
        }</span>

        <span class="cov2" title="2">return true, ""</span>
}

// InputValidationMiddleware creates input validation middleware
func InputValidationMiddleware(cfg InputValidationConfig) gin.HandlerFunc <span class="cov2" title="3">{
        return func(c *gin.Context) </span><span class="cov2" title="3">{
                // Validate query parameters
                for key, values := range c.Request.URL.Query() </span><span class="cov3" title="4">{
                        for _, value := range values </span><span class="cov3" title="4">{
                                valid, _, reason := ValidateString(value, cfg)
                                if !valid </span><span class="cov2" title="2">{
                                        LogSecurityEvent("INVALID_INPUT", c.ClientIP(),
                                                fmt.Sprintf("Invalid query parameter %s: %s", key, reason))
                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "error": "Invalid input detected",
                                        })
                                        c.Abort()
                                        return
                                }</span>
                        }
                }

                // Validate headers
                <span class="cov1" title="1">suspiciousHeaders := []string{
                        "X-Forwarded-Host",
                        "X-Original-URL",
                        "X-Rewrite-URL",
                }

                for _, header := range suspiciousHeaders </span><span class="cov2" title="3">{
                        if value := c.GetHeader(header); value != "" </span><span class="cov0" title="0">{
                                valid, _, reason := ValidateString(value, cfg)
                                if !valid </span><span class="cov0" title="0">{
                                        LogSecurityEvent("INVALID_INPUT", c.ClientIP(),
                                                fmt.Sprintf("Invalid header %s: %s", header, reason))
                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "error": "Invalid input detected",
                                        })
                                        c.Abort()
                                        return
                                }</span>
                        }
                }

                <span class="cov1" title="1">c.Next()</span>
        }
}

// SQLInjectionPattern checks for SQL injection patterns
func SQLInjectionPattern(input string) bool <span class="cov4" title="8">{
        for _, pattern := range sqlInjectionPatterns </span><span class="cov7" title="59">{
                if pattern.MatchString(input) </span><span class="cov3" title="6">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// XSSPattern checks for XSS patterns
func XSSPattern(input string) bool <span class="cov4" title="8">{
        for _, pattern := range xssPatterns </span><span class="cov7" title="63">{
                if pattern.MatchString(input) </span><span class="cov3" title="6">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// PathTraversalPattern checks for path traversal patterns
func PathTraversalPattern(input string) bool <span class="cov3" title="5">{
        for _, pattern := range pathTraversalPatterns </span><span class="cov5" title="18">{
                if pattern.MatchString(input) </span><span class="cov2" title="3">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package security

import (
        "fmt"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
)

// SecurityHeadersConfig contains security headers configuration
type SecurityHeadersConfig struct {
        // HSTS (HTTP Strict Transport Security)
        EnableHSTS            bool
        HSTSMaxAge            int    // Seconds (default: 31536000 = 1 year)
        HSTSIncludeSubdomains bool
        HSTSPreload           bool

        // CSP (Content Security Policy)
        EnableCSP             bool
        CSPDirectives         map[string][]string
        CSPReportOnly         bool
        CSPReportURI          string

        // X-Frame-Options (Clickjacking protection)
        EnableFrameOptions    bool
        FrameOption           string // DENY, SAMEORIGIN, or ALLOW-FROM uri

        // X-Content-Type-Options (MIME sniffing protection)
        EnableContentTypeOptions bool

        // X-XSS-Protection
        EnableXSSProtection   bool
        XSSProtectionMode     string // "0", "1", "1; mode=block"

        // Referrer-Policy
        EnableReferrerPolicy  bool
        ReferrerPolicy        string // no-referrer, strict-origin-when-cross-origin, etc.

        // Permissions-Policy (formerly Feature-Policy)
        EnablePermissionsPolicy bool
        PermissionsDirectives   map[string]string

        // Additional security headers
        EnableExpectCT        bool
        ExpectCTMaxAge        int
        ExpectCTEnforce       bool
        ExpectCTReportURI     string

        // Cross-Origin headers
        EnableCORP            bool // Cross-Origin-Resource-Policy
        CORPPolicy            string // same-site, same-origin, cross-origin

        EnableCOEP            bool // Cross-Origin-Embedder-Policy
        COEPPolicy            string // require-corp, credentialless

        EnableCOOP            bool // Cross-Origin-Opener-Policy
        COOPPolicy            string // same-origin, same-origin-allow-popups, unsafe-none

        // Server header
        RemoveServerHeader    bool
        CustomServerHeader    string

        // X-Powered-By header
        RemovePoweredByHeader bool
}

// DefaultSecurityHeadersConfig returns secure default settings
func DefaultSecurityHeadersConfig() SecurityHeadersConfig <span class="cov5" title="6">{
        return SecurityHeadersConfig{
                // HSTS - Force HTTPS for 1 year
                EnableHSTS:            true,
                HSTSMaxAge:            31536000, // 1 year
                HSTSIncludeSubdomains: true,
                HSTSPreload:           true,

                // CSP - Strict content security policy
                EnableCSP:      true,
                CSPDirectives: map[string][]string{
                        "default-src": {"'self'"},
                        "script-src":  {"'self'", "'unsafe-inline'"}, // Allow inline scripts for now
                        "style-src":   {"'self'", "'unsafe-inline'"}, // Allow inline styles for now
                        "img-src":     {"'self'", "data:", "https:"},
                        "font-src":    {"'self'", "data:"},
                        "connect-src": {"'self'"},
                        "media-src":   {"'self'"},
                        "object-src":  {"'none'"},
                        "frame-src":   {"'none'"},
                        "base-uri":    {"'self'"},
                        "form-action": {"'self'"},
                        "frame-ancestors": {"'none'"}, // Prevent clickjacking
                        "upgrade-insecure-requests": {}, // Upgrade HTTP to HTTPS
                },
                CSPReportOnly: false,

                // X-Frame-Options - Prevent clickjacking
                EnableFrameOptions: true,
                FrameOption:        "DENY",

                // X-Content-Type-Options - Prevent MIME sniffing
                EnableContentTypeOptions: true,

                // X-XSS-Protection - Enable XSS filter
                EnableXSSProtection: true,
                XSSProtectionMode:   "1; mode=block",

                // Referrer-Policy - Strict referrer policy
                EnableReferrerPolicy: true,
                ReferrerPolicy:       "strict-origin-when-cross-origin",

                // Permissions-Policy - Disable dangerous features
                EnablePermissionsPolicy: true,
                PermissionsDirectives: map[string]string{
                        "geolocation":           "()",
                        "microphone":            "()",
                        "camera":                "()",
                        "payment":               "()",
                        "usb":                   "()",
                        "magnetometer":          "()",
                        "gyroscope":             "()",
                        "accelerometer":         "()",
                        "ambient-light-sensor":  "()",
                        "autoplay":              "()",
                        "encrypted-media":       "()",
                        "fullscreen":            "(self)",
                        "picture-in-picture":    "()",
                },

                // Expect-CT - Require Certificate Transparency
                EnableExpectCT:  true,
                ExpectCTMaxAge:  86400, // 24 hours
                ExpectCTEnforce: true,

                // Cross-Origin policies
                EnableCORP:   true,
                CORPPolicy:   "same-origin",
                EnableCOEP:   true,
                COEPPolicy:   "require-corp",
                EnableCOOP:   true,
                COOPPolicy:   "same-origin",

                // Remove identifying headers
                RemoveServerHeader:    true,
                RemovePoweredByHeader: true,
        }
}</span>

// StrictSecurityHeadersConfig returns very strict security settings
func StrictSecurityHeadersConfig() SecurityHeadersConfig <span class="cov1" title="1">{
        cfg := DefaultSecurityHeadersConfig()

        // Stricter CSP
        cfg.CSPDirectives = map[string][]string{
                "default-src":         {"'none'"},
                "script-src":          {"'self'"},
                "style-src":           {"'self'"},
                "img-src":             {"'self'"},
                "font-src":            {"'self'"},
                "connect-src":         {"'self'"},
                "media-src":           {"'none'"},
                "object-src":          {"'none'"},
                "frame-src":           {"'none'"},
                "base-uri":            {"'self'"},
                "form-action":         {"'self'"},
                "frame-ancestors":     {"'none'"},
                "upgrade-insecure-requests": {},
        }

        // Stricter referrer policy
        cfg.ReferrerPolicy = "no-referrer"

        return cfg
}</span>

// RelaxedSecurityHeadersConfig returns more permissive settings for development
func RelaxedSecurityHeadersConfig() SecurityHeadersConfig <span class="cov1" title="1">{
        cfg := DefaultSecurityHeadersConfig()

        // More permissive CSP for development
        cfg.CSPDirectives = map[string][]string{
                "default-src": {"'self'", "'unsafe-inline'", "'unsafe-eval'"},
                "img-src":     {"'self'", "data:", "https:", "http:"},
                "connect-src": {"'self'", "ws:", "wss:"},
        }

        // Disable some headers for development
        cfg.EnableHSTS = false
        cfg.EnableExpectCT = false

        return cfg
}</span>

// SecurityHeadersMiddleware creates security headers middleware
func SecurityHeadersMiddleware(cfg SecurityHeadersConfig) gin.HandlerFunc <span class="cov4" title="4">{
        return func(c *gin.Context) </span><span class="cov4" title="4">{
                // Remove identifying headers
                if cfg.RemoveServerHeader </span><span class="cov4" title="4">{
                        c.Header("Server", cfg.CustomServerHeader)
                }</span>
                <span class="cov4" title="4">if cfg.RemovePoweredByHeader </span><span class="cov4" title="4">{
                        c.Header("X-Powered-By", "")
                }</span>

                // HSTS - HTTP Strict Transport Security
                <span class="cov4" title="4">if cfg.EnableHSTS &amp;&amp; c.Request.TLS != nil </span><span class="cov1" title="1">{
                        hsts := fmt.Sprintf("max-age=%d", cfg.HSTSMaxAge)
                        if cfg.HSTSIncludeSubdomains </span><span class="cov1" title="1">{
                                hsts += "; includeSubDomains"
                        }</span>
                        <span class="cov1" title="1">if cfg.HSTSPreload </span><span class="cov1" title="1">{
                                hsts += "; preload"
                        }</span>
                        <span class="cov1" title="1">c.Header("Strict-Transport-Security", hsts)</span>
                }

                // CSP - Content Security Policy
                <span class="cov4" title="4">if cfg.EnableCSP </span><span class="cov4" title="4">{
                        csp := buildCSP(cfg.CSPDirectives)
                        if cfg.CSPReportURI != "" </span><span class="cov0" title="0">{
                                csp += fmt.Sprintf("; report-uri %s", cfg.CSPReportURI)
                        }</span>
                        <span class="cov4" title="4">headerName := "Content-Security-Policy"
                        if cfg.CSPReportOnly </span><span class="cov0" title="0">{
                                headerName = "Content-Security-Policy-Report-Only"
                        }</span>
                        <span class="cov4" title="4">c.Header(headerName, csp)</span>
                }

                // X-Frame-Options - Clickjacking protection
                <span class="cov4" title="4">if cfg.EnableFrameOptions </span><span class="cov4" title="4">{
                        c.Header("X-Frame-Options", cfg.FrameOption)
                }</span>

                // X-Content-Type-Options - MIME sniffing protection
                <span class="cov4" title="4">if cfg.EnableContentTypeOptions </span><span class="cov4" title="4">{
                        c.Header("X-Content-Type-Options", "nosniff")
                }</span>

                // X-XSS-Protection
                <span class="cov4" title="4">if cfg.EnableXSSProtection </span><span class="cov4" title="4">{
                        c.Header("X-XSS-Protection", cfg.XSSProtectionMode)
                }</span>

                // Referrer-Policy
                <span class="cov4" title="4">if cfg.EnableReferrerPolicy </span><span class="cov4" title="4">{
                        c.Header("Referrer-Policy", cfg.ReferrerPolicy)
                }</span>

                // Permissions-Policy (formerly Feature-Policy)
                <span class="cov4" title="4">if cfg.EnablePermissionsPolicy </span><span class="cov4" title="4">{
                        pp := buildPermissionsPolicy(cfg.PermissionsDirectives)
                        c.Header("Permissions-Policy", pp)
                }</span>

                // Expect-CT - Certificate Transparency
                <span class="cov4" title="4">if cfg.EnableExpectCT &amp;&amp; c.Request.TLS != nil </span><span class="cov1" title="1">{
                        expectCT := fmt.Sprintf("max-age=%d", cfg.ExpectCTMaxAge)
                        if cfg.ExpectCTEnforce </span><span class="cov1" title="1">{
                                expectCT += ", enforce"
                        }</span>
                        <span class="cov1" title="1">if cfg.ExpectCTReportURI != "" </span><span class="cov0" title="0">{
                                expectCT += fmt.Sprintf(", report-uri=\"%s\"", cfg.ExpectCTReportURI)
                        }</span>
                        <span class="cov1" title="1">c.Header("Expect-CT", expectCT)</span>
                }

                // Cross-Origin-Resource-Policy
                <span class="cov4" title="4">if cfg.EnableCORP </span><span class="cov4" title="4">{
                        c.Header("Cross-Origin-Resource-Policy", cfg.CORPPolicy)
                }</span>

                // Cross-Origin-Embedder-Policy
                <span class="cov4" title="4">if cfg.EnableCOEP </span><span class="cov4" title="4">{
                        c.Header("Cross-Origin-Embedder-Policy", cfg.COEPPolicy)
                }</span>

                // Cross-Origin-Opener-Policy
                <span class="cov4" title="4">if cfg.EnableCOOP </span><span class="cov4" title="4">{
                        c.Header("Cross-Origin-Opener-Policy", cfg.COOPPolicy)
                }</span>

                <span class="cov4" title="4">c.Next()</span>
        }
}

// buildCSP builds a Content-Security-Policy header value
func buildCSP(directives map[string][]string) string <span class="cov4" title="5">{
        var parts []string
        for directive, values := range directives </span><span class="cov10" title="55">{
                if len(values) == 0 </span><span class="cov4" title="4">{
                        // Directive with no value (like upgrade-insecure-requests)
                        parts = append(parts, directive)
                }</span> else<span class="cov9" title="51"> {
                        // Directive with values
                        parts = append(parts, fmt.Sprintf("%s %s", directive, strings.Join(values, " ")))
                }</span>
        }
        <span class="cov4" title="5">return strings.Join(parts, "; ")</span>
}

// buildPermissionsPolicy builds a Permissions-Policy header value
func buildPermissionsPolicy(directives map[string]string) string <span class="cov4" title="5">{
        var parts []string
        for feature, allowlist := range directives </span><span class="cov10" title="55">{
                parts = append(parts, fmt.Sprintf("%s=%s", feature, allowlist))
        }</span>
        <span class="cov4" title="5">return strings.Join(parts, ", ")</span>
}

// CSPViolationReport represents a CSP violation report
type CSPViolationReport struct {
        DocumentURI        string `json:"document-uri"`
        Referrer           string `json:"referrer"`
        BlockedURI         string `json:"blocked-uri"`
        ViolatedDirective  string `json:"violated-directive"`
        EffectiveDirective string `json:"effective-directive"`
        OriginalPolicy     string `json:"original-policy"`
        Disposition        string `json:"disposition"`
        StatusCode         int    `json:"status-code"`
}

// CSPReportHandler creates a handler for CSP violation reports
func CSPReportHandler() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                var report struct {
                        CSPReport CSPViolationReport `json:"csp-report"`
                }

                if err := c.ShouldBindJSON(&amp;report); err != nil </span><span class="cov1" title="1">{
                        c.JSON(400, gin.H{"error": "Invalid CSP report"})
                        return
                }</span>

                // Log the CSP violation
                <span class="cov0" title="0">LogSecurityEvent("CSP_VIOLATION", c.ClientIP(),
                        fmt.Sprintf("Violated directive: %s, Blocked URI: %s",
                                report.CSPReport.ViolatedDirective,
                                report.CSPReport.BlockedURI))

                c.Status(204)</span> // No Content
        }
}

// SecureRedirect redirects HTTP to HTTPS
func SecureRedirect(trustProxy bool) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                // Check if request is HTTPS
                isHTTPS := c.Request.TLS != nil

                // Check X-Forwarded-Proto header if behind proxy
                if trustProxy </span><span class="cov0" title="0">{
                        proto := c.GetHeader("X-Forwarded-Proto")
                        if proto == "https" </span><span class="cov0" title="0">{
                                isHTTPS = true
                        }</span>
                }

                // Redirect to HTTPS if not already
                <span class="cov1" title="1">if !isHTTPS </span><span class="cov1" title="1">{
                        host := c.Request.Host
                        if host == "" </span><span class="cov0" title="0">{
                                host = "localhost"
                        }</span>

                        <span class="cov1" title="1">target := fmt.Sprintf("https://%s%s", host, c.Request.RequestURI)
                        LogSecurityEvent("HTTP_TO_HTTPS_REDIRECT", c.ClientIP(),
                                fmt.Sprintf("Redirecting to %s", target))

                        c.Redirect(301, target) // Permanent redirect
                        c.Abort()
                        return</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// TLSVersionMiddleware enforces minimum TLS version
func TLSVersionMiddleware(minVersion uint16) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                if c.Request.TLS != nil </span><span class="cov2" title="2">{
                        if c.Request.TLS.Version &lt; minVersion </span><span class="cov1" title="1">{
                                LogSecurityEvent("TLS_VERSION_TOO_LOW", c.ClientIP(),
                                        fmt.Sprintf("TLS version %d is too low (min: %d)",
                                                c.Request.TLS.Version, minVersion))

                                c.JSON(400, gin.H{
                                        "error": "TLS version too low",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov1" title="1">c.Next()</span>
        }
}

// SecurityHeadersChecker checks if security headers are properly set
type SecurityHeadersChecker struct {
        RequiredHeaders map[string]bool
        ForbiddenHeaders []string
}

// DefaultSecurityHeadersChecker returns a checker with recommended headers
func DefaultSecurityHeadersChecker() *SecurityHeadersChecker <span class="cov2" title="2">{
        return &amp;SecurityHeadersChecker{
                RequiredHeaders: map[string]bool{
                        "Strict-Transport-Security":    false,
                        "Content-Security-Policy":      false,
                        "X-Frame-Options":              false,
                        "X-Content-Type-Options":       false,
                        "X-XSS-Protection":             false,
                        "Referrer-Policy":              false,
                },
                ForbiddenHeaders: []string{
                        "X-Powered-By",
                        "Server",
                },
        }
}</span>

// CheckHeaders checks if security headers are properly set
func (checker *SecurityHeadersChecker) CheckHeaders(headers map[string][]string) map[string]string <span class="cov2" title="2">{
        issues := make(map[string]string)

        // Check required headers
        for header := range checker.RequiredHeaders </span><span class="cov6" title="12">{
                if _, exists := headers[header]; !exists </span><span class="cov2" title="2">{
                        issues[header] = "Missing required security header"
                }</span>
        }

        // Check forbidden headers
        <span class="cov2" title="2">for _, header := range checker.ForbiddenHeaders </span><span class="cov4" title="4">{
                if value, exists := headers[header]; exists &amp;&amp; len(value) &gt; 0 &amp;&amp; value[0] != "" </span><span class="cov2" title="2">{
                        issues[header] = "Forbidden header present (information disclosure)"
                }</span>
        }

        <span class="cov2" title="2">return issues</span>
}

// SecurityHeadersAuditMiddleware logs security headers for audit
func SecurityHeadersAuditMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        checker := DefaultSecurityHeadersChecker()

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Check response headers
                issues := checker.CheckHeaders(c.Writer.Header())

                if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                        LogSecurityEvent("SECURITY_HEADERS_ISSUE", c.ClientIP(),
                                fmt.Sprintf("Issues found: %v", issues))
                }</span>
        }
}

// GetSecurityHeaders returns all security-related headers
func GetSecurityHeaders(c *gin.Context) map[string]string <span class="cov1" title="1">{
        headers := make(map[string]string)

        securityHeaderNames := []string{
                "Strict-Transport-Security",
                "Content-Security-Policy",
                "Content-Security-Policy-Report-Only",
                "X-Frame-Options",
                "X-Content-Type-Options",
                "X-XSS-Protection",
                "Referrer-Policy",
                "Permissions-Policy",
                "Feature-Policy",
                "Expect-CT",
                "Cross-Origin-Resource-Policy",
                "Cross-Origin-Embedder-Policy",
                "Cross-Origin-Opener-Policy",
        }

        for _, name := range securityHeaderNames </span><span class="cov6" title="13">{
                if value := c.Writer.Header().Get(name); value != "" </span><span class="cov5" title="9">{
                        headers[name] = value
                }</span>
        }

        <span class="cov1" title="1">return headers</span>
}

// SecurityHeadersInfo provides information about current security headers
type SecurityHeadersInfo struct {
        HSTSEnabled             bool          `json:"hsts_enabled"`
        HSTSMaxAge              time.Duration `json:"hsts_max_age,omitempty"`
        CSPEnabled              bool          `json:"csp_enabled"`
        CSPPolicy               string        `json:"csp_policy,omitempty"`
        FrameOptionsEnabled     bool          `json:"frame_options_enabled"`
        FrameOption             string        `json:"frame_option,omitempty"`
        ContentTypeNoSniff      bool          `json:"content_type_no_sniff"`
        XSSProtectionEnabled    bool          `json:"xss_protection_enabled"`
        ReferrerPolicyEnabled   bool          `json:"referrer_policy_enabled"`
        ReferrerPolicy          string        `json:"referrer_policy,omitempty"`
        PermissionsPolicyEnabled bool         `json:"permissions_policy_enabled"`
        ExpectCTEnabled         bool          `json:"expect_ct_enabled"`
        CORPEnabled             bool          `json:"corp_enabled"`
        COEPEnabled             bool          `json:"coep_enabled"`
        COOPEnabled             bool          `json:"coop_enabled"`
        ServerHeaderRemoved     bool          `json:"server_header_removed"`
        PoweredByHeaderRemoved  bool          `json:"powered_by_header_removed"`
}

// GetSecurityHeadersInfo extracts security headers information
func GetSecurityHeadersInfo(c *gin.Context) *SecurityHeadersInfo <span class="cov1" title="1">{
        info := &amp;SecurityHeadersInfo{}

        // Check HSTS
        if hsts := c.Writer.Header().Get("Strict-Transport-Security"); hsts != "" </span><span class="cov0" title="0">{
                info.HSTSEnabled = true
                // Parse max-age if needed
        }</span>

        // Check CSP
        <span class="cov1" title="1">if csp := c.Writer.Header().Get("Content-Security-Policy"); csp != "" </span><span class="cov1" title="1">{
                info.CSPEnabled = true
                info.CSPPolicy = csp
        }</span> else<span class="cov0" title="0"> if csp := c.Writer.Header().Get("Content-Security-Policy-Report-Only"); csp != "" </span><span class="cov0" title="0">{
                info.CSPEnabled = true
                info.CSPPolicy = csp + " (report-only)"
        }</span>

        // Check X-Frame-Options
        <span class="cov1" title="1">if fo := c.Writer.Header().Get("X-Frame-Options"); fo != "" </span><span class="cov1" title="1">{
                info.FrameOptionsEnabled = true
                info.FrameOption = fo
        }</span>

        // Check X-Content-Type-Options
        <span class="cov1" title="1">if ctno := c.Writer.Header().Get("X-Content-Type-Options"); ctno == "nosniff" </span><span class="cov1" title="1">{
                info.ContentTypeNoSniff = true
        }</span>

        // Check X-XSS-Protection
        <span class="cov1" title="1">if xss := c.Writer.Header().Get("X-XSS-Protection"); xss != "" </span><span class="cov1" title="1">{
                info.XSSProtectionEnabled = true
        }</span>

        // Check Referrer-Policy
        <span class="cov1" title="1">if rp := c.Writer.Header().Get("Referrer-Policy"); rp != "" </span><span class="cov1" title="1">{
                info.ReferrerPolicyEnabled = true
                info.ReferrerPolicy = rp
        }</span>

        // Check Permissions-Policy
        <span class="cov1" title="1">if pp := c.Writer.Header().Get("Permissions-Policy"); pp != "" </span><span class="cov1" title="1">{
                info.PermissionsPolicyEnabled = true
        }</span>

        // Check Expect-CT
        <span class="cov1" title="1">if ect := c.Writer.Header().Get("Expect-CT"); ect != "" </span><span class="cov0" title="0">{
                info.ExpectCTEnabled = true
        }</span>

        // Check Cross-Origin policies
        <span class="cov1" title="1">if corp := c.Writer.Header().Get("Cross-Origin-Resource-Policy"); corp != "" </span><span class="cov1" title="1">{
                info.CORPEnabled = true
        }</span>
        <span class="cov1" title="1">if coep := c.Writer.Header().Get("Cross-Origin-Embedder-Policy"); coep != "" </span><span class="cov1" title="1">{
                info.COEPEnabled = true
        }</span>
        <span class="cov1" title="1">if coop := c.Writer.Header().Get("Cross-Origin-Opener-Policy"); coop != "" </span><span class="cov1" title="1">{
                info.COOPEnabled = true
        }</span>

        // Check if identifying headers are removed
        <span class="cov1" title="1">if server := c.Writer.Header().Get("Server"); server == "" </span><span class="cov1" title="1">{
                info.ServerHeaderRemoved = true
        }</span>
        <span class="cov1" title="1">if poweredBy := c.Writer.Header().Get("X-Powered-By"); poweredBy == "" </span><span class="cov1" title="1">{
                info.PoweredByHeaderRemoved = true
        }</span>

        <span class="cov1" title="1">return info</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package security

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "time"

        "helixtrack.ru/core/internal/models"
)

// ServiceSigner handles cryptographic signing and verification of services
type ServiceSigner struct {
        privateKey *rsa.PrivateKey
        publicKey  *rsa.PublicKey
}

// NewServiceSigner creates a new service signer with generated keys
func NewServiceSigner() (*ServiceSigner, error) <span class="cov8" title="7">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }</span>

        <span class="cov8" title="7">return &amp;ServiceSigner{
                privateKey: privateKey,
                publicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// NewServiceSignerFromPrivateKey creates a signer from an existing private key
func NewServiceSignerFromPrivateKey(privateKeyPEM string) (*ServiceSigner, error) <span class="cov0" title="0">{
        block, _ := pem.Decode([]byte(privateKeyPEM))
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode PEM block containing private key")
        }</span>

        <span class="cov0" title="0">privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse private key: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ServiceSigner{
                privateKey: privateKey,
                publicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// SignServiceRegistration signs a service registration with the private key
func (s *ServiceSigner) SignServiceRegistration(service *models.ServiceRegistration) error <span class="cov8" title="9">{
        // Get the public key in PEM format
        publicKeyPEM, err := s.GetPublicKeyPEM()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get public key: %w", err)
        }</span>
        <span class="cov8" title="9">service.PublicKey = publicKeyPEM

        // Compute the data to sign
        data := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%d",
                service.ID,
                service.Name,
                service.Type,
                service.Version,
                service.URL,
                service.PublicKey,
                service.RegisteredAt.Unix(),
        )

        // Hash the data
        hashed := sha256.Sum256([]byte(data))

        // Sign the hash
        signature, err := rsa.SignPKCS1v15(rand.Reader, s.privateKey, crypto.SHA256, hashed[:])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sign service registration: %w", err)
        }</span>

        // Encode signature as base64
        <span class="cov8" title="9">service.Signature = base64.StdEncoding.EncodeToString(signature)

        return nil</span>
}

// VerifyServiceRegistration verifies the signature of a service registration
func (s *ServiceSigner) VerifyServiceRegistration(service *models.ServiceRegistration) error <span class="cov10" title="12">{
        // Decode the signature
        signature, err := base64.StdEncoding.DecodeString(service.Signature)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("failed to decode signature: %w", err)
        }</span>

        // Parse the public key from the service
        <span class="cov9" title="10">publicKey, err := ParsePublicKey(service.PublicKey)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        // Compute the data that was signed
        <span class="cov8" title="9">data := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%d",
                service.ID,
                service.Name,
                service.Type,
                service.Version,
                service.URL,
                service.PublicKey,
                service.RegisteredAt.Unix(),
        )

        // Hash the data
        hashed := sha256.Sum256([]byte(data))

        // Verify the signature
        err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hashed[:], signature)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("signature verification failed: %w", err)
        }</span>

        <span class="cov8" title="7">return nil</span>
}

// VerifyServiceRotation verifies that a service rotation request is legitimate
func (s *ServiceSigner) VerifyServiceRotation(
        oldService *models.ServiceRegistration,
        newService *models.ServiceRegistration,
        adminToken string,
) error <span class="cov8" title="8">{
        // 1. Verify old service is not already rotating or decommissioned
        if !oldService.CanRotate() </span><span class="cov3" title="2">{
                return fmt.Errorf("service cannot be rotated in current status: %s", oldService.Status)
        }</span>

        // 2. Verify new service signature
        <span class="cov7" title="6">if err := s.VerifyServiceRegistration(newService); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("new service signature invalid: %w", err)
        }</span>

        // 3. Verify admin token (implementation depends on your admin auth system)
        <span class="cov6" title="5">if !s.verifyAdminToken(adminToken) </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid admin token")
        }</span>

        // 4. Verify service types match
        <span class="cov6" title="4">if oldService.Type != newService.Type </span><span class="cov1" title="1">{
                return fmt.Errorf("service type mismatch: old=%s, new=%s", oldService.Type, newService.Type)
        }</span>

        // 5. Verify new service is healthy (should be checked before calling this)
        <span class="cov4" title="3">if !newService.IsHealthy() </span><span class="cov1" title="1">{
                return fmt.Errorf("new service is not healthy")
        }</span>

        // 6. Verify time-based constraints (prevent rapid rotations)
        <span class="cov3" title="2">if time.Since(oldService.RegisteredAt) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                return fmt.Errorf("service was registered too recently for rotation")
        }</span>

        // 7. Verify new service has been registered long enough
        <span class="cov3" title="2">if time.Since(newService.RegisteredAt) &lt; 5*time.Minute </span><span class="cov1" title="1">{
                return fmt.Errorf("new service must be registered for at least 5 minutes before rotation")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// verifyAdminToken verifies an admin authorization token
func (s *ServiceSigner) verifyAdminToken(token string) bool <span class="cov6" title="5">{
        // In a real implementation, this would verify against a secure token store
        // For now, we'll use a simple check
        if token == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Hash the token and compare with expected values
        <span class="cov6" title="5">hash := sha256.Sum256([]byte(token))
        hashStr := base64.StdEncoding.EncodeToString(hash[:])

        // This should be replaced with actual token verification
        // For production, integrate with the JWT service or a dedicated admin auth system
        _ = hashStr

        // For development/testing, accept non-empty tokens
        // TODO: Implement proper admin token verification
        return len(token) &gt;= 32</span>
}

// GetPublicKeyPEM returns the public key in PEM format
func (s *ServiceSigner) GetPublicKeyPEM() (string, error) <span class="cov9" title="11">{
        publicKeyBytes, err := x509.MarshalPKIXPublicKey(s.publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov9" title="11">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyBytes,
        })

        return string(publicKeyPEM), nil</span>
}

// GetPrivateKeyPEM returns the private key in PEM format
func (s *ServiceSigner) GetPrivateKeyPEM() string <span class="cov1" title="1">{
        privateKeyBytes := x509.MarshalPKCS1PrivateKey(s.privateKey)
        privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyBytes,
        })

        return string(privateKeyPEM)
}</span>

// ParsePublicKey parses a PEM-encoded public key
func ParsePublicKey(publicKeyPEM string) (*rsa.PublicKey, error) <span class="cov9" title="10">{
        block, _ := pem.Decode([]byte(publicKeyPEM))
        if block == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decode PEM block containing public key")
        }</span>

        <span class="cov8" title="9">publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        <span class="cov8" title="9">rsaPublicKey, ok := publicKey.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not an RSA public key")
        }</span>

        <span class="cov8" title="9">return rsaPublicKey, nil</span>
}

// GenerateAdminToken generates a secure admin token for service operations
func GenerateAdminToken(username string, secret string) string <span class="cov6" title="5">{
        // Combine username, secret, and timestamp
        data := fmt.Sprintf("%s|%s|%d", username, secret, time.Now().Unix())
        hash := sha256.Sum256([]byte(data))
        return base64.StdEncoding.EncodeToString(hash[:])
}</span>

// VerifyRotationCode verifies a rotation verification code
func VerifyRotationCode(serviceID string, code string, secret string) bool <span class="cov3" title="2">{
        // Generate expected code
        expected := GenerateRotationCode(serviceID, secret)
        return code == expected
}</span>

// GenerateRotationCode generates a verification code for service rotation
func GenerateRotationCode(serviceID string, secret string) string <span class="cov8" title="8">{
        // Combine service ID, secret, and current hour (time-based code)
        hour := time.Now().UTC().Hour()
        data := fmt.Sprintf("%s|%s|%d", serviceID, secret, hour)
        hash := sha256.Sum256([]byte(data))
        return base64.StdEncoding.EncodeToString(hash[:])[:16] // First 16 characters
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package security

import (
        "crypto/tls"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
)

// TLSConfig contains TLS/SSL enforcement configuration
type TLSConfig struct {
        // TLS version enforcement
        MinTLSVersion uint16 // Minimum TLS version (default: tls.VersionTLS12)
        MaxTLSVersion uint16 // Maximum TLS version (default: tls.VersionTLS13)

        // Cipher suites
        CipherSuites  []uint16 // Allowed cipher suites
        PreferServerCipherSuites bool // Prefer server cipher suites

        // Certificate configuration
        CertFile      string // Path to certificate file
        KeyFile       string // Path to private key file
        ClientCAFile  string // Path to client CA file (for mutual TLS)

        // Client authentication
        ClientAuth    tls.ClientAuthType // Client authentication mode

        // HTTPS enforcement
        EnforceHTTPS  bool // Redirect HTTP to HTTPS
        HTTPSPort     int  // HTTPS port (default: 443)

        // HSTS
        EnableHSTS    bool // Enable HTTP Strict Transport Security
        HSTSMaxAge    int  // HSTS max age in seconds

        // Certificate verification
        InsecureSkipVerify bool // Skip certificate verification (NOT RECOMMENDED)

        // Session tickets
        SessionTicketsDisabled bool // Disable session tickets

        // Renegotiation
        Renegotiation tls.RenegotiationSupport // Renegotiation support
}

// DefaultTLSConfig returns secure default TLS settings
func DefaultTLSConfig() TLSConfig <span class="cov4" title="9">{
        return TLSConfig{
                MinTLSVersion:            tls.VersionTLS12,
                MaxTLSVersion:            tls.VersionTLS13,
                CipherSuites:             getSecureCipherSuites(),
                PreferServerCipherSuites: true,
                ClientAuth:               tls.NoClientCert,
                EnforceHTTPS:             true,
                HTTPSPort:                443,
                EnableHSTS:               true,
                HSTSMaxAge:               31536000, // 1 year
                InsecureSkipVerify:       false,
                SessionTicketsDisabled:   false,
                Renegotiation:            tls.RenegotiateNever,
        }
}</span>

// StrictTLSConfig returns very strict TLS settings
func StrictTLSConfig() TLSConfig <span class="cov1" title="1">{
        cfg := DefaultTLSConfig()
        cfg.MinTLSVersion = tls.VersionTLS13 // TLS 1.3 only
        cfg.CipherSuites = getTLS13CipherSuites()
        cfg.SessionTicketsDisabled = true
        cfg.ClientAuth = tls.RequireAndVerifyClientCert // Mutual TLS
        return cfg
}</span>

// getSecureCipherSuites returns recommended cipher suites for TLS 1.2
func getSecureCipherSuites() []uint16 <span class="cov5" title="11">{
        return []uint16{
                // TLS 1.3 cipher suites (always enabled in TLS 1.3)
                tls.TLS_AES_128_GCM_SHA256,
                tls.TLS_AES_256_GCM_SHA384,
                tls.TLS_CHACHA20_POLY1305_SHA256,

                // TLS 1.2 cipher suites (recommended)
                tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
                tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
                tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
        }
}</span>

// getTLS13CipherSuites returns TLS 1.3 cipher suites
func getTLS13CipherSuites() []uint16 <span class="cov1" title="1">{
        return []uint16{
                tls.TLS_AES_128_GCM_SHA256,
                tls.TLS_AES_256_GCM_SHA384,
                tls.TLS_CHACHA20_POLY1305_SHA256,
        }
}</span>

// GetWeakCipherSuites returns a list of weak cipher suites to avoid
func GetWeakCipherSuites() []uint16 <span class="cov2" title="3">{
        return []uint16{
                tls.TLS_RSA_WITH_RC4_128_SHA,
                tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
                tls.TLS_RSA_WITH_AES_128_CBC_SHA,
                tls.TLS_RSA_WITH_AES_256_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
                tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
                tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
                tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
                tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
        }
}</span>

// CreateTLSConfig creates a *tls.Config from TLSConfig
func CreateTLSConfig(cfg TLSConfig) *tls.Config <span class="cov1" title="1">{
        return &amp;tls.Config{
                MinVersion:               cfg.MinTLSVersion,
                MaxVersion:               cfg.MaxTLSVersion,
                CipherSuites:             cfg.CipherSuites,
                PreferServerCipherSuites: cfg.PreferServerCipherSuites,
                ClientAuth:               cfg.ClientAuth,
                InsecureSkipVerify:       cfg.InsecureSkipVerify,
                SessionTicketsDisabled:   cfg.SessionTicketsDisabled,
                Renegotiation:            cfg.Renegotiation,
        }
}</span>

// TLSEnforcementMiddleware enforces TLS/SSL requirements
func TLSEnforcementMiddleware(cfg TLSConfig) gin.HandlerFunc <span class="cov3" title="4">{
        return func(c *gin.Context) </span><span class="cov3" title="4">{
                // Check if connection is TLS
                if c.Request.TLS == nil </span><span class="cov1" title="1">{
                        // Not using TLS
                        if cfg.EnforceHTTPS </span><span class="cov1" title="1">{
                                // Redirect to HTTPS
                                host := c.Request.Host
                                if cfg.HTTPSPort != 443 </span><span class="cov0" title="0">{
                                        host = fmt.Sprintf("%s:%d", c.Request.Host, cfg.HTTPSPort)
                                }</span>

                                <span class="cov1" title="1">target := fmt.Sprintf("https://%s%s", host, c.Request.RequestURI)
                                LogSecurityEvent("HTTP_TO_HTTPS_REDIRECT", c.ClientIP(),
                                        fmt.Sprintf("Redirecting to %s", target))

                                c.Redirect(http.StatusMovedPermanently, target)
                                c.Abort()
                                return</span>
                        } else<span class="cov0" title="0"> {
                                // Just log warning
                                LogSecurityEvent("INSECURE_CONNECTION", c.ClientIP(),
                                        "Request received over HTTP instead of HTTPS")
                        }</span>
                } else<span class="cov2" title="3"> {
                        // Using TLS, verify version and cipher suite
                        if c.Request.TLS.Version &lt; cfg.MinTLSVersion </span><span class="cov1" title="1">{
                                LogSecurityEvent("TLS_VERSION_TOO_LOW", c.ClientIP(),
                                        fmt.Sprintf("TLS version %d is below minimum %d",
                                                c.Request.TLS.Version, cfg.MinTLSVersion))

                                c.JSON(http.StatusBadRequest, gin.H{
                                        "error": "TLS version too low",
                                })
                                c.Abort()
                                return
                        }</span>

                        <span class="cov2" title="2">if cfg.MaxTLSVersion &gt; 0 &amp;&amp; c.Request.TLS.Version &gt; cfg.MaxTLSVersion </span><span class="cov0" title="0">{
                                LogSecurityEvent("TLS_VERSION_TOO_HIGH", c.ClientIP(),
                                        fmt.Sprintf("TLS version %d is above maximum %d",
                                                c.Request.TLS.Version, cfg.MaxTLSVersion))

                                c.JSON(http.StatusBadRequest, gin.H{
                                        "error": "TLS version not supported",
                                })
                                c.Abort()
                                return
                        }</span>

                        // Check cipher suite
                        <span class="cov2" title="2">if len(cfg.CipherSuites) &gt; 0 </span><span class="cov2" title="2">{
                                cipherAllowed := false
                                for _, allowed := range cfg.CipherSuites </span><span class="cov4" title="10">{
                                        if c.Request.TLS.CipherSuite == allowed </span><span class="cov1" title="1">{
                                                cipherAllowed = true
                                                break</span>
                                        }
                                }

                                <span class="cov2" title="2">if !cipherAllowed </span><span class="cov1" title="1">{
                                        LogSecurityEvent("WEAK_CIPHER_SUITE", c.ClientIP(),
                                                fmt.Sprintf("Cipher suite 0x%04X not allowed",
                                                        c.Request.TLS.CipherSuite))

                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "error": "Cipher suite not allowed",
                                        })
                                        c.Abort()
                                        return
                                }</span>
                        }

                        // Add HSTS header if enabled
                        <span class="cov1" title="1">if cfg.EnableHSTS </span><span class="cov1" title="1">{
                                hsts := fmt.Sprintf("max-age=%d; includeSubDomains; preload", cfg.HSTSMaxAge)
                                c.Header("Strict-Transport-Security", hsts)
                        }</span>
                }

                <span class="cov1" title="1">c.Next()</span>
        }
}

// MutualTLSMiddleware enforces mutual TLS (client certificate authentication)
func MutualTLSMiddleware() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                if c.Request.TLS == nil </span><span class="cov0" title="0">{
                        LogSecurityEvent("MTLS_NO_TLS", c.ClientIP(), "Mutual TLS required but no TLS connection")
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "TLS required",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov1" title="1">if len(c.Request.TLS.PeerCertificates) == 0 </span><span class="cov1" title="1">{
                        LogSecurityEvent("MTLS_NO_CLIENT_CERT", c.ClientIP(),
                                "Mutual TLS required but no client certificate provided")

                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Client certificate required",
                        })
                        c.Abort()
                        return
                }</span>

                // Get client certificate
                <span class="cov0" title="0">clientCert := c.Request.TLS.PeerCertificates[0]

                // Verify certificate is not expired
                if clientCert.NotAfter.Before(c.Request.TLS.PeerCertificates[0].NotBefore) </span><span class="cov0" title="0">{
                        LogSecurityEvent("MTLS_CERT_EXPIRED", c.ClientIP(),
                                fmt.Sprintf("Client certificate expired: %s", clientCert.Subject.CommonName))

                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Client certificate expired",
                        })
                        c.Abort()
                        return
                }</span>

                // Store client certificate info in context
                <span class="cov0" title="0">c.Set("client_cert_subject", clientCert.Subject.CommonName)
                c.Set("client_cert_issuer", clientCert.Issuer.CommonName)
                c.Set("client_cert", clientCert)

                LogSecurityEvent("MTLS_SUCCESS", c.ClientIP(),
                        fmt.Sprintf("Mutual TLS authentication successful for %s", clientCert.Subject.CommonName))

                c.Next()</span>
        }
}

// TLSVersionInfo contains information about TLS connection
type TLSVersionInfo struct {
        Version              string   `json:"version"`
        VersionNumber        uint16   `json:"version_number"`
        CipherSuite          string   `json:"cipher_suite"`
        CipherSuiteNumber    uint16   `json:"cipher_suite_number"`
        ServerName           string   `json:"server_name"`
        NegotiatedProtocol   string   `json:"negotiated_protocol"`
        HandshakeComplete    bool     `json:"handshake_complete"`
        ClientCertPresent    bool     `json:"client_cert_present"`
        ClientCertSubject    string   `json:"client_cert_subject,omitempty"`
}

// GetTLSVersionInfo extracts TLS connection information
func GetTLSVersionInfo(c *gin.Context) *TLSVersionInfo <span class="cov2" title="3">{
        if c.Request.TLS == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="2">info := &amp;TLSVersionInfo{
                Version:            getTLSVersionName(c.Request.TLS.Version),
                VersionNumber:      c.Request.TLS.Version,
                CipherSuite:        getCipherSuiteName(c.Request.TLS.CipherSuite),
                CipherSuiteNumber:  c.Request.TLS.CipherSuite,
                ServerName:         c.Request.TLS.ServerName,
                NegotiatedProtocol: c.Request.TLS.NegotiatedProtocol,
                HandshakeComplete:  c.Request.TLS.HandshakeComplete,
                ClientCertPresent:  len(c.Request.TLS.PeerCertificates) &gt; 0,
        }

        if info.ClientCertPresent </span><span class="cov0" title="0">{
                info.ClientCertSubject = c.Request.TLS.PeerCertificates[0].Subject.CommonName
        }</span>

        <span class="cov2" title="2">return info</span>
}

// getTLSVersionName returns the name of a TLS version
func getTLSVersionName(version uint16) string <span class="cov4" title="7">{
        switch version </span>{
        case tls.VersionTLS10:<span class="cov1" title="1">
                return "TLS 1.0"</span>
        case tls.VersionTLS11:<span class="cov1" title="1">
                return "TLS 1.1"</span>
        case tls.VersionTLS12:<span class="cov1" title="1">
                return "TLS 1.2"</span>
        case tls.VersionTLS13:<span class="cov2" title="3">
                return "TLS 1.3"</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("Unknown (0x%04X)", version)</span>
        }
}

// getCipherSuiteName returns the name of a cipher suite
func getCipherSuiteName(suite uint16) string <span class="cov4" title="7">{
        // TLS 1.3 cipher suites
        switch suite </span>{
        case tls.TLS_AES_128_GCM_SHA256:<span class="cov2" title="3">
                return "TLS_AES_128_GCM_SHA256"</span>
        case tls.TLS_AES_256_GCM_SHA384:<span class="cov1" title="1">
                return "TLS_AES_256_GCM_SHA384"</span>
        case tls.TLS_CHACHA20_POLY1305_SHA256:<span class="cov1" title="1">
                return "TLS_CHACHA20_POLY1305_SHA256"</span>

        // TLS 1.2 cipher suites
        case tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:<span class="cov1" title="1">
                return "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"</span>
        case tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:<span class="cov0" title="0">
                return "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"</span>
        case tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"</span>
        case tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:<span class="cov0" title="0">
                return "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"</span>
        case tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"</span>
        case tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"</span>

        // Weak cipher suites
        case tls.TLS_RSA_WITH_RC4_128_SHA:<span class="cov1" title="1">
                return "TLS_RSA_WITH_RC4_128_SHA (WEAK)"</span>
        case tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA:<span class="cov0" title="0">
                return "TLS_RSA_WITH_3DES_EDE_CBC_SHA (WEAK)"</span>
        case tls.TLS_RSA_WITH_AES_128_CBC_SHA:<span class="cov0" title="0">
                return "TLS_RSA_WITH_AES_128_CBC_SHA (WEAK)"</span>
        case tls.TLS_RSA_WITH_AES_256_CBC_SHA:<span class="cov0" title="0">
                return "TLS_RSA_WITH_AES_256_CBC_SHA (WEAK)"</span>

        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown (0x%04X)", suite)</span>
        }
}

// ValidateTLSConfig validates a TLS configuration
func ValidateTLSConfig(cfg TLSConfig) []string <span class="cov2" title="2">{
        var issues []string

        // Check TLS version
        if cfg.MinTLSVersion &lt; tls.VersionTLS12 </span><span class="cov1" title="1">{
                issues = append(issues, "Minimum TLS version is below TLS 1.2 (insecure)")
        }</span>

        // Check if HTTPS is enforced
        <span class="cov2" title="2">if !cfg.EnforceHTTPS </span><span class="cov0" title="0">{
                issues = append(issues, "HTTPS enforcement is disabled")
        }</span>

        // Check HSTS
        <span class="cov2" title="2">if !cfg.EnableHSTS </span><span class="cov1" title="1">{
                issues = append(issues, "HSTS is disabled")
        }</span> else<span class="cov1" title="1"> if cfg.HSTSMaxAge &lt; 31536000 </span><span class="cov0" title="0">{
                issues = append(issues, "HSTS max-age is less than 1 year")
        }</span>

        // Check certificate verification
        <span class="cov2" title="2">if cfg.InsecureSkipVerify </span><span class="cov1" title="1">{
                issues = append(issues, "Certificate verification is disabled (CRITICAL SECURITY ISSUE)")
        }</span>

        // Check for weak cipher suites
        <span class="cov2" title="2">weakCiphers := GetWeakCipherSuites()
        for _, configured := range cfg.CipherSuites </span><span class="cov5" title="18">{
                for _, weak := range weakCiphers </span><span class="cov10" title="198">{
                        if configured == weak </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("Weak cipher suite enabled: %s",
                                        getCipherSuiteName(configured)))
                        }</span>
                }
        }

        <span class="cov2" title="2">return issues</span>
}

// TLSAuditMiddleware logs TLS connection details for audit
func TLSAuditMiddleware() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                if c.Request.TLS != nil </span><span class="cov1" title="1">{
                        info := GetTLSVersionInfo(c)
                        LogSecurityEvent("TLS_CONNECTION", c.ClientIP(),
                                fmt.Sprintf("TLS %s with %s", info.Version, info.CipherSuite))
                }</span> else<span class="cov0" title="0"> {
                        LogSecurityEvent("INSECURE_HTTP_CONNECTION", c.ClientIP(),
                                "Request received over insecure HTTP")
                }</span>

                <span class="cov1" title="1">c.Next()</span>
        }
}

// RequireHTTPSMiddleware strictly requires HTTPS (aborts non-HTTPS requests)
func RequireHTTPSMiddleware() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                if c.Request.TLS == nil </span><span class="cov1" title="1">{
                        LogSecurityEvent("HTTPS_REQUIRED", c.ClientIP(),
                                "HTTPS required but request was HTTP")

                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "HTTPS required",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov1" title="1">c.Next()</span>
        }
}

// TLSStatistics contains TLS usage statistics
type TLSStatistics struct {
        TotalTLSConnections    int            `json:"total_tls_connections"`
        TotalHTTPConnections   int            `json:"total_http_connections"`
        TLSVersions            map[string]int `json:"tls_versions"`
        CipherSuites           map[string]int `json:"cipher_suites"`
        ClientCertConnections  int            `json:"client_cert_connections"`
        WeakCipherDetections   int            `json:"weak_cipher_detections"`
}

// Global TLS statistics (would need to be implemented with proper tracking)
var tlsStats = &amp;TLSStatistics{
        TLSVersions:  make(map[string]int),
        CipherSuites: make(map[string]int),
}

// GetTLSStatistics returns TLS statistics
func GetTLSStatistics() *TLSStatistics <span class="cov0" title="0">{
        return tlsStats
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package server

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/config"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/handlers"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/security/engine"
        "helixtrack.ru/core/internal/services"
        "helixtrack.ru/core/internal/websocket"
)

// Server represents the HTTP server
type Server struct {
        config                  *config.Config
        router                  *gin.Engine
        httpServer              *http.Server
        db                      database.Database
        authService             services.AuthService
        permService             services.PermissionService
        securityEngine          engine.Engine
        serviceDiscoveryHandler *handlers.ServiceDiscoveryHandler
        networkDiscoveryService *services.NetworkDiscoveryService
        wsManager               *websocket.Manager
        wsPublisher             websocket.EventPublisher
        wsHandler               *websocket.Handler
}

// NewServer creates a new server instance
func NewServer(cfg *config.Config) (*Server, error) <span class="cov7" title="14">{
        // Initialize database
        db, err := database.NewDatabase(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>

        // Initialize services
        <span class="cov7" title="14">authService := services.NewAuthService(
                cfg.Services.Authentication.URL,
                cfg.Services.Authentication.Timeout,
                cfg.Services.Authentication.Enabled,
        )

        permService := services.NewPermissionService(
                cfg.Services.Permissions.URL,
                cfg.Services.Permissions.Timeout,
                cfg.Services.Permissions.Enabled,
        )

        // Initialize Security Engine
        securityConfig := engine.DefaultConfig()
        securityEngine := engine.NewSecurityEngine(db, securityConfig)

        logger.Info("Security Engine initialized",
                zap.Bool("caching_enabled", securityConfig.EnableCaching),
                zap.Bool("auditing_enabled", securityConfig.EnableAuditing),
        )

        // Initialize service discovery handler
        serviceDiscoveryHandler, err := handlers.NewServiceDiscoveryHandler(db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize service discovery handler: %w", err)
        }</span>

        // Initialize network discovery service
        <span class="cov7" title="14">listener := cfg.GetPrimaryListener()
        host := "localhost"
        port := 8080
        if listener != nil </span><span class="cov7" title="14">{
                host = listener.Address
                port = listener.Port
        }</span>
        <span class="cov7" title="14">networkDiscoveryService := services.NewNetworkDiscoveryService(port, host)

        // Initialize WebSocket manager and publisher
        var wsManager *websocket.Manager
        var wsPublisher websocket.EventPublisher
        var wsHandler *websocket.Handler

        if cfg.IsWebSocketEnabled() </span><span class="cov1" title="1">{
                wsConfig := websocket.ConfigToModel(cfg.GetWebSocketConfig())
                wsManager = websocket.NewManager(wsConfig, permService)
                wsPublisher = websocket.NewPublisher(wsManager, true)
                wsHandler = websocket.NewHandler(wsManager, authService, wsConfig)

                logger.Info("WebSocket enabled",
                        zap.String("path", wsConfig.Path),
                        zap.Int("maxClients", wsConfig.MaxClients),
                )
        }</span> else<span class="cov7" title="13"> {
                wsPublisher = websocket.NewNoOpPublisher()
                logger.Info("WebSocket disabled")
        }</span>

        <span class="cov7" title="14">server := &amp;Server{
                config:                  cfg,
                db:                      db,
                authService:             authService,
                permService:             permService,
                securityEngine:          securityEngine,
                serviceDiscoveryHandler: serviceDiscoveryHandler,
                networkDiscoveryService: networkDiscoveryService,
                wsManager:               wsManager,
                wsPublisher:             wsPublisher,
                wsHandler:               wsHandler,
        }

        server.setupRouter()

        return server, nil</span>
}

// setupRouter configures the Gin router with all routes and middleware
func (s *Server) setupRouter() <span class="cov7" title="14">{
        // Set Gin mode based on configuration
        gin.SetMode(gin.ReleaseMode)

        router := gin.New()

        // Add middleware
        router.Use(gin.Recovery())
        router.Use(s.loggingMiddleware())
        router.Use(s.corsMiddleware())

        // Initialize users table
        if err := handlers.InitializeUserTable(s.db); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize users table", zap.Error(err))
        }</span>

        // Initialize project, ticket, and comment tables
        <span class="cov7" title="14">if err := handlers.InitializeProjectTables(s.db); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize project tables", zap.Error(err))
        }</span>

        // Initialize service discovery tables
        <span class="cov7" title="14">if err := handlers.InitializeServiceDiscoveryTables(s.db); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize service discovery tables", zap.Error(err))
        }</span>

        // Start service health checker
        <span class="cov7" title="14">if err := s.serviceDiscoveryHandler.StartHealthChecker(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start health checker", zap.Error(err))
        }</span> else<span class="cov7" title="14"> {
                logger.Info("Service health checker started")
        }</span>

        // Create handlers
        <span class="cov7" title="14">handler := handlers.NewHandler(s.db, s.authService, s.permService, s.config.Version)
        handler.SetEventPublisher(s.wsPublisher) // Set event publisher for WebSocket events
        handler.SetSecurityEngine(s.securityEngine) // Set Security Engine for RBAC
        authHandler := handlers.NewAuthHandler(s.db)

        // WebSocket routes (if enabled)
        if s.config.IsWebSocketEnabled() &amp;&amp; s.wsHandler != nil </span><span class="cov1" title="1">{
                wsPath := s.config.WebSocket.Path
                router.GET(wsPath, s.wsHandler.HandleConnection)
                router.GET(wsPath+"/stats", s.wsHandler.HandleStats)
                logger.Info("WebSocket routes registered",
                        zap.String("path", wsPath),
                        zap.String("statsPath", wsPath+"/stats"),
                )
        }</span>

        // Authentication routes (public)
        <span class="cov7" title="14">auth := router.Group("/api/auth")
        </span><span class="cov7" title="14">{
                auth.POST("/register", authHandler.Register)
                auth.POST("/login", authHandler.Login)
                auth.POST("/logout", authHandler.Logout)
        }</span>

        // Service discovery routes (admin only)
        <span class="cov7" title="14">serviceDiscovery := router.Group("/api/services")
        </span><span class="cov7" title="14">{
                serviceDiscovery.POST("/register", s.serviceDiscoveryHandler.RegisterService)
                serviceDiscovery.POST("/discover", s.serviceDiscoveryHandler.DiscoverServices)
                serviceDiscovery.POST("/rotate", s.serviceDiscoveryHandler.RotateService)
                serviceDiscovery.POST("/decommission", s.serviceDiscoveryHandler.DecommissionService)
                serviceDiscovery.POST("/update", s.serviceDiscoveryHandler.UpdateService)
                serviceDiscovery.GET("/list", s.serviceDiscoveryHandler.ListServices)
                serviceDiscovery.GET("/health/:id", s.serviceDiscoveryHandler.GetServiceHealth)
        }</span>

        // Public routes (no JWT required)
        <span class="cov7" title="14">router.POST("/do", func(c *gin.Context) </span><span class="cov3" title="3">{
                // Log raw request body for debugging
                bodyBytes, _ := c.GetRawData()
                logger.Info("Received /do request", zap.String("body", string(bodyBytes)))

                // Restore body for binding
                c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

                // Parse request to check if authentication is required
                var req models.Request
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        logger.Error("Failed to bind JSON request",
                                zap.Error(err),
                                zap.String("error_details", err.Error()),
                                zap.String("body", string(bodyBytes)))
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidRequest,
                                fmt.Sprintf("Invalid request format: %v", err),
                                "",
                        ))
                        return
                }</span>

                <span class="cov2" title="2">logger.Info("Successfully parsed request", zap.String("action", req.Action))

                // If authentication is required, validate JWT
                if req.IsAuthenticationRequired() </span><span class="cov1" title="1">{
                        // Extract JWT from Authorization header or request body
                        var jwtToken string

                        // Check Authorization header first (format: "Bearer &lt;token&gt;")
                        authHeader := c.GetHeader("Authorization")
                        if authHeader != "" </span><span class="cov0" title="0">{
                                // Extract token from "Bearer &lt;token&gt;" format
                                if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                                        jwtToken = authHeader[7:]
                                }</span>
                        }

                        // Fall back to JWT field in request body
                        <span class="cov1" title="1">if jwtToken == "" </span><span class="cov1" title="1">{
                                jwtToken = req.JWT
                        }</span>

                        // Check if JWT is present
                        <span class="cov1" title="1">if jwtToken == "" </span><span class="cov1" title="1">{
                                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                        models.ErrorCodeMissingJWT,
                                        "JWT token is required for this action",
                                        "",
                                ))
                                return
                        }</span>

                        // Create JWT middleware and validate
                        <span class="cov0" title="0">jwtMiddleware := middleware.NewJWTMiddleware(s.authService, "")
                        claims, err := jwtMiddleware.ValidateToken(c.Request.Context(), jwtToken)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                        models.ErrorCodeInvalidJWT,
                                        "Invalid or expired JWT token",
                                        "",
                                ))
                                return
                        }</span>

                        // Store claims in context
                        <span class="cov0" title="0">c.Set("claims", claims)
                        c.Set("username", claims.Username)</span>
                }

                // Restore request body for handler
                <span class="cov1" title="1">c.Set("request", &amp;req)

                // Call handler
                handler.DoAction(c)</span>
        })

        // Health check endpoint
        <span class="cov7" title="14">router.GET("/health", func(c *gin.Context) </span><span class="cov3" title="3">{
                c.JSON(http.StatusOK, gin.H{
                        "status": "ok",
                })
        }</span>)

        <span class="cov7" title="14">s.router = router</span>
}

// loggingMiddleware logs HTTP requests
func (s *Server) loggingMiddleware() gin.HandlerFunc <span class="cov7" title="14">{
        return func(c *gin.Context) </span><span class="cov5" title="7">{
                start := time.Now()
                path := c.Request.URL.Path

                c.Next()

                latency := time.Since(start)
                statusCode := c.Writer.Status()

                logger.Info("HTTP Request",
                        zap.String("method", c.Request.Method),
                        zap.String("path", path),
                        zap.Int("status", statusCode),
                        zap.Duration("latency", latency),
                        zap.String("client_ip", c.ClientIP()),
                )
        }</span>
}

// corsMiddleware adds CORS headers
func (s *Server) corsMiddleware() gin.HandlerFunc <span class="cov7" title="14">{
        return func(c *gin.Context) </span><span class="cov5" title="7">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov1" title="1">{
                        c.AbortWithStatus(http.StatusOK)
                        return
                }</span>

                <span class="cov5" title="6">c.Next()</span>
        }
}

// Start starts the HTTP server with port fallback mechanism
func (s *Server) Start() error <span class="cov3" title="3">{
        // Start WebSocket manager if enabled
        if s.wsManager != nil </span><span class="cov0" title="0">{
                if err := s.wsManager.Start(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start WebSocket manager: %w", err)
                }</span>
                <span class="cov0" title="0">logger.Info("WebSocket manager started")</span>
        }

        // Start network discovery service
        <span class="cov3" title="3">if err := s.networkDiscoveryService.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start network discovery service: %w", err)
        }</span>
        <span class="cov3" title="3">logger.Info("Network discovery service started")

        // Try to start server with port fallback
        addr, err := s.startWithPortFallback()
        if err != nil </span><span class="cov3" title="3">{
                return err
        }</span>

        // Update network discovery service with actual port
        <span class="cov0" title="0">actualPort := s.extractPortFromAddress(addr)
        s.networkDiscoveryService.UpdatePort(actualPort)

        logger.Info("HTTP server started successfully", zap.String("address", addr))

        // Broadcast availability to clients
        s.broadcastAvailability(addr)

        return nil</span>
}

// startWithPortFallback attempts to start the server, trying multiple ports if needed
func (s *Server) startWithPortFallback() (string, error) <span class="cov3" title="3">{
        listener := s.config.GetPrimaryListener()
        if listener == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no listener configured")
        }</span>

        <span class="cov3" title="3">basePort := listener.Port
        maxAttempts := 100 // Try up to 100 different ports

        for attempt := 0; attempt &lt; maxAttempts; attempt++ </span><span class="cov4" title="5">{
                port := basePort + attempt
                if port &gt; 65535 </span><span class="cov0" title="0">{
                        port = 1024 + (port - 65535 - 1) // Wrap around to higher ports
                }</span>

                <span class="cov4" title="5">addr := fmt.Sprintf("%s:%d", listener.Address, port)

                s.httpServer = &amp;http.Server{
                        Addr:         addr,
                        Handler:      s.router,
                        ReadTimeout:  30 * time.Second,
                        WriteTimeout: 30 * time.Second,
                        IdleTimeout:  60 * time.Second,
                }

                logger.Info("Attempting to start server",
                        zap.String("address", addr),
                        zap.Int("attempt", attempt+1),
                )

                var err error
                if listener.HTTPS </span><span class="cov0" title="0">{
                        logger.Info("Starting HTTPS server",
                                zap.String("cert", listener.CertFile),
                                zap.String("key", listener.KeyFile),
                        )
                        err = s.httpServer.ListenAndServeTLS(listener.CertFile, listener.KeyFile)
                }</span> else<span class="cov4" title="5"> {
                        err = s.httpServer.ListenAndServe()
                }</span>

                // Check if the error is due to port already in use
                <span class="cov4" title="5">if err != nil &amp;&amp; s.isPortInUseError(err) </span><span class="cov2" title="2">{
                        logger.Warn("Port already in use, trying next port",
                                zap.Int("port", port),
                                zap.Error(err),
                        )
                        // Stop the current server before trying next port
                        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                        s.httpServer.Shutdown(ctx)
                        cancel()
                        continue</span>
                }

                <span class="cov3" title="3">if err != nil </span><span class="cov3" title="3">{
                        return "", fmt.Errorf("failed to start server on %s: %w", addr, err)
                }</span>

                // Server started successfully
                <span class="cov0" title="0">return addr, nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed to start server after trying %d different ports starting from %d", maxAttempts, basePort)</span>
}

// isPortInUseError checks if the error indicates the port is already in use
func (s *Server) isPortInUseError(err error) bool <span class="cov6" title="11">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check for common "address already in use" errors
        <span class="cov6" title="10">errStr := err.Error()
        return contains(errStr, "address already in use") ||
                contains(errStr, "bind: address already in use") ||
                contains(errStr, "listen tcp") &amp;&amp; contains(errStr, "address already in use")</span>
}

// contains checks if a string contains a substring (case-insensitive helper)
func contains(s, substr string) bool <span class="cov8" title="20">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr ||
                len(s) &gt; len(substr) &amp;&amp;
                        (s[:len(substr)] == substr ||
                                s[len(s)-len(substr):] == substr ||
                                containsInMiddle(s, substr)))
}</span>

// containsInMiddle checks if substring exists in the middle of the string
func containsInMiddle(s, substr string) bool <span class="cov4" title="5">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov10" title="46">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov4" title="5">return false</span>
}

// extractPortFromAddress extracts the port number from an address string
func (s *Server) extractPortFromAddress(addr string) int <span class="cov5" title="7">{
        // Simple port extraction from "host:port" format
        if len(addr) == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>

        // Find the last colon
        <span class="cov5" title="6">lastColon := -1
        for i := len(addr) - 1; i &gt;= 0; i-- </span><span class="cov8" title="28">{
                if addr[i] == ':' </span><span class="cov4" title="5">{
                        lastColon = i
                        break</span>
                }
        }

        <span class="cov5" title="6">if lastColon == -1 || lastColon == len(addr)-1 </span><span class="cov2" title="2">{
                return 0
        }</span>

        // Parse the port number
        <span class="cov4" title="4">var port int
        for i := lastColon + 1; i &lt; len(addr); i++ </span><span class="cov7" title="16">{
                if addr[i] &gt;= '0' &amp;&amp; addr[i] &lt;= '9' </span><span class="cov7" title="16">{
                        port = port*10 + int(addr[i]-'0')
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov4" title="4">return port</span>
}

// broadcastAvailability broadcasts the server availability to clients
func (s *Server) broadcastAvailability(addr string) <span class="cov1" title="1">{
        // Create availability event
        eventData := map[string]interface{}{
                "type":      "server_available",
                "address":   addr,
                "timestamp": time.Now().Unix(),
                "version":   s.config.Version,
        }

        // Create models.Event for WebSocket publishing
        event := &amp;models.Event{
                ID:       generateEventID(),
                Type:     models.EventSystemHealthCheck,
                Action:   "server_started",
                Object:   "server",
                EntityID: addr,
                Username: "system",
                Data:     eventData,
        }

        // Broadcast via WebSocket if available
        if s.wsPublisher != nil &amp;&amp; s.wsPublisher.IsEnabled() </span><span class="cov1" title="1">{
                s.wsPublisher.PublishEvent(event)
                logger.Info("Server availability broadcasted via WebSocket")
        }</span>

        // Log the availability
        <span class="cov1" title="1">logger.Info("Server is now available",
                zap.String("address", addr),
                zap.String("version", s.config.Version),
        )</span>
}

// generateEventID generates a unique event ID
func generateEventID() string <span class="cov1" title="1">{
        return fmt.Sprintf("evt_%d", time.Now().UnixNano())
}</span>

// Shutdown gracefully shuts down the server
func (s *Server) Shutdown(ctx context.Context) error <span class="cov4" title="4">{
        logger.Info("Shutting down server...")

        // Stop WebSocket manager
        if s.wsManager != nil </span><span class="cov0" title="0">{
                logger.Info("Stopping WebSocket manager...")
                if err := s.wsManager.Stop(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error stopping WebSocket manager", zap.Error(err))
                }</span>
        }

        // Stop network discovery service
        <span class="cov4" title="4">logger.Info("Stopping network discovery service...")
        if err := s.networkDiscoveryService.Stop(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error stopping network discovery service", zap.Error(err))
        }</span>

        // Stop health checker
        <span class="cov4" title="4">if s.serviceDiscoveryHandler != nil </span><span class="cov4" title="4">{
                logger.Info("Stopping service health checker...")
                s.serviceDiscoveryHandler.StopHealthChecker()
        }</span>

        <span class="cov4" title="4">if s.httpServer != nil </span><span class="cov3" title="3">{
                if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error shutting down HTTP server", zap.Error(err))
                        return err
                }</span>
        }

        <span class="cov4" title="4">if s.db != nil </span><span class="cov4" title="4">{
                if err := s.db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing database", zap.Error(err))
                        return err
                }</span>
        }

        <span class="cov4" title="4">logger.Info("Server shutdown complete")
        return nil</span>
}

// GetRouter returns the Gin router (useful for testing)
func (s *Server) GetRouter() *gin.Engine <span class="cov1" title="1">{
        return s.router
}</span>

// GetEventPublisher returns the WebSocket event publisher
func (s *Server) GetEventPublisher() websocket.EventPublisher <span class="cov0" title="0">{
        return s.wsPublisher
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package services

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "helixtrack.ru/core/internal/models"
)

// AuthService defines the interface for authentication operations
type AuthService interface {
        // Authenticate validates credentials and returns a JWT token
        Authenticate(ctx context.Context, username, password string) (*models.JWTClaims, error)

        // ValidateToken validates a JWT token and returns the claims
        ValidateToken(ctx context.Context, token string) (*models.JWTClaims, error)

        // IsEnabled returns whether the authentication service is enabled
        IsEnabled() bool
}

// httpAuthService is the HTTP-based implementation of AuthService
type httpAuthService struct {
        baseURL    string
        httpClient *http.Client
        enabled    bool
}

// NewAuthService creates a new authentication service client
func NewAuthService(baseURL string, timeout int, enabled bool) AuthService <span class="cov10" title="17">{
        return &amp;httpAuthService{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: time.Duration(timeout) * time.Second,
                },
                enabled: enabled,
        }
}</span>

// AuthRequest represents an authentication request
type AuthRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// AuthResponse represents an authentication response
type AuthResponse struct {
        Token  string           `json:"token"`
        Claims *models.JWTClaims `json:"claims,omitempty"`
}

// Authenticate validates credentials and returns JWT claims
func (s *httpAuthService) Authenticate(ctx context.Context, username, password string) (*models.JWTClaims, error) <span class="cov8" title="10">{
        if !s.enabled </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("authentication service is not enabled")
        }</span>

        <span class="cov7" title="8">reqBody := AuthRequest{
                Username: username,
                Password: password,
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov7" title="8">req, err := http.NewRequestWithContext(ctx, http.MethodPost, s.baseURL+"/authenticate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov7" title="8">req.Header.Set("Content-Type", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov6" title="6">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov4" title="3">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("authentication failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov4" title="3">var authResp AuthResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;authResp); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov3" title="2">return authResp.Claims, nil</span>
}

// ValidateToken validates a JWT token and returns the claims
func (s *httpAuthService) ValidateToken(ctx context.Context, token string) (*models.JWTClaims, error) <span class="cov7" title="7">{
        if !s.enabled </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("authentication service is not enabled")
        }</span>

        <span class="cov6" title="5">req, err := http.NewRequestWithContext(ctx, http.MethodGet, s.baseURL+"/validate", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov6" title="5">req.Header.Set("Authorization", "Bearer "+token)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov6" title="5">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov3" title="2">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("token validation failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov4" title="3">var claims models.JWTClaims
        if err := json.NewDecoder(resp.Body).Decode(&amp;claims); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov3" title="2">return &amp;claims, nil</span>
}

// IsEnabled returns whether the authentication service is enabled
func (s *httpAuthService) IsEnabled() bool <span class="cov3" title="2">{
        return s.enabled
}</span>

// MockAuthService is a mock implementation for testing
type MockAuthService struct {
        AuthenticateFunc   func(ctx context.Context, username, password string) (*models.JWTClaims, error)
        ValidateTokenFunc  func(ctx context.Context, token string) (*models.JWTClaims, error)
        IsEnabledFunc      func() bool
}

func (m *MockAuthService) Authenticate(ctx context.Context, username, password string) (*models.JWTClaims, error) <span class="cov5" title="4">{
        if m.AuthenticateFunc != nil </span><span class="cov4" title="3">{
                return m.AuthenticateFunc(ctx, username, password)
        }</span>
        <span class="cov1" title="1">return nil, fmt.Errorf("not implemented")</span>
}

func (m *MockAuthService) ValidateToken(ctx context.Context, token string) (*models.JWTClaims, error) <span class="cov5" title="4">{
        if m.ValidateTokenFunc != nil </span><span class="cov4" title="3">{
                return m.ValidateTokenFunc(ctx, token)
        }</span>
        <span class="cov1" title="1">return nil, fmt.Errorf("not implemented")</span>
}

func (m *MockAuthService) IsEnabled() bool <span class="cov4" title="3">{
        if m.IsEnabledFunc != nil </span><span class="cov3" title="2">{
                return m.IsEnabledFunc()
        }</span>
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
)

// FailoverManager handles automatic failover and failback of services
type FailoverManager struct {
        db                      database.Database
        stabilityCheckCount     int           // Number of consecutive healthy checks before failback
        failbackDelay           time.Duration // Minimum time before attempting failback
        consecutiveHealthChecks map[string]int // Track consecutive healthy checks per service
}

// NewFailoverManager creates a new failover manager
func NewFailoverManager(db database.Database) *FailoverManager <span class="cov10" title="4">{
        return &amp;FailoverManager{
                db:                      db,
                stabilityCheckCount:     3,              // Primary must be healthy for 3 consecutive checks
                failbackDelay:           5 * time.Minute, // Wait at least 5 minutes before failback
                consecutiveHealthChecks: make(map[string]int),
        }
}</span>

// CheckFailoverNeeded checks if a service needs failover and executes it if necessary
func (fm *FailoverManager) CheckFailoverNeeded(serviceID string, isHealthy bool, status models.ServiceStatus) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Get service details
        query := `
                SELECT id, name, type, role, failover_group, is_active, status, last_failover_at
                FROM service_registry
                WHERE id = ? AND deleted = 0
        `

        var service struct {
                ID             string
                Name           string
                Type           string
                Role           string
                FailoverGroup  string
                IsActive       int
                Status         string
                LastFailoverAt int64
        }

        err := fm.db.QueryRow(ctx, query, serviceID).Scan(
                &amp;service.ID,
                &amp;service.Name,
                &amp;service.Type,
                &amp;service.Role,
                &amp;service.FailoverGroup,
                &amp;service.IsActive,
                &amp;service.Status,
                &amp;service.LastFailoverAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get service details: %w", err)
        }</span>

        // Only process services that are part of a failover group
        <span class="cov0" title="0">if service.FailoverGroup == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Update consecutive health check count
        <span class="cov0" title="0">if isHealthy </span><span class="cov0" title="0">{
                fm.consecutiveHealthChecks[serviceID]++
        }</span> else<span class="cov0" title="0"> {
                fm.consecutiveHealthChecks[serviceID] = 0
        }</span>

        // Check if failover is needed (active service became unhealthy)
        <span class="cov0" title="0">if service.IsActive == 1 &amp;&amp; !isHealthy &amp;&amp; status == models.ServiceStatusUnhealthy </span><span class="cov0" title="0">{
                logger.Warn("Active service became unhealthy, initiating failover",
                        zap.String("service_id", serviceID),
                        zap.String("service_name", service.Name),
                        zap.String("failover_group", service.FailoverGroup),
                )

                return fm.executeFailover(service.FailoverGroup, service.Type, serviceID)
        }</span>

        // Check if failback is needed (primary recovered while backup is active)
        <span class="cov0" title="0">if service.Role == "primary" &amp;&amp; service.IsActive == 0 &amp;&amp; isHealthy </span><span class="cov0" title="0">{
                consecutiveHealthy := fm.consecutiveHealthChecks[serviceID]
                timeSinceFailover := time.Now().Unix() - service.LastFailoverAt

                // Ensure primary is stable before failing back
                if consecutiveHealthy &gt;= fm.stabilityCheckCount &amp;&amp; timeSinceFailover &gt;= int64(fm.failbackDelay.Seconds()) </span><span class="cov0" title="0">{
                        logger.Info("Primary service recovered and stable, initiating failback",
                                zap.String("service_id", serviceID),
                                zap.String("service_name", service.Name),
                                zap.String("failover_group", service.FailoverGroup),
                                zap.Int("consecutive_healthy", consecutiveHealthy),
                        )

                        return fm.executeFailback(service.FailoverGroup, service.Type, serviceID)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeFailover performs failover from unhealthy active service to backup
func (fm *FailoverManager) executeFailover(failoverGroup, serviceType, oldServiceID string) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Find the best backup service in the same failover group
        query := `
                SELECT id, name, url, status, priority
                FROM service_registry
                WHERE failover_group = ?
                  AND type = ?
                  AND role = 'backup'
                  AND status = 'healthy'
                  AND deleted = 0
                  AND is_active = 0
                ORDER BY priority DESC, health_check_count DESC
                LIMIT 1
        `

        var backup struct {
                ID       string
                Name     string
                URL      string
                Status   string
                Priority int
        }

        err := fm.db.QueryRow(ctx, query, failoverGroup, serviceType).Scan(
                &amp;backup.ID,
                &amp;backup.Name,
                &amp;backup.URL,
                &amp;backup.Status,
                &amp;backup.Priority,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("No healthy backup service available for failover",
                        zap.String("failover_group", failoverGroup),
                        zap.String("service_type", serviceType),
                        zap.Error(err),
                )
                return fmt.Errorf("no healthy backup available: %w", err)
        }</span>

        // Perform failover in a transaction-like manner
        <span class="cov0" title="0">now := time.Now().Unix()

        // 1. Deactivate old service
        _, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 0, last_failover_at = ? WHERE id = ?",
                now, oldServiceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate old service: %w", err)
        }</span>

        // 2. Activate backup service
        <span class="cov0" title="0">_, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 1, last_failover_at = ? WHERE id = ?",
                now, backup.ID)
        if err != nil </span><span class="cov0" title="0">{
                // Rollback: reactivate old service
                fm.db.Exec(ctx, "UPDATE service_registry SET is_active = 1 WHERE id = ?", oldServiceID)
                return fmt.Errorf("failed to activate backup service: %w", err)
        }</span>

        // 3. Record failover event
        <span class="cov0" title="0">event := models.ServiceFailoverEvent{
                ID:             uuid.New().String(),
                FailoverGroup:  failoverGroup,
                ServiceType:    models.ServiceType(serviceType),
                OldServiceID:   oldServiceID,
                NewServiceID:   backup.ID,
                FailoverReason: "Primary service became unhealthy",
                FailoverType:   "failover",
                Timestamp:      time.Now(),
                Automatic:      true,
        }

        _, err = fm.db.Exec(ctx, `
                INSERT INTO service_failover_events (
                        id, failover_group, service_type, old_service_id, new_service_id,
                        failover_reason, failover_type, timestamp, automatic
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, event.ID, event.FailoverGroup, event.ServiceType, event.OldServiceID,
                event.NewServiceID, event.FailoverReason, event.FailoverType,
                event.Timestamp.Unix(), 1)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to record failover event", zap.Error(err))
                // Don't fail the failover for logging issues
        }</span>

        <span class="cov0" title="0">logger.Info("Failover completed successfully",
                zap.String("failover_group", failoverGroup),
                zap.String("old_service", oldServiceID),
                zap.String("new_service", backup.ID),
                zap.String("backup_name", backup.Name),
                zap.String("backup_url", backup.URL),
        )

        return nil</span>
}

// executeFailback performs failback to primary service when it recovers
func (fm *FailoverManager) executeFailback(failoverGroup, serviceType, primaryServiceID string) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Find the currently active backup
        query := `
                SELECT id, name
                FROM service_registry
                WHERE failover_group = ?
                  AND type = ?
                  AND is_active = 1
                  AND deleted = 0
                LIMIT 1
        `

        var activeBackup struct {
                ID   string
                Name string
        }

        err := fm.db.QueryRow(ctx, query, failoverGroup, serviceType).Scan(
                &amp;activeBackup.ID,
                &amp;activeBackup.Name,
        )

        if err != nil </span><span class="cov0" title="0">{
                // No active backup found, primary might already be active
                return nil
        }</span>

        // Perform failback
        <span class="cov0" title="0">now := time.Now().Unix()

        // 1. Deactivate backup
        _, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 0, last_failover_at = ? WHERE id = ?",
                now, activeBackup.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate backup: %w", err)
        }</span>

        // 2. Activate primary
        <span class="cov0" title="0">_, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 1, last_failover_at = ? WHERE id = ?",
                now, primaryServiceID)
        if err != nil </span><span class="cov0" title="0">{
                // Rollback: reactivate backup
                fm.db.Exec(ctx, "UPDATE service_registry SET is_active = 1 WHERE id = ?", activeBackup.ID)
                return fmt.Errorf("failed to activate primary: %w", err)
        }</span>

        // 3. Record failback event
        <span class="cov0" title="0">event := models.ServiceFailoverEvent{
                ID:             uuid.New().String(),
                FailoverGroup:  failoverGroup,
                ServiceType:    models.ServiceType(serviceType),
                OldServiceID:   activeBackup.ID,
                NewServiceID:   primaryServiceID,
                FailoverReason: "Primary service recovered and stable",
                FailoverType:   "failback",
                Timestamp:      time.Now(),
                Automatic:      true,
        }

        _, err = fm.db.Exec(ctx, `
                INSERT INTO service_failover_events (
                        id, failover_group, service_type, old_service_id, new_service_id,
                        failover_reason, failover_type, timestamp, automatic
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, event.ID, event.FailoverGroup, event.ServiceType, event.OldServiceID,
                event.NewServiceID, event.FailoverReason, event.FailoverType,
                event.Timestamp.Unix(), 1)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to record failback event", zap.Error(err))
                // Don't fail the failback for logging issues
        }</span>

        // Reset consecutive health check counter
        <span class="cov0" title="0">fm.consecutiveHealthChecks[primaryServiceID] = 0

        logger.Info("Failback completed successfully",
                zap.String("failover_group", failoverGroup),
                zap.String("backup_service", activeBackup.ID),
                zap.String("primary_service", primaryServiceID),
        )

        return nil</span>
}

// GetFailoverHistory returns recent failover events for a failover group
func (fm *FailoverManager) GetFailoverHistory(failoverGroup string, limit int) ([]models.ServiceFailoverEvent, error) <span class="cov0" title="0">{
        ctx := context.Background()

        query := `
                SELECT id, failover_group, service_type, old_service_id, new_service_id,
                       failover_reason, failover_type, timestamp, automatic
                FROM service_failover_events
                WHERE failover_group = ?
                ORDER BY timestamp DESC
                LIMIT ?
        `

        rows, err := fm.db.Query(ctx, query, failoverGroup, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query failover history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []models.ServiceFailoverEvent

        for rows.Next() </span><span class="cov0" title="0">{
                var event models.ServiceFailoverEvent
                var timestamp int64
                var automatic int

                err := rows.Scan(
                        &amp;event.ID,
                        &amp;event.FailoverGroup,
                        &amp;event.ServiceType,
                        &amp;event.OldServiceID,
                        &amp;event.NewServiceID,
                        &amp;event.FailoverReason,
                        &amp;event.FailoverType,
                        &amp;timestamp,
                        &amp;automatic,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan failover event: %w", err)
                }</span>

                <span class="cov0" title="0">event.Timestamp = time.Unix(timestamp, 0)
                event.Automatic = automatic == 1

                events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}

// GetActiveService returns the currently active service for a failover group and type
func (fm *FailoverManager) GetActiveService(failoverGroup string, serviceType models.ServiceType) (*models.ServiceRegistration, error) <span class="cov0" title="0">{
        ctx := context.Background()

        query := `
                SELECT id, name, type, version, url, health_check_url, status, role,
                       failover_group, is_active, priority, last_health_check
                FROM service_registry
                WHERE failover_group = ?
                  AND type = ?
                  AND is_active = 1
                  AND deleted = 0
                LIMIT 1
        `

        var service models.ServiceRegistration
        var lastHealthCheck int64

        err := fm.db.QueryRow(ctx, query, failoverGroup, serviceType).Scan(
                &amp;service.ID,
                &amp;service.Name,
                &amp;service.Type,
                &amp;service.Version,
                &amp;service.URL,
                &amp;service.HealthCheckURL,
                &amp;service.Status,
                &amp;service.Role,
                &amp;service.FailoverGroup,
                &amp;service.IsActive,
                &amp;service.Priority,
                &amp;lastHealthCheck,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no active service found: %w", err)
        }</span>

        <span class="cov0" title="0">if lastHealthCheck &gt; 0 </span><span class="cov0" title="0">{
                service.LastHealthCheck = time.Unix(lastHealthCheck, 0)
        }</span>

        <span class="cov0" title="0">return &amp;service, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package services

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "go.uber.org/zap"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
)

// HealthChecker performs periodic health checks on registered services
type HealthChecker struct {
        db               database.Database
        httpClient       *http.Client
        checkInterval    time.Duration
        checkTimeout     time.Duration
        stopChan         chan struct{}
        wg               sync.WaitGroup
        mu               sync.RWMutex
        running          bool
        failureThreshold int // Number of failures before marking unhealthy
        failoverManager  *FailoverManager
}

// NewHealthChecker creates a new health checker
func NewHealthChecker(db database.Database, checkInterval, checkTimeout time.Duration) *HealthChecker <span class="cov10" title="3">{
        return &amp;HealthChecker{
                db:            db,
                httpClient: &amp;http.Client{
                        Timeout: checkTimeout,
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse // Don't follow redirects
                        }</span>,
                },
                checkInterval:    checkInterval,
                checkTimeout:     checkTimeout,
                stopChan:         make(chan struct{}),
                failureThreshold: 3, // Mark unhealthy after 3 consecutive failures
                failoverManager:  NewFailoverManager(db),
        }
}

// Start begins the health check loop
func (h *HealthChecker) Start() error <span class="cov6" title="2">{
        h.mu.Lock()
        if h.running </span><span class="cov1" title="1">{
                h.mu.Unlock()
                return fmt.Errorf("health checker is already running")
        }</span>
        <span class="cov1" title="1">h.running = true
        h.mu.Unlock()

        logger.Info("Starting service health checker", zap.Duration("interval", h.checkInterval))

        h.wg.Add(1)
        go h.checkLoop()

        return nil</span>
}

// Stop stops the health check loop
func (h *HealthChecker) Stop() <span class="cov6" title="2">{
        h.mu.Lock()
        if !h.running </span><span class="cov1" title="1">{
                h.mu.Unlock()
                return
        }</span>
        <span class="cov1" title="1">h.running = false
        h.mu.Unlock()

        close(h.stopChan)
        h.wg.Wait()

        logger.Info("Service health checker stopped")</span>
}

// IsRunning returns whether the health checker is currently running
func (h *HealthChecker) IsRunning() bool <span class="cov10" title="3">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.running
}</span>

// checkLoop is the main health check loop
func (h *HealthChecker) checkLoop() <span class="cov1" title="1">{
        defer h.wg.Done()

        ticker := time.NewTicker(h.checkInterval)
        defer ticker.Stop()

        // Perform initial check immediately
        h.checkAllServices()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.checkAllServices()</span>
                case &lt;-h.stopChan:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// checkAllServices checks health of all registered services
func (h *HealthChecker) checkAllServices() <span class="cov1" title="1">{
        ctx := context.Background()

        // Get all non-deleted, non-decommissioned services
        query := `
                SELECT id, name, type, url, health_check_url, status, failed_health_count
                FROM service_registry
                WHERE deleted = 0 AND status != ?
        `

        rows, err := h.db.Query(ctx, query, models.ServiceStatusDecommission)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to query services for health check", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var services []struct {
                ID               string
                Name             string
                Type             string
                URL              string
                HealthCheckURL   string
                Status           string
                FailedHealthCount int
        }

        for rows.Next() </span><span class="cov0" title="0">{
                var svc struct {
                        ID               string
                        Name             string
                        Type             string
                        URL              string
                        HealthCheckURL   string
                        Status           string
                        FailedHealthCount int
                }

                err := rows.Scan(&amp;svc.ID, &amp;svc.Name, &amp;svc.Type, &amp;svc.URL, &amp;svc.HealthCheckURL,
                        &amp;svc.Status, &amp;svc.FailedHealthCount)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan service row", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">services = append(services, svc)</span>
        }

        // Check each service in parallel
        <span class="cov0" title="0">var wg sync.WaitGroup
        for _, svc := range services </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(s struct {
                        ID               string
                        Name             string
                        Type             string
                        URL              string
                        HealthCheckURL   string
                        Status           string
                        FailedHealthCount int
                }) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        h.checkService(s.ID, s.Name, s.HealthCheckURL, s.FailedHealthCount)
                }</span>(svc)
        }

        <span class="cov0" title="0">wg.Wait()</span>
}

// checkService performs a health check on a single service
func (h *HealthChecker) checkService(serviceID, serviceName, healthCheckURL string, currentFailures int) <span class="cov0" title="0">{
        ctx := context.Background()
        startTime := time.Now()

        logger.Debug("Checking service health",
                zap.String("service_id", serviceID),
                zap.String("service_name", serviceName),
                zap.String("url", healthCheckURL),
        )

        // Create context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, h.checkTimeout)
        defer cancel()

        // Perform HTTP health check
        req, err := http.NewRequestWithContext(timeoutCtx, http.MethodGet, healthCheckURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.recordHealthCheck(serviceID, false, 0, 0, fmt.Sprintf("Failed to create request: %v", err), currentFailures+1)
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.httpClient.Do(req)
        responseTime := time.Since(startTime).Milliseconds()

        if err != nil </span><span class="cov0" title="0">{
                h.recordHealthCheck(serviceID, false, responseTime, 0, fmt.Sprintf("Request failed: %v", err), currentFailures+1)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Consider 2xx and 3xx status codes as healthy
        healthy := resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400

        var failureCount int
        if healthy </span><span class="cov0" title="0">{
                failureCount = 0 // Reset failure count on success
        }</span> else<span class="cov0" title="0"> {
                failureCount = currentFailures + 1
        }</span>

        <span class="cov0" title="0">errorMsg := ""
        if !healthy </span><span class="cov0" title="0">{
                errorMsg = fmt.Sprintf("Unhealthy status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">h.recordHealthCheck(serviceID, healthy, responseTime, resp.StatusCode, errorMsg, failureCount)</span>
}

// recordHealthCheck records the result of a health check
func (h *HealthChecker) recordHealthCheck(
        serviceID string,
        healthy bool,
        responseTime int64,
        statusCode int,
        errorMessage string,
        failureCount int,
) <span class="cov0" title="0">{
        ctx := context.Background()
        now := time.Now()

        // Determine new status
        var newStatus models.ServiceStatus
        if healthy </span><span class="cov0" title="0">{
                newStatus = models.ServiceStatusHealthy
        }</span> else<span class="cov0" title="0"> {
                if failureCount &gt;= h.failureThreshold </span><span class="cov0" title="0">{
                        newStatus = models.ServiceStatusUnhealthy
                }</span> else<span class="cov0" title="0"> {
                        // Keep current status if below threshold
                        var currentStatus string
                        err := h.db.QueryRow(ctx, "SELECT status FROM service_registry WHERE id = ?", serviceID).Scan(&amp;currentStatus)
                        if err == nil </span><span class="cov0" title="0">{
                                newStatus = models.ServiceStatus(currentStatus)
                        }</span> else<span class="cov0" title="0"> {
                                newStatus = models.ServiceStatusHealthy // Default
                        }</span>
                }
        }

        // Update service registry
        <span class="cov0" title="0">updateQuery := `
                UPDATE service_registry
                SET status = ?,
                    last_health_check = ?,
                    health_check_count = health_check_count + 1,
                    failed_health_count = ?
                WHERE id = ?
        `

        _, err := h.db.Exec(ctx, updateQuery, newStatus, now.Unix(), failureCount, serviceID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update service health status",
                        zap.String("service_id", serviceID),
                        zap.Error(err),
                )
                return
        }</span>

        // Check if failover is needed (automatic failover/failback)
        <span class="cov0" title="0">if err := h.failoverManager.CheckFailoverNeeded(serviceID, healthy, newStatus); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failover check failed",
                        zap.String("service_id", serviceID),
                        zap.Error(err),
                )
                // Don't return - continue with health check recording even if failover fails
        }</span>

        // Insert health check record
        <span class="cov0" title="0">insertQuery := `
                INSERT INTO service_health_check (id, service_id, timestamp, status, response_time, status_code, error_message, checked_by)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        checkID := fmt.Sprintf("hc_%s_%d", serviceID[:8], now.Unix())
        _, err = h.db.Exec(ctx, insertQuery,
                checkID,
                serviceID,
                now.Unix(),
                newStatus,
                responseTime,
                statusCode,
                errorMessage,
                "system",
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to insert health check record",
                        zap.String("service_id", serviceID),
                        zap.Error(err),
                )
                return
        }</span>

        // Log the result
        <span class="cov0" title="0">if healthy </span><span class="cov0" title="0">{
                logger.Debug("Service health check passed",
                        zap.String("service_id", serviceID),
                        zap.Int64("response_time_ms", responseTime),
                        zap.Int("status_code", statusCode),
                )
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Service health check failed",
                        zap.String("service_id", serviceID),
                        zap.Int("failure_count", failureCount),
                        zap.String("status", string(newStatus)),
                        zap.String("error", errorMessage),
                )
        }</span>
}

// CheckServiceNow performs an immediate health check on a specific service
func (h *HealthChecker) CheckServiceNow(serviceID string) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Get service details
        query := `
                SELECT name, health_check_url, failed_health_count
                FROM service_registry
                WHERE id = ? AND deleted = 0
        `

        var name, healthCheckURL string
        var failedHealthCount int

        err := h.db.QueryRow(ctx, query, serviceID).Scan(&amp;name, &amp;healthCheckURL, &amp;failedHealthCount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service not found: %w", err)
        }</span>

        // Perform check
        <span class="cov0" title="0">h.checkService(serviceID, name, healthCheckURL, failedHealthCount)

        return nil</span>
}

// GetServiceHealthHistory returns recent health check history for a service
func (h *HealthChecker) GetServiceHealthHistory(serviceID string, limit int) ([]models.ServiceHealthCheck, error) <span class="cov1" title="1">{
        ctx := context.Background()

        query := `
                SELECT id, service_id, timestamp, status, response_time, status_code, error_message, checked_by
                FROM service_health_check
                WHERE service_id = ?
                ORDER BY timestamp DESC
                LIMIT ?
        `

        rows, err := h.db.Query(ctx, query, serviceID, limit)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to query health check history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var checks []models.ServiceHealthCheck

        for rows.Next() </span><span class="cov0" title="0">{
                var check models.ServiceHealthCheck
                var timestamp int64

                err := rows.Scan(
                        &amp;check.ID,
                        &amp;check.ServiceID,
                        &amp;timestamp,
                        &amp;check.Status,
                        &amp;check.ResponseTime,
                        &amp;check.StatusCode,
                        &amp;check.ErrorMessage,
                        &amp;check.CheckedBy,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan health check row: %w", err)
                }</span>

                <span class="cov0" title="0">check.Timestamp = time.Unix(timestamp, 0)
                checks = append(checks, check)</span>
        }

        <span class="cov0" title="0">return checks, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package services

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "helixtrack.ru/core/internal/models"
)

// JWTService handles JWT token generation and validation
type JWTService struct {
        secretKey string
        issuer    string
        expiry    time.Duration
}

// NewJWTService creates a new JWT service
func NewJWTService(secretKey, issuer string, expiryHours int) *JWTService <span class="cov0" title="0">{
        if secretKey == "" </span><span class="cov0" title="0">{
                secretKey = "helix-track-default-secret-key-change-in-production"
        }</span>
        <span class="cov0" title="0">if issuer == "" </span><span class="cov0" title="0">{
                issuer = "helixtrack-core"
        }</span>
        <span class="cov0" title="0">if expiryHours == 0 </span><span class="cov0" title="0">{
                expiryHours = 24 // Default 24 hours
        }</span>

        <span class="cov0" title="0">return &amp;JWTService{
                secretKey: secretKey,
                issuer:    issuer,
                expiry:    time.Duration(expiryHours) * time.Hour,
        }</span>
}

// GenerateToken generates a JWT token for a user
func (s *JWTService) GenerateToken(username, email, name, role string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiresAt := now.Add(s.expiry)

        claims := &amp;models.JWTClaims{
                Username: username,
                Email:    email,
                Name:     name,
                Role:     role,
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   username,
                        Issuer:    s.issuer,
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        NotBefore: jwt.NewNumericDate(now),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(s.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign token: %w", err)
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// ValidateToken validates a JWT token and returns the claims
func (s *JWTService) ValidateToken(tokenString string) (*models.JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;models.JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(s.secretKey), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*models.JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token claims")</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "net"
        "sync"
        "time"

        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
)

// ServiceInfo represents the service information broadcasted
type ServiceInfo struct {
        Name    string `json:"name"`
        Host    string `json:"host"`
        Port    int    `json:"port"`
        Version string `json:"version"`
        API     string `json:"api"`
}

// NetworkDiscoveryService handles UDP-based service discovery for the Core
type NetworkDiscoveryService struct {
        port          int
        host          string
        broadcastAddr string
        conn          *net.UDPConn
        running       bool
        mu            sync.RWMutex
        serviceInfo   ServiceInfo
}

// NewNetworkDiscoveryService creates a new network discovery service
func NewNetworkDiscoveryService(port int, host string) *NetworkDiscoveryService <span class="cov10" title="5">{
        return &amp;NetworkDiscoveryService{
                port:          port,
                host:          host,
                broadcastAddr: "255.255.255.255:9999", // Standard broadcast port for discovery
                running:       false,
                serviceInfo: ServiceInfo{
                        Name:    "HelixTrack Core",
                        Host:    host,
                        Port:    port,
                        Version: "1.0.0",
                        API:     "v1",
                },
        }
}</span>

// Start begins broadcasting the service via UDP
func (s *NetworkDiscoveryService) Start() error <span class="cov4" title="2">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("network discovery service already running")
        }</span>

        <span class="cov4" title="2">logger.Info("Starting network discovery service",
                zap.String("host", s.host),
                zap.Int("port", s.port))

        // Create UDP connection
        conn, err := net.ListenUDP("udp", &amp;net.UDPAddr{IP: net.IPv4zero, Port: 0})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create UDP connection: %w", err)
        }</span>

        <span class="cov4" title="2">s.conn = conn
        s.running = true

        // Start broadcasting in a goroutine
        go s.broadcastLoop()

        logger.Info("Network discovery service started successfully")

        return nil</span>
}

// Stop stops broadcasting the service
func (s *NetworkDiscoveryService) Stop() error <span class="cov4" title="2">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.running </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="2">logger.Info("Stopping network discovery service")

        s.running = false

        if s.conn != nil </span><span class="cov4" title="2">{
                s.conn.Close()
                s.conn = nil
        }</span>

        <span class="cov4" title="2">logger.Info("Network discovery service stopped")

        return nil</span>
}

// IsRunning returns whether the service is currently running
func (s *NetworkDiscoveryService) IsRunning() bool <span class="cov4" title="2">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// DiscoverServices discovers available HelixTrack services on the network
func (s *NetworkDiscoveryService) DiscoverServices(timeout time.Duration) ([]ServiceInfo, error) <span class="cov1" title="1">{
        // Create a listening connection for discovery
        listenAddr, err := net.ResolveUDPAddr("udp", ":0")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve listen address: %w", err)
        }</span>

        <span class="cov1" title="1">conn, err := net.ListenUDP("udp", listenAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create listen connection: %w", err)
        }</span>
        <span class="cov1" title="1">defer conn.Close()

        // Send discovery request
        broadcastAddr, err := net.ResolveUDPAddr("udp", s.broadcastAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve broadcast address: %w", err)
        }</span>

        <span class="cov1" title="1">request := map[string]string{"action": "discover", "service": "helixtrack"}
        requestData, _ := json.Marshal(request)

        _, err = conn.WriteToUDP(requestData, broadcastAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send discovery request: %w", err)
        }</span>

        // Listen for responses
        <span class="cov1" title="1">conn.SetReadDeadline(time.Now().Add(timeout))

        var services []ServiceInfo
        buffer := make([]byte, 1024)

        for </span><span class="cov1" title="1">{
                n, _, err := conn.ReadFromUDP(buffer)
                if err != nil </span><span class="cov1" title="1">{
                        if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov1" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to read response: %w", err)</span>
                }

                <span class="cov0" title="0">var response ServiceInfo
                if err := json.Unmarshal(buffer[:n], &amp;response); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid responses
                }

                <span class="cov0" title="0">services = append(services, response)</span>
        }

        <span class="cov1" title="1">return services, nil</span>
}

// broadcastLoop continuously broadcasts the service information
func (s *NetworkDiscoveryService) broadcastLoop() <span class="cov4" title="2">{
        ticker := time.NewTicker(5 * time.Second) // Broadcast every 5 seconds
        defer ticker.Stop()

        broadcastAddr, err := net.ResolveUDPAddr("udp", s.broadcastAddr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to resolve broadcast address", zap.Error(err))
                return
        }</span>

        <span class="cov4" title="2">data, err := json.Marshal(s.serviceInfo)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal service info", zap.Error(err))
                return
        }</span>

        <span class="cov4" title="2">for </span><span class="cov4" title="2">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        s.mu.RLock()
                        if !s.running </span><span class="cov0" title="0">{
                                s.mu.RUnlock()
                                return
                        }</span>
                        <span class="cov0" title="0">s.mu.RUnlock()

                        _, err := s.conn.WriteToUDP(data, broadcastAddr)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to broadcast service info", zap.Error(err))
                        }</span>
                }
        }
}

// GetServiceURL returns the full URL for the service
func (s *NetworkDiscoveryService) GetServiceURL() string <span class="cov8" title="4">{
        return fmt.Sprintf("http://%s:%d", s.host, s.port)
}</span>

// GetServicePort returns the service port
func (s *NetworkDiscoveryService) GetServicePort() int <span class="cov8" title="4">{
        return s.port
}</span>

// GetServiceHost returns the service host
func (s *NetworkDiscoveryService) GetServiceHost() string <span class="cov7" title="3">{
        return s.host
}</span>

// UpdatePort updates the service port and service info
func (s *NetworkDiscoveryService) UpdatePort(port int) <span class="cov4" title="2">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.port = port
        s.serviceInfo.Port = port
        s.serviceInfo.Host = s.host

        logger.Info("Network discovery service port updated",
                zap.Int("port", port),
                zap.String("host", s.host),
        )
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package services

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "helixtrack.ru/core/internal/models"
)

// PermissionService defines the interface for permission checking operations
type PermissionService interface {
        // CheckPermission checks if a user has required permission for a context
        CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error)

        // GetUserPermissions retrieves all permissions for a user
        GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error)

        // IsEnabled returns whether the permission service is enabled
        IsEnabled() bool
}

// httpPermissionService is the HTTP-based implementation of PermissionService
type httpPermissionService struct {
        baseURL    string
        httpClient *http.Client
        enabled    bool
}

// NewPermissionService creates a new permission service client
func NewPermissionService(baseURL string, timeout int, enabled bool) PermissionService <span class="cov9" title="17">{
        return &amp;httpPermissionService{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: time.Duration(timeout) * time.Second,
                },
                enabled: enabled,
        }
}</span>

// PermissionCheckRequest represents a permission check request
type PermissionCheckRequest struct {
        Username          string                  `json:"username"`
        Context           string                  `json:"context"`
        RequiredLevel     models.PermissionLevel  `json:"required_level"`
}

// PermissionCheckResponse represents a permission check response
type PermissionCheckResponse struct {
        Allowed bool   `json:"allowed"`
        Reason  string `json:"reason,omitempty"`
}

// UserPermissionsResponse represents a user permissions response
type UserPermissionsResponse struct {
        Permissions []models.Permission `json:"permissions"`
}

// CheckPermission checks if a user has required permission for a context
func (s *httpPermissionService) CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error) <span class="cov7" title="9">{
        if !s.enabled </span><span class="cov3" title="2">{
                // If permission service is disabled, allow all operations (development mode)
                return true, nil
        }</span>

        <span class="cov7" title="7">reqBody := PermissionCheckRequest{
                Username:      username,
                Context:       permissionContext,
                RequiredLevel: requiredLevel,
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov7" title="7">req, err := http.NewRequestWithContext(ctx, http.MethodPost, s.baseURL+"/check", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov7" title="7">req.Header.Set("Content-Type", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov7" title="7">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov4" title="3">{
                body, _ := io.ReadAll(resp.Body)
                return false, fmt.Errorf("permission check failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov5" title="4">var checkResp PermissionCheckResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;checkResp); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov5" title="4">return checkResp.Allowed, nil</span>
}

// GetUserPermissions retrieves all permissions for a user
func (s *httpPermissionService) GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error) <span class="cov6" title="5">{
        if !s.enabled </span><span class="cov3" title="2">{
                // If permission service is disabled, return empty permissions
                return []models.Permission{}, nil
        }</span>

        <span class="cov4" title="3">req, err := http.NewRequestWithContext(ctx, http.MethodGet, s.baseURL+"/permissions/"+username, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov4" title="3">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov4" title="3">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("get permissions failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov3" title="2">var permResp UserPermissionsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;permResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov3" title="2">return permResp.Permissions, nil</span>
}

// IsEnabled returns whether the permission service is enabled
func (s *httpPermissionService) IsEnabled() bool <span class="cov6" title="5">{
        return s.enabled
}</span>

// localPermissionService is a local/in-memory implementation of PermissionService
// This can be used as a free/open-source alternative to proprietary implementations
type localPermissionService struct {
        permissions map[string][]models.Permission // username -&gt; permissions
        enabled     bool
}

// NewLocalPermissionService creates a new local permission service
func NewLocalPermissionService(enabled bool) PermissionService <span class="cov9" title="14">{
        return &amp;localPermissionService{
                permissions: make(map[string][]models.Permission),
                enabled:     enabled,
        }
}</span>

// AddUserPermission adds a permission for a user (for testing/setup)
func (s *localPermissionService) AddUserPermission(username string, permission models.Permission) <span class="cov8" title="12">{
        if s.permissions[username] == nil </span><span class="cov7" title="7">{
                s.permissions[username] = []models.Permission{}
        }</span>
        <span class="cov8" title="12">s.permissions[username] = append(s.permissions[username], permission)</span>
}

// CheckPermission checks if a user has required permission for a context
func (s *localPermissionService) CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error) <span class="cov9" title="15">{
        if !s.enabled </span><span class="cov1" title="1">{
                // If permission service is disabled, allow all operations
                return true, nil
        }</span>

        <span class="cov9" title="14">userPerms, exists := s.permissions[username]
        if !exists </span><span class="cov1" title="1">{
                return false, nil // User has no permissions
        }</span>

        // Check for exact context match or parent context match
        <span class="cov8" title="13">for _, perm := range userPerms </span><span class="cov10" title="18">{
                if perm.Deleted </span><span class="cov1" title="1">{
                        continue</span>
                }

                // Check if permission context matches or is a parent
                <span class="cov9" title="17">if perm.Context == permissionContext || models.IsParentContext(perm.Context, permissionContext) </span><span class="cov8" title="12">{
                        // Check if permission level is sufficient
                        if perm.Level.HasPermission(requiredLevel) </span><span class="cov7" title="8">{
                                return true, nil
                        }</span>
                }
        }

        <span class="cov6" title="5">return false, nil</span>
}

// GetUserPermissions retrieves all permissions for a user
func (s *localPermissionService) GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error) <span class="cov5" title="4">{
        if !s.enabled </span><span class="cov1" title="1">{
                return []models.Permission{}, nil
        }</span>

        <span class="cov4" title="3">userPerms, exists := s.permissions[username]
        if !exists </span><span class="cov1" title="1">{
                return []models.Permission{}, nil
        }</span>

        // Filter out deleted permissions
        <span class="cov3" title="2">activePerms := []models.Permission{}
        for _, perm := range userPerms </span><span class="cov6" title="5">{
                if !perm.Deleted </span><span class="cov5" title="4">{
                        activePerms = append(activePerms, perm)
                }</span>
        }

        <span class="cov3" title="2">return activePerms, nil</span>
}

// IsEnabled returns whether the permission service is enabled
func (s *localPermissionService) IsEnabled() bool <span class="cov4" title="3">{
        return s.enabled
}</span>

// MockPermissionService is a mock implementation for testing
type MockPermissionService struct {
        CheckPermissionFunc    func(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error)
        GetUserPermissionsFunc func(ctx context.Context, username string) ([]models.Permission, error)
        IsEnabledFunc          func() bool
}

func (m *MockPermissionService) CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error) <span class="cov4" title="3">{
        if m.CheckPermissionFunc != nil </span><span class="cov3" title="2">{
                return m.CheckPermissionFunc(ctx, username, permissionContext, requiredLevel)
        }</span>
        <span class="cov1" title="1">return true, nil</span> // Default to allowing
}

func (m *MockPermissionService) GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error) <span class="cov4" title="3">{
        if m.GetUserPermissionsFunc != nil </span><span class="cov3" title="2">{
                return m.GetUserPermissionsFunc(ctx, username)
        }</span>
        <span class="cov1" title="1">return []models.Permission{}, nil</span>
}

func (m *MockPermissionService) IsEnabled() bool <span class="cov3" title="2">{
        if m.IsEnabledFunc != nil </span><span class="cov1" title="1">{
                return m.IsEnabledFunc()
        }</span>
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package websocket

import (
        "time"

        "helixtrack.ru/core/internal/config"
        "helixtrack.ru/core/internal/models"
)

// ConfigToModel converts config.WebSocketConfig to models.WebSocketConfig
func ConfigToModel(cfg config.WebSocketConfig) models.WebSocketConfig <span class="cov0" title="0">{
        return models.WebSocketConfig{
                Enabled:           cfg.Enabled,
                Path:              cfg.Path,
                ReadBufferSize:    cfg.ReadBufferSize,
                WriteBufferSize:   cfg.WriteBufferSize,
                MaxMessageSize:    cfg.MaxMessageSize,
                WriteWait:         time.Duration(cfg.WriteWaitSeconds) * time.Second,
                PongWait:          time.Duration(cfg.PongWaitSeconds) * time.Second,
                PingPeriod:        time.Duration(cfg.PingPeriodSeconds) * time.Second,
                MaxClients:        cfg.MaxClients,
                RequireAuth:       cfg.RequireAuth,
                AllowOrigins:      cfg.AllowOrigins,
                EnableCompression: cfg.EnableCompression,
                HandshakeTimeout:  time.Duration(cfg.HandshakeTimeout) * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package websocket

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// Handler handles WebSocket connections
type Handler struct {
        manager     *Manager
        authService services.AuthService
        config      models.WebSocketConfig
}

// NewHandler creates a new WebSocket handler
func NewHandler(manager *Manager, authService services.AuthService, config models.WebSocketConfig) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                manager:     manager,
                authService: authService,
                config:      config,
        }
}</span>

// HandleConnection handles WebSocket connection upgrades
func (h *Handler) HandleConnection(c *gin.Context) <span class="cov0" title="0">{
        // Check if WebSocket is enabled
        if !h.config.Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, models.NewErrorResponse(
                        models.ErrorCodeServiceUnavailable,
                        "WebSocket service is not enabled",
                        "",
                ))
                return
        }</span>

        // Get JWT token from query parameter or header
        <span class="cov0" title="0">var jwtToken string

        // Check query parameter first (ws://host/ws?token=xxx)
        jwtToken = c.Query("token")

        // Fall back to Authorization header
        if jwtToken == "" </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                        jwtToken = authHeader[7:]
                }</span>
        }

        // Fall back to Sec-WebSocket-Protocol header (common for WebSocket auth)
        <span class="cov0" title="0">if jwtToken == "" </span><span class="cov0" title="0">{
                jwtToken = c.GetHeader("Sec-WebSocket-Protocol")
        }</span>

        // Check if authentication is required
        <span class="cov0" title="0">if h.config.RequireAuth &amp;&amp; jwtToken == "" </span><span class="cov0" title="0">{
                logger.Warn("WebSocket connection attempt without JWT token",
                        zap.String("remoteAddr", c.Request.RemoteAddr),
                )
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeMissingJWT,
                        "JWT token is required for WebSocket connection",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">var claims *models.JWTClaims
        var username string

        // Validate JWT token if provided
        if jwtToken != "" </span><span class="cov0" title="0">{
                jwtMiddleware := middleware.NewJWTMiddleware(h.authService, "")
                validatedClaims, err := jwtMiddleware.ValidateToken(c.Request.Context(), jwtToken)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Invalid JWT token for WebSocket",
                                zap.Error(err),
                                zap.String("remoteAddr", c.Request.RemoteAddr),
                        )
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeInvalidJWT,
                                "Invalid or expired JWT token",
                                "",
                        ))
                        return
                }</span>
                <span class="cov0" title="0">claims = validatedClaims
                username = claims.Username</span>
        } else<span class="cov0" title="0"> {
                // If auth is not required and no token provided, use anonymous connection
                username = "anonymous"
                claims = nil
        }</span>

        // Upgrade connection to WebSocket
        <span class="cov0" title="0">upgrader := h.manager.GetUpgrader()
        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to upgrade to WebSocket",
                        zap.Error(err),
                        zap.String("username", username),
                        zap.String("remoteAddr", c.Request.RemoteAddr),
                )
                return
        }</span>

        // Create client
        <span class="cov0" title="0">client := h.manager.CreateClient(conn, username, claims)

        // Register client with manager
        if err := h.manager.RegisterClient(client); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to register WebSocket client",
                        zap.Error(err),
                        zap.String("clientId", client.ID),
                        zap.String("username", username),
                )
                client.Close()
                return
        }</span>

        <span class="cov0" title="0">logger.Info("WebSocket connection established",
                zap.String("clientId", client.ID),
                zap.String("username", username),
                zap.String("remoteAddr", c.Request.RemoteAddr),
        )</span>
}

// HandleStats returns WebSocket manager statistics
func (h *Handler) HandleStats(c *gin.Context) <span class="cov0" title="0">{
        stats := h.manager.GetStats()

        c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "totalConnections":  stats.TotalConnections,
                "activeConnections": stats.ActiveConnections,
                "totalEvents":       stats.TotalEvents,
                "totalErrors":       stats.TotalErrors,
                "startTime":         stats.StartTime,
                "lastEventTime":     stats.LastEventTime,
                "uptime":            stats.LastEventTime.Sub(stats.StartTime).String(),
        }))
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package websocket

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/gorilla/websocket"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// Manager manages WebSocket connections and event broadcasting
type Manager struct {
        clients         map[string]*models.Client   // Registered clients by ID
        clientsByUser   map[string][]*models.Client // Clients indexed by username
        register        chan *models.Client         // Channel for registering clients
        unregister      chan *models.Client         // Channel for unregistering clients
        broadcast       chan *models.Event          // Channel for broadcasting events
        config          models.WebSocketConfig      // WebSocket configuration
        upgrader        websocket.Upgrader          // WebSocket upgrader
        permService     services.PermissionService  // Permission service for authorization
        mu              sync.RWMutex                // Mutex for thread-safe operations
        ctx             context.Context             // Context for cancellation
        cancel          context.CancelFunc          // Cancel function
        wg              sync.WaitGroup              // Wait group for graceful shutdown
        running         bool                        // Whether the manager is running
        stats           ManagerStats                // Manager statistics
}

// ManagerStats contains statistics about the WebSocket manager
type ManagerStats struct {
        TotalConnections    int64     // Total connections since start
        ActiveConnections   int       // Current active connections
        TotalEvents         int64     // Total events broadcasted
        TotalErrors         int64     // Total errors encountered
        StartTime           time.Time // Manager start time
        LastEventTime       time.Time // Last event broadcast time
        mu                  sync.RWMutex
}

// NewManager creates a new WebSocket manager
func NewManager(config models.WebSocketConfig, permService services.PermissionService) *Manager <span class="cov6" title="4">{
        ctx, cancel := context.WithCancel(context.Background())

        // Configure WebSocket upgrader
        upgrader := websocket.Upgrader{
                ReadBufferSize:   config.ReadBufferSize,
                WriteBufferSize:  config.WriteBufferSize,
                CheckOrigin:      createOriginChecker(config.AllowOrigins),
                HandshakeTimeout: config.HandshakeTimeout,
        }

        if config.EnableCompression </span><span class="cov0" title="0">{
                upgrader.EnableCompression = true
        }</span>

        <span class="cov6" title="4">return &amp;Manager{
                clients:       make(map[string]*models.Client),
                clientsByUser: make(map[string][]*models.Client),
                register:      make(chan *models.Client, 10),
                unregister:    make(chan *models.Client, 10),
                broadcast:     make(chan *models.Event, 256),
                config:        config,
                upgrader:      upgrader,
                permService:   permService,
                ctx:           ctx,
                cancel:        cancel,
                stats: ManagerStats{
                        StartTime: time.Now(),
                },
        }</span>
}

// Start starts the WebSocket manager
func (m *Manager) Start() error <span class="cov6" title="4">{
        m.mu.Lock()
        if m.running </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return fmt.Errorf("manager already running")
        }</span>
        <span class="cov6" title="4">m.running = true
        m.mu.Unlock()

        logger.Info("Starting WebSocket manager",
                zap.Int("maxClients", m.config.MaxClients),
                zap.String("path", m.config.Path),
        )

        m.wg.Add(1)
        go m.run()

        return nil</span>
}

// Stop stops the WebSocket manager gracefully
func (m *Manager) Stop() error <span class="cov6" title="4">{
        m.mu.Lock()
        if !m.running </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return nil
        }</span>
        <span class="cov6" title="4">m.running = false
        m.mu.Unlock()

        logger.Info("Stopping WebSocket manager")

        // Cancel context to stop all goroutines
        m.cancel()

        // Close all channels
        close(m.register)
        close(m.unregister)
        close(m.broadcast)

        // Wait for all goroutines to finish
        m.wg.Wait()

        // Close all client connections
        m.mu.Lock()
        for _, client := range m.clients </span><span class="cov0" title="0">{
                client.Close()
        }</span>
        <span class="cov6" title="4">m.clients = make(map[string]*models.Client)
        m.clientsByUser = make(map[string][]*models.Client)
        m.mu.Unlock()

        logger.Info("WebSocket manager stopped")
        return nil</span>
}

// run is the main event loop for the manager
func (m *Manager) run() <span class="cov6" title="4">{
        defer m.wg.Done()

        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov10" title="12">{
                select </span>{
                case &lt;-m.ctx.Done():<span class="cov6" title="4">
                        return</span>

                case client := &lt;-m.register:<span class="cov6" title="4">
                        m.registerClient(client)</span>

                case client := &lt;-m.unregister:<span class="cov6" title="4">
                        m.unregisterClient(client)</span>

                case event := &lt;-m.broadcast:<span class="cov0" title="0">
                        m.broadcastEvent(event)</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.cleanupStaleConnections()</span>
                }
        }
}

// RegisterClient registers a new WebSocket client
func (m *Manager) RegisterClient(client *models.Client) error <span class="cov6" title="4">{
        // Check max clients limit
        m.mu.RLock()
        currentCount := len(m.clients)
        m.mu.RUnlock()

        if currentCount &gt;= m.config.MaxClients </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum client limit reached")
        }</span>

        <span class="cov6" title="4">select </span>{
        case m.register &lt;- client:<span class="cov6" title="4">
                return nil</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("timeout registering client")</span>
        }
}

// registerClient handles client registration (internal)
func (m *Manager) registerClient(client *models.Client) <span class="cov6" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Add to clients map
        m.clients[client.ID] = client

        // Add to user index
        if _, exists := m.clientsByUser[client.Username]; !exists </span><span class="cov6" title="4">{
                m.clientsByUser[client.Username] = make([]*models.Client, 0)
        }</span>
        <span class="cov6" title="4">m.clientsByUser[client.Username] = append(m.clientsByUser[client.Username], client)

        // Update stats
        m.stats.mu.Lock()
        m.stats.TotalConnections++
        m.stats.ActiveConnections = len(m.clients)
        m.stats.mu.Unlock()

        logger.Info("Client registered",
                zap.String("clientId", client.ID),
                zap.String("username", client.Username),
                zap.Int("activeClients", len(m.clients)),
        )

        // Send connection established event
        connectionEvent := models.NewEvent(
                models.EventConnectionEstablished,
                "connect",
                "connection",
                client.ID,
                client.Username,
                map[string]interface{}{
                        "clientId": client.ID,
                        "time":     time.Now().UTC(),
                },
        )
        m.sendToClient(client, connectionEvent)

        // Start client read/write pumps
        go m.readPump(client)
        go m.writePump(client)</span>
}

// UnregisterClient unregistersa WebSocket client
func (m *Manager) UnregisterClient(client *models.Client) <span class="cov6" title="4">{
        // Check if manager is running before trying to send on channel
        m.mu.RLock()
        running := m.running
        m.mu.RUnlock()

        if !running </span><span class="cov0" title="0">{
                // Manager is stopped, handle unregistration directly
                m.unregisterClient(client)
                return
        }</span>

        // Manager is running, send through channel
        <span class="cov6" title="4">select </span>{
        case m.unregister &lt;- client:<span class="cov6" title="4"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                logger.Error("Timeout unregistering client", zap.String("clientId", client.ID))</span>
        }
}

// unregisterClient handles client unregistration (internal)
func (m *Manager) unregisterClient(client *models.Client) <span class="cov6" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Remove from clients map
        if _, exists := m.clients[client.ID]; exists </span><span class="cov6" title="4">{
                delete(m.clients, client.ID)

                // Remove from user index
                if userClients, exists := m.clientsByUser[client.Username]; exists </span><span class="cov6" title="4">{
                        for i, c := range userClients </span><span class="cov6" title="4">{
                                if c.ID == client.ID </span><span class="cov6" title="4">{
                                        m.clientsByUser[client.Username] = append(userClients[:i], userClients[i+1:]...)
                                        break</span>
                                }
                        }
                        // Remove user entry if no more clients
                        <span class="cov6" title="4">if len(m.clientsByUser[client.Username]) == 0 </span><span class="cov6" title="4">{
                                delete(m.clientsByUser, client.Username)
                        }</span>
                }

                // Close client connection
                <span class="cov6" title="4">client.Close()

                // Update stats
                m.stats.mu.Lock()
                m.stats.ActiveConnections = len(m.clients)
                m.stats.mu.Unlock()

                logger.Info("Client unregistered",
                        zap.String("clientId", client.ID),
                        zap.String("username", client.Username),
                        zap.Int("activeClients", len(m.clients)),
                )</span>
        }
}

// BroadcastEvent broadcasts an event to all subscribed clients
func (m *Manager) BroadcastEvent(event *models.Event) <span class="cov0" title="0">{
        select </span>{
        case m.broadcast &lt;- event:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                logger.Error("Timeout broadcasting event", zap.String("eventId", event.ID))
                m.stats.mu.Lock()
                m.stats.TotalErrors++
                m.stats.mu.Unlock()</span>
        }
}

// broadcastEvent handles event broadcasting (internal)
func (m *Manager) broadcastEvent(event *models.Event) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Update stats
        m.stats.mu.Lock()
        m.stats.TotalEvents++
        m.stats.LastEventTime = time.Now()
        m.stats.mu.Unlock()

        logger.Debug("Broadcasting event",
                zap.String("eventId", event.ID),
                zap.String("type", string(event.Type)),
                zap.String("object", event.Object),
                zap.String("entityId", event.EntityID),
        )

        // Send event to all matching clients
        for _, client := range m.clients </span><span class="cov0" title="0">{
                // Check if client is subscribed to this event
                subscription := client.GetSubscription()
                if !event.MatchesSubscription(subscription) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if client has permission to see this event
                <span class="cov0" title="0">if !m.canClientReceiveEvent(client, event) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Send event to client
                <span class="cov0" title="0">m.sendToClient(client, event)</span>
        }
}

// canClientReceiveEvent checks if a client has permission to receive an event
func (m *Manager) canClientReceiveEvent(client *models.Client, event *models.Event) bool <span class="cov0" title="0">{
        // If no permission context, allow
        if len(event.Context.Permissions) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if client has required permissions
        <span class="cov0" title="0">for _, requiredPerm := range event.Context.Permissions </span><span class="cov0" title="0">{
                permLevel := models.ParsePermissionLevel(requiredPerm)
                if !client.HasPermission(int(permLevel)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // If permission service is enabled, check with service
        <span class="cov0" title="0">if m.permService != nil &amp;&amp; m.permService.IsEnabled() </span><span class="cov0" title="0">{
                allowed, err := m.permService.CheckPermission(
                        m.ctx,
                        client.Username,
                        event.Object,
                        models.PermissionRead,
                )
                if err != nil || !allowed </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// sendToClient sends an event to a specific client
func (m *Manager) sendToClient(client *models.Client, event *models.Event) <span class="cov6" title="4">{
        // Create WebSocket message
        message := models.NewEventMessage(event)
        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal event",
                        zap.Error(err),
                        zap.String("eventId", event.ID),
                )
                return
        }</span>

        // Send to client's send channel
        <span class="cov6" title="4">select </span>{
        case client.Send &lt;- data:<span class="cov6" title="4"></span>
        default:<span class="cov0" title="0">
                // Client buffer is full, disconnect
                logger.Warn("Client send buffer full, disconnecting",
                        zap.String("clientId", client.ID),
                        zap.String("username", client.Username),
                )
                m.UnregisterClient(client)</span>
        }
}

// readPump reads messages from the WebSocket connection
func (m *Manager) readPump(client *models.Client) <span class="cov6" title="4">{
        defer func() </span><span class="cov6" title="4">{
                m.UnregisterClient(client)
        }</span>()

        <span class="cov6" title="4">client.Conn.SetReadLimit(m.config.MaxMessageSize)
        client.Conn.SetReadDeadline(time.Now().Add(m.config.PongWait))
        client.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                client.UpdatePing()
                client.Conn.SetReadDeadline(time.Now().Add(m.config.PongWait))
                return nil
        }</span>)

        <span class="cov6" title="4">for </span><span class="cov6" title="5">{
                _, messageData, err := client.Conn.ReadMessage()
                if err != nil </span><span class="cov6" title="4">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                logger.Error("WebSocket read error",
                                        zap.Error(err),
                                        zap.String("clientId", client.ID),
                                )
                        }</span>
                        <span class="cov6" title="4">break</span>
                }

                <span class="cov1" title="1">client.UpdateActivity()

                // Parse message
                var message models.WebSocketMessage
                if err := json.Unmarshal(messageData, &amp;message); err != nil </span><span class="cov1" title="1">{
                        logger.Error("Failed to unmarshal WebSocket message",
                                zap.Error(err),
                                zap.String("clientId", client.ID),
                        )
                        m.sendError(client, "Invalid message format")
                        continue</span>
                }

                // Handle message
                <span class="cov0" title="0">m.handleClientMessage(client, &amp;message)</span>
        }
}

// writePump writes messages to the WebSocket connection
func (m *Manager) writePump(client *models.Client) <span class="cov6" title="4">{
        ticker := time.NewTicker(m.config.PingPeriod)
        defer func() </span><span class="cov6" title="4">{
                ticker.Stop()
                client.Conn.Close()
        }</span>()

        <span class="cov6" title="4">for </span><span class="cov8" title="9">{
                select </span>{
                case message, ok := &lt;-client.Send:<span class="cov8" title="9">
                        client.Conn.SetWriteDeadline(time.Now().Add(m.config.WriteWait))
                        if !ok </span><span class="cov6" title="4">{
                                // Channel closed
                                client.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov6" title="5">w, err := client.Conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov6" title="5">w.Write(message)

                        // Add queued messages to the current websocket message
                        n := len(client.Send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-client.Send)
                        }</span>

                        <span class="cov6" title="5">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        client.Conn.SetWriteDeadline(time.Now().Add(m.config.WriteWait))
                        if err := client.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// handleClientMessage handles incoming messages from clients
func (m *Manager) handleClientMessage(client *models.Client, message *models.WebSocketMessage) <span class="cov0" title="0">{
        switch message.Type </span>{
        case models.WSMessageTypeSubscribe:<span class="cov0" title="0">
                m.handleSubscribe(client, message)</span>
        case models.WSMessageTypeUnsubscribe:<span class="cov0" title="0">
                m.handleUnsubscribe(client, message)</span>
        case models.WSMessageTypePing:<span class="cov0" title="0">
                m.handlePing(client)</span>
        default:<span class="cov0" title="0">
                logger.Warn("Unknown message type",
                        zap.String("type", message.Type),
                        zap.String("clientId", client.ID),
                )
                m.sendError(client, "Unknown message type")</span>
        }
}

// handleSubscribe handles subscription requests
func (m *Manager) handleSubscribe(client *models.Client, message *models.WebSocketMessage) <span class="cov0" title="0">{
        // Parse subscription from message data
        subscriptionData, err := json.Marshal(message.Data)
        if err != nil </span><span class="cov0" title="0">{
                m.sendError(client, "Invalid subscription data")
                return
        }</span>

        <span class="cov0" title="0">var subscription models.Subscription
        if err := json.Unmarshal(subscriptionData, &amp;subscription); err != nil </span><span class="cov0" title="0">{
                m.sendError(client, "Invalid subscription format")
                return
        }</span>

        // Update client subscription
        <span class="cov0" title="0">client.UpdateSubscription(&amp;subscription)

        logger.Info("Client subscribed",
                zap.String("clientId", client.ID),
                zap.String("username", client.Username),
                zap.Int("eventTypes", len(subscription.EventTypes)),
                zap.Int("entityTypes", len(subscription.EntityTypes)),
        )

        // Send acknowledgment
        ack := models.NewWebSocketMessage(models.WSMessageTypeAck, "subscribe", map[string]interface{}{
                "success": true,
                "message": "Subscription updated",
        })
        ackData, _ := json.Marshal(ack)
        select </span>{
        case client.Send &lt;- ackData:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// handleUnsubscribe handles unsubscription requests
func (m *Manager) handleUnsubscribe(client *models.Client, message *models.WebSocketMessage) <span class="cov0" title="0">{
        // Reset subscription
        client.UpdateSubscription(&amp;models.Subscription{
                EventTypes:   []models.EventType{},
                EntityTypes:  []string{},
                EntityIDs:    []string{},
                Filters:      make(map[string]string),
                IncludeReads: false,
        })

        logger.Info("Client unsubscribed",
                zap.String("clientId", client.ID),
                zap.String("username", client.Username),
        )

        // Send acknowledgment
        ack := models.NewWebSocketMessage(models.WSMessageTypeAck, "unsubscribe", map[string]interface{}{
                "success": true,
                "message": "Unsubscribed",
        })
        ackData, _ := json.Marshal(ack)
        select </span>{
        case client.Send &lt;- ackData:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// handlePing handles ping messages
func (m *Manager) handlePing(client *models.Client) <span class="cov0" title="0">{
        client.UpdatePing()

        // Send pong response
        pong := models.NewWebSocketMessage(models.WSMessageTypePong, "pong", map[string]interface{}{
                "time": time.Now().UTC(),
        })
        pongData, _ := json.Marshal(pong)
        select </span>{
        case client.Send &lt;- pongData:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// sendError sends an error message to a client
func (m *Manager) sendError(client *models.Client, errorMsg string) <span class="cov1" title="1">{
        errorMessage := models.NewErrorMessage(errorMsg)
        data, _ := json.Marshal(errorMessage)
        select </span>{
        case client.Send &lt;- data:<span class="cov1" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// cleanupStaleConnections removes stale connections
func (m *Manager) cleanupStaleConnections() <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        now := time.Now()
        timeout := 2 * m.config.PongWait

        for _, client := range m.clients </span><span class="cov0" title="0">{
                lastPing := client.GetLastPing()
                if now.Sub(lastPing) &gt; timeout </span><span class="cov0" title="0">{
                        logger.Warn("Removing stale connection",
                                zap.String("clientId", client.ID),
                                zap.String("username", client.Username),
                                zap.Duration("lastPing", now.Sub(lastPing)),
                        )
                        m.UnregisterClient(client)
                }</span>
        }
}

// GetStats returns current manager statistics
func (m *Manager) GetStats() ManagerStats <span class="cov6" title="5">{
        m.stats.mu.RLock()
        defer m.stats.mu.RUnlock()
        return m.stats
}</span>

// GetUpgrader returns the WebSocket upgrader
func (m *Manager) GetUpgrader() *websocket.Upgrader <span class="cov6" title="4">{
        return &amp;m.upgrader
}</span>

// CreateClient creates a new client instance
func (m *Manager) CreateClient(conn *websocket.Conn, username string, claims *models.JWTClaims) *models.Client <span class="cov6" title="4">{
        clientID := uuid.New().String()
        return models.NewClient(clientID, conn, username, claims, m)
}</span>

// createOriginChecker creates an origin checker function for the upgrader
func createOriginChecker(allowedOrigins []string) func(r *http.Request) bool <span class="cov6" title="4">{
        return func(r *http.Request) bool </span><span class="cov6" title="4">{
                // If no origins specified or * is specified, allow all
                if len(allowedOrigins) == 0 || contains(allowedOrigins, "*") </span><span class="cov6" title="4">{
                        return true
                }</span>

                <span class="cov0" title="0">origin := r.Header.Get("Origin")
                return contains(allowedOrigins, origin)</span>
        }
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov6" title="4">{
        for _, s := range slice </span><span class="cov6" title="4">{
                if s == item </span><span class="cov6" title="4">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package websocket

import (
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
)

// EventBroadcaster is an interface for broadcasting events to clients
type EventBroadcaster interface {
        BroadcastEvent(event *models.Event)
}

// EventPublisher is an interface for publishing events
type EventPublisher interface {
        // PublishEvent publishes an event to all subscribed clients
        PublishEvent(event *models.Event)

        // PublishEntityEvent publishes an event for entity operations (CRUD)
        PublishEntityEvent(action, object, entityID, username string, data map[string]interface{}, context models.EventContext)

        // IsEnabled returns whether event publishing is enabled
        IsEnabled() bool
}

// Publisher implements the EventPublisher interface
type Publisher struct {
        manager EventBroadcaster
        enabled bool
}

// NewPublisher creates a new event publisher
func NewPublisher(manager EventBroadcaster, enabled bool) EventPublisher <span class="cov5" title="11">{
        return &amp;Publisher{
                manager: manager,
                enabled: enabled,
        }
}</span>

// PublishEvent publishes an event to all subscribed clients
func (p *Publisher) PublishEvent(event *models.Event) <span class="cov10" title="107">{
        if !p.enabled || p.manager == nil </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov9" title="105">logger.Debug("Publishing event",
                zap.String("eventId", event.ID),
                zap.String("type", string(event.Type)),
                zap.String("action", event.Action),
                zap.String("object", event.Object),
                zap.String("entityId", event.EntityID),
                zap.String("username", event.Username),
        )

        p.manager.BroadcastEvent(event)</span>
}

// PublishEntityEvent publishes an event for entity operations (CRUD)
func (p *Publisher) PublishEntityEvent(action, object, entityID, username string, data map[string]interface{}, context models.EventContext) <span class="cov2" title="2">{
        if !p.enabled || p.manager == nil </span><span class="cov1" title="1">{
                return
        }</span>

        // Determine event type based on action and object
        <span class="cov1" title="1">eventType := models.GetEventTypeFromAction(action, object)

        // Create event
        event := models.NewEvent(eventType, action, object, entityID, username, data)
        event.Context = context

        // Publish event
        p.PublishEvent(event)</span>
}

// IsEnabled returns whether event publishing is enabled
func (p *Publisher) IsEnabled() bool <span class="cov3" title="4">{
        return p.enabled
}</span>

// NoOpPublisher is a no-op implementation of EventPublisher
type NoOpPublisher struct{}

// NewNoOpPublisher creates a no-op publisher (for when WebSocket is disabled)
func NewNoOpPublisher() EventPublisher <span class="cov3" title="3">{
        return &amp;NoOpPublisher{}
}</span>

// PublishEvent does nothing
func (n *NoOpPublisher) PublishEvent(event *models.Event) {<span class="cov1" title="1">}</span>

// PublishEntityEvent does nothing
func (n *NoOpPublisher) PublishEntityEvent(action, object, entityID, username string, data map[string]interface{}, context models.EventContext) {<span class="cov1" title="1">}</span>

// IsEnabled returns false
func (n *NoOpPublisher) IsEnabled() bool <span class="cov1" title="1">{
        return false
}</span>

// Helper functions for creating common event contexts

// NewProjectContext creates an event context for project-related events
func NewProjectContext(projectID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                ProjectID:   projectID,
                Permissions: permissions,
        }
}</span>

// NewOrganizationContext creates an event context for organization-related events
func NewOrganizationContext(organizationID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                OrganizationID: organizationID,
                Permissions:    permissions,
        }
}</span>

// NewTeamContext creates an event context for team-related events
func NewTeamContext(teamID, organizationID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                TeamID:         teamID,
                OrganizationID: organizationID,
                Permissions:    permissions,
        }
}</span>

// NewAccountContext creates an event context for account-related events
func NewAccountContext(accountID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                AccountID:   accountID,
                Permissions: permissions,
        }
}</span>

// NewFullContext creates an event context with all fields
func NewFullContext(projectID, organizationID, teamID, accountID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                ProjectID:      projectID,
                OrganizationID: organizationID,
                TeamID:         teamID,
                AccountID:      accountID,
                Permissions:    permissions,
        }
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "helixtrack.ru/core/internal/config"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/server"
)

const (
        defaultConfigPath = "Configurations/default.json"
        version           = "1.0.0"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        configPath := flag.String("config", defaultConfigPath, "Path to configuration file")
        showVersion := flag.Bool("version", false, "Show version and exit")
        flag.Parse()

        // Show version and exit
        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("Helix Track Core v%s\n", version)
                os.Exit(0)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to load configuration: %v\n", err)
                os.Exit(1)
        }</span>

        // Set version
        <span class="cov0" title="0">cfg.Version = version

        // Initialize logger
        if err := logger.Initialize(cfg.Log); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logger.Sync()

        logger.Infof("Starting Helix Track Core v%s", version)
        logger.Infof("Configuration loaded from: %s", *configPath)

        // Create server
        srv, err := server.NewServer(cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to create server: %v", err)
        }</span>

        // Start server in a goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := srv.Start(); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("Server error: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        logger.Info("Shutting down server...")

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Server forced to shutdown: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited successfully")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
