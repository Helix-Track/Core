
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cache: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">helixtrack.ru/core/internal/cache/cache.go (96.4%)</option>
				
				<option value="file1">helixtrack.ru/core/internal/config/config.go (83.5%)</option>
				
				<option value="file2">helixtrack.ru/core/internal/database/database.go (69.0%)</option>
				
				<option value="file3">helixtrack.ru/core/internal/database/optimized_database.go (81.6%)</option>
				
				<option value="file4">helixtrack.ru/core/internal/handlers/account_handler.go (74.6%)</option>
				
				<option value="file5">helixtrack.ru/core/internal/handlers/asset_handler.go (61.2%)</option>
				
				<option value="file6">helixtrack.ru/core/internal/handlers/audit_handler.go (76.0%)</option>
				
				<option value="file7">helixtrack.ru/core/internal/handlers/auth_handler.go (84.9%)</option>
				
				<option value="file8">helixtrack.ru/core/internal/handlers/board_handler.go (27.2%)</option>
				
				<option value="file9">helixtrack.ru/core/internal/handlers/comment_handler.go (85.4%)</option>
				
				<option value="file10">helixtrack.ru/core/internal/handlers/component_handler.go (64.1%)</option>
				
				<option value="file11">helixtrack.ru/core/internal/handlers/customfield_handler.go (65.3%)</option>
				
				<option value="file12">helixtrack.ru/core/internal/handlers/cycle_handler.go (61.3%)</option>
				
				<option value="file13">helixtrack.ru/core/internal/handlers/db_init.go (0.0%)</option>
				
				<option value="file14">helixtrack.ru/core/internal/handlers/extension_handler.go (64.4%)</option>
				
				<option value="file15">helixtrack.ru/core/internal/handlers/filter_handler.go (72.5%)</option>
				
				<option value="file16">helixtrack.ru/core/internal/handlers/handler.go (63.0%)</option>
				
				<option value="file17">helixtrack.ru/core/internal/handlers/label_handler.go (63.0%)</option>
				
				<option value="file18">helixtrack.ru/core/internal/handlers/organization_handler.go (74.7%)</option>
				
				<option value="file19">helixtrack.ru/core/internal/handlers/permission_handler.go (59.5%)</option>
				
				<option value="file20">helixtrack.ru/core/internal/handlers/priority_handler.go (69.6%)</option>
				
				<option value="file21">helixtrack.ru/core/internal/handlers/project_handler.go (92.4%)</option>
				
				<option value="file22">helixtrack.ru/core/internal/handlers/report_handler.go (63.5%)</option>
				
				<option value="file23">helixtrack.ru/core/internal/handlers/repository_handler.go (62.1%)</option>
				
				<option value="file24">helixtrack.ru/core/internal/handlers/resolution_handler.go (65.8%)</option>
				
				<option value="file25">helixtrack.ru/core/internal/handlers/service_discovery_db.go (0.0%)</option>
				
				<option value="file26">helixtrack.ru/core/internal/handlers/service_discovery_handler.go (49.8%)</option>
				
				<option value="file27">helixtrack.ru/core/internal/handlers/team_handler.go (65.6%)</option>
				
				<option value="file28">helixtrack.ru/core/internal/handlers/ticket_handler.go (86.9%)</option>
				
				<option value="file29">helixtrack.ru/core/internal/handlers/ticket_relationship_handler.go (63.8%)</option>
				
				<option value="file30">helixtrack.ru/core/internal/handlers/ticket_status_handler.go (68.9%)</option>
				
				<option value="file31">helixtrack.ru/core/internal/handlers/ticket_type_handler.go (64.1%)</option>
				
				<option value="file32">helixtrack.ru/core/internal/handlers/version_handler.go (63.9%)</option>
				
				<option value="file33">helixtrack.ru/core/internal/handlers/watcher_handler.go (77.5%)</option>
				
				<option value="file34">helixtrack.ru/core/internal/handlers/workflow_handler.go (77.0%)</option>
				
				<option value="file35">helixtrack.ru/core/internal/handlers/workflow_step_handler.go (70.4%)</option>
				
				<option value="file36">helixtrack.ru/core/internal/logger/logger.go (90.7%)</option>
				
				<option value="file37">helixtrack.ru/core/internal/metrics/metrics.go (100.0%)</option>
				
				<option value="file38">helixtrack.ru/core/internal/middleware/jwt.go (90.9%)</option>
				
				<option value="file39">helixtrack.ru/core/internal/middleware/performance.go (90.4%)</option>
				
				<option value="file40">helixtrack.ru/core/internal/middleware/permission.go (100.0%)</option>
				
				<option value="file41">helixtrack.ru/core/internal/models/asset.go (0.0%)</option>
				
				<option value="file42">helixtrack.ru/core/internal/models/audit.go (0.0%)</option>
				
				<option value="file43">helixtrack.ru/core/internal/models/board.go (0.0%)</option>
				
				<option value="file44">helixtrack.ru/core/internal/models/comment.go (0.0%)</option>
				
				<option value="file45">helixtrack.ru/core/internal/models/component.go (0.0%)</option>
				
				<option value="file46">helixtrack.ru/core/internal/models/customfield.go (100.0%)</option>
				
				<option value="file47">helixtrack.ru/core/internal/models/cycle.go (0.0%)</option>
				
				<option value="file48">helixtrack.ru/core/internal/models/errors.go (100.0%)</option>
				
				<option value="file49">helixtrack.ru/core/internal/models/event.go (66.1%)</option>
				
				<option value="file50">helixtrack.ru/core/internal/models/extension.go (0.0%)</option>
				
				<option value="file51">helixtrack.ru/core/internal/models/filter.go (100.0%)</option>
				
				<option value="file52">helixtrack.ru/core/internal/models/jwt.go (97.3%)</option>
				
				<option value="file53">helixtrack.ru/core/internal/models/label.go (0.0%)</option>
				
				<option value="file54">helixtrack.ru/core/internal/models/permission.go (0.0%)</option>
				
				<option value="file55">helixtrack.ru/core/internal/models/priority.go (100.0%)</option>
				
				<option value="file56">helixtrack.ru/core/internal/models/project.go (0.0%)</option>
				
				<option value="file57">helixtrack.ru/core/internal/models/report.go (0.0%)</option>
				
				<option value="file58">helixtrack.ru/core/internal/models/request.go (100.0%)</option>
				
				<option value="file59">helixtrack.ru/core/internal/models/resolution.go (100.0%)</option>
				
				<option value="file60">helixtrack.ru/core/internal/models/response.go (100.0%)</option>
				
				<option value="file61">helixtrack.ru/core/internal/models/service_registry.go (0.0%)</option>
				
				<option value="file62">helixtrack.ru/core/internal/models/ticket.go (0.0%)</option>
				
				<option value="file63">helixtrack.ru/core/internal/models/version.go (100.0%)</option>
				
				<option value="file64">helixtrack.ru/core/internal/models/watcher.go (100.0%)</option>
				
				<option value="file65">helixtrack.ru/core/internal/models/websocket.go (81.8%)</option>
				
				<option value="file66">helixtrack.ru/core/internal/security/audit_log.go (98.6%)</option>
				
				<option value="file67">helixtrack.ru/core/internal/security/brute_force_protection.go (79.5%)</option>
				
				<option value="file68">helixtrack.ru/core/internal/security/csrf_protection.go (59.1%)</option>
				
				<option value="file69">helixtrack.ru/core/internal/security/ddos_protection.go (77.8%)</option>
				
				<option value="file70">helixtrack.ru/core/internal/security/input_validation.go (88.4%)</option>
				
				<option value="file71">helixtrack.ru/core/internal/security/security_headers.go (86.1%)</option>
				
				<option value="file72">helixtrack.ru/core/internal/security/service_signer.go (81.7%)</option>
				
				<option value="file73">helixtrack.ru/core/internal/security/tls_enforcement.go (71.9%)</option>
				
				<option value="file74">helixtrack.ru/core/internal/server/server.go (67.4%)</option>
				
				<option value="file75">helixtrack.ru/core/internal/services/auth_service.go (91.8%)</option>
				
				<option value="file76">helixtrack.ru/core/internal/services/failover_manager.go (1.1%)</option>
				
				<option value="file77">helixtrack.ru/core/internal/services/health_checker.go (31.3%)</option>
				
				<option value="file78">helixtrack.ru/core/internal/services/jwt_service.go (0.0%)</option>
				
				<option value="file79">helixtrack.ru/core/internal/services/permission_service.go (90.7%)</option>
				
				<option value="file80">helixtrack.ru/core/internal/websocket/config.go (0.0%)</option>
				
				<option value="file81">helixtrack.ru/core/internal/websocket/handler.go (0.0%)</option>
				
				<option value="file82">helixtrack.ru/core/internal/websocket/manager.go (56.5%)</option>
				
				<option value="file83">helixtrack.ru/core/internal/websocket/publisher.go (100.0%)</option>
				
				<option value="file84">helixtrack.ru/core/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "sync"
        "time"
)

// Cache defines the caching interface
type Cache interface {
        // Get retrieves a value from cache
        Get(ctx context.Context, key string) (interface{}, bool)

        // Set stores a value in cache with expiration
        Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error

        // Delete removes a value from cache
        Delete(ctx context.Context, key string) error

        // Clear removes all values from cache
        Clear(ctx context.Context) error

        // GetStats returns cache statistics
        GetStats() *CacheStats

        // Close closes the cache connection
        Close() error
}

// CacheStats contains cache performance metrics
type CacheStats struct {
        Hits           int64         // Number of cache hits
        Misses         int64         // Number of cache misses
        Sets           int64         // Number of set operations
        Deletes        int64         // Number of delete operations
        Evictions      int64         // Number of evicted entries
        Size           int           // Current number of entries
        AvgGetDuration time.Duration // Average get operation duration
        AvgSetDuration time.Duration // Average set operation duration
        HitRate        float64       // Cache hit rate (0.0 - 1.0)
}

// cacheEntry represents a single cache entry
type cacheEntry struct {
        value      interface{}
        expiration time.Time
        size       int // Approximate size in bytes
}

// isExpired checks if entry has expired
func (e *cacheEntry) isExpired() bool <span class="cov9" title="109">{
        return time.Now().After(e.expiration)
}</span>

// inMemoryCache is a high-performance in-memory cache
type inMemoryCache struct {
        entries       map[string]*cacheEntry
        mu            sync.RWMutex

        // Statistics
        hits          int64
        misses        int64
        sets          int64
        deletes       int64
        evictions     int64
        totalGetTime  time.Duration
        totalSetTime  time.Duration
        statsMu       sync.RWMutex

        // Configuration
        maxSize       int           // Maximum number of entries
        maxMemory     int64         // Maximum memory in bytes
        currentMemory int64         // Current memory usage
        defaultTTL    time.Duration // Default time-to-live

        // Cleanup
        cleanupInterval time.Duration
        stopCleanup     chan struct{}
        cleanupDone     sync.WaitGroup
}

// CacheConfig contains cache configuration
type CacheConfig struct {
        MaxSize         int           // Maximum entries (0 = unlimited)
        MaxMemory       int64         // Maximum memory in bytes (0 = unlimited)
        DefaultTTL      time.Duration // Default expiration time
        CleanupInterval time.Duration // Cleanup interval
}

// DefaultCacheConfig returns optimized default settings
func DefaultCacheConfig() CacheConfig <span class="cov5" title="13">{
        return CacheConfig{
                MaxSize:         10000,              // 10k entries
                MaxMemory:       256 * 1024 * 1024,  // 256MB
                DefaultTTL:      5 * time.Minute,    // 5 minute default
                CleanupInterval: 1 * time.Minute,    // Cleanup every minute
        }
}</span>

// NewInMemoryCache creates a new high-performance in-memory cache
func NewInMemoryCache(cfg CacheConfig) Cache <span class="cov5" title="13">{
        c := &amp;inMemoryCache{
                entries:         make(map[string]*cacheEntry),
                maxSize:         cfg.MaxSize,
                maxMemory:       cfg.MaxMemory,
                defaultTTL:      cfg.DefaultTTL,
                cleanupInterval: cfg.CleanupInterval,
                stopCleanup:     make(chan struct{}),
        }

        // Start background cleanup
        c.cleanupDone.Add(1)
        go c.cleanupLoop()

        return c
}</span>

// Get retrieves a value from cache
func (c *inMemoryCache) Get(ctx context.Context, key string) (interface{}, bool) <span class="cov10" title="119">{
        start := time.Now()
        defer c.trackGetTime(time.Since(start))

        c.mu.RLock()
        entry, exists := c.entries[key]
        c.mu.RUnlock()

        if !exists </span><span class="cov5" title="10">{
                c.incrementMisses()
                return nil, false
        }</span>

        <span class="cov9" title="109">if entry.isExpired() </span><span class="cov1" title="1">{
                // Remove expired entry
                c.Delete(ctx, key)
                c.incrementMisses()
                return nil, false
        }</span>

        <span class="cov9" title="108">c.incrementHits()
        return entry.value, true</span>
}

// Set stores a value in cache with expiration
func (c *inMemoryCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov9" title="118">{
        start := time.Now()
        defer c.trackSetTime(time.Since(start))

        if expiration == 0 </span><span class="cov0" title="0">{
                expiration = c.defaultTTL
        }</span>

        // Estimate entry size
        <span class="cov9" title="118">size := c.estimateSize(value)

        c.mu.Lock()
        defer c.mu.Unlock()

        // Check if we need to evict
        if c.maxSize &gt; 0 &amp;&amp; len(c.entries) &gt;= c.maxSize </span><span class="cov1" title="1">{
                c.evictOldest()
        }</span>

        // Check memory limit
        <span class="cov9" title="118">if c.maxMemory &gt; 0 </span><span class="cov9" title="118">{
                for c.currentMemory+int64(size) &gt; c.maxMemory &amp;&amp; len(c.entries) &gt; 0 </span><span class="cov0" title="0">{
                        c.evictOldest()
                }</span>
        }

        // Remove old entry size if exists
        <span class="cov9" title="118">if oldEntry, exists := c.entries[key]; exists </span><span class="cov0" title="0">{
                c.currentMemory -= int64(oldEntry.size)
        }</span>

        // Add new entry
        <span class="cov9" title="118">c.entries[key] = &amp;cacheEntry{
                value:      value,
                expiration: time.Now().Add(expiration),
                size:       size,
        }
        c.currentMemory += int64(size)

        c.incrementSets()
        return nil</span>
}

// Delete removes a value from cache
func (c *inMemoryCache) Delete(ctx context.Context, key string) error <span class="cov2" title="2">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if entry, exists := c.entries[key]; exists </span><span class="cov2" title="2">{
                c.currentMemory -= int64(entry.size)
                delete(c.entries, key)
                c.incrementDeletes()
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// Clear removes all values from cache
func (c *inMemoryCache) Clear(ctx context.Context) error <span class="cov1" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.entries = make(map[string]*cacheEntry)
        c.currentMemory = 0

        return nil
}</span>

// GetStats returns cache statistics
func (c *inMemoryCache) GetStats() *CacheStats <span class="cov3" title="4">{
        c.statsMu.RLock()
        hits := c.hits
        misses := c.misses
        sets := c.sets
        deletes := c.deletes
        evictions := c.evictions
        totalGetTime := c.totalGetTime
        totalSetTime := c.totalSetTime
        c.statsMu.RUnlock()

        c.mu.RLock()
        size := len(c.entries)
        c.mu.RUnlock()

        var avgGetDuration, avgSetDuration time.Duration
        var hitRate float64

        totalRequests := hits + misses
        if totalRequests &gt; 0 </span><span class="cov2" title="2">{
                hitRate = float64(hits) / float64(totalRequests)
        }</span>

        <span class="cov3" title="4">if hits &gt; 0 </span><span class="cov2" title="2">{
                avgGetDuration = totalGetTime / time.Duration(hits)
        }</span>

        <span class="cov3" title="4">if sets &gt; 0 </span><span class="cov3" title="4">{
                avgSetDuration = totalSetTime / time.Duration(sets)
        }</span>

        <span class="cov3" title="4">return &amp;CacheStats{
                Hits:           hits,
                Misses:         misses,
                Sets:           sets,
                Deletes:        deletes,
                Evictions:      evictions,
                Size:           size,
                AvgGetDuration: avgGetDuration,
                AvgSetDuration: avgSetDuration,
                HitRate:        hitRate,
        }</span>
}

// Close closes the cache and stops background cleanup
func (c *inMemoryCache) Close() error <span class="cov5" title="13">{
        close(c.stopCleanup)
        c.cleanupDone.Wait()
        return nil
}</span>

// cleanupLoop runs background cleanup of expired entries
func (c *inMemoryCache) cleanupLoop() <span class="cov5" title="13">{
        defer c.cleanupDone.Done()

        ticker := time.NewTicker(c.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov6" title="15">{
                select </span>{
                case &lt;-ticker.C:<span class="cov2" title="2">
                        c.cleanup()</span>
                case &lt;-c.stopCleanup:<span class="cov5" title="13">
                        return</span>
                }
        }
}

// cleanup removes expired entries
func (c *inMemoryCache) cleanup() <span class="cov2" title="2">{
        c.mu.Lock()
        defer c.mu.Unlock()

        now := time.Now()
        for key, entry := range c.entries </span><span class="cov2" title="2">{
                if now.After(entry.expiration) </span><span class="cov2" title="2">{
                        c.currentMemory -= int64(entry.size)
                        delete(c.entries, key)
                        c.incrementEvictions()
                }</span>
        }
}

// evictOldest removes the oldest entry (called with lock held)
func (c *inMemoryCache) evictOldest() <span class="cov1" title="1">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.entries </span><span class="cov3" title="3">{
                if oldestTime.IsZero() || entry.expiration.Before(oldestTime) </span><span class="cov1" title="1">{
                        oldestKey = key
                        oldestTime = entry.expiration
                }</span>
        }

        <span class="cov1" title="1">if oldestKey != "" </span><span class="cov1" title="1">{
                c.currentMemory -= int64(c.entries[oldestKey].size)
                delete(c.entries, oldestKey)
                c.incrementEvictions()
        }</span>
}

// estimateSize estimates the size of a value in bytes
func (c *inMemoryCache) estimateSize(value interface{}) int <span class="cov9" title="118">{
        // Try JSON serialization for size estimation
        if data, err := json.Marshal(value); err == nil </span><span class="cov9" title="118">{
                return len(data)
        }</span>

        // Fallback to rough estimate
        <span class="cov0" title="0">return 100</span> // Default size estimate
}

// Statistics tracking methods
func (c *inMemoryCache) incrementHits() <span class="cov9" title="108">{
        c.statsMu.Lock()
        c.hits++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementMisses() <span class="cov5" title="11">{
        c.statsMu.Lock()
        c.misses++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementSets() <span class="cov9" title="118">{
        c.statsMu.Lock()
        c.sets++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementDeletes() <span class="cov2" title="2">{
        c.statsMu.Lock()
        c.deletes++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) incrementEvictions() <span class="cov3" title="3">{
        c.statsMu.Lock()
        c.evictions++
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) trackGetTime(duration time.Duration) <span class="cov10" title="119">{
        c.statsMu.Lock()
        c.totalGetTime += duration
        c.statsMu.Unlock()
}</span>

func (c *inMemoryCache) trackSetTime(duration time.Duration) <span class="cov9" title="118">{
        c.statsMu.Lock()
        c.totalSetTime += duration
        c.statsMu.Unlock()
}</span>

// BuildCacheKey builds a cache key from components
func BuildCacheKey(components ...string) string <span class="cov3" title="3">{
        key := ""
        for i, component := range components </span><span class="cov3" title="4">{
                if i &gt; 0 </span><span class="cov2" title="2">{
                        key += ":"
                }</span>
                <span class="cov3" title="4">key += component</span>
        }
        <span class="cov3" title="3">return key</span>
}

// CachedQuery executes a query with caching
func CachedQuery[T any](
        ctx context.Context,
        cache Cache,
        key string,
        ttl time.Duration,
        queryFunc func(ctx context.Context) (T, error),
) (T, error) <span class="cov3" title="3">{
        var zero T

        // Try cache first
        if cached, found := cache.Get(ctx, key); found </span><span class="cov1" title="1">{
                if result, ok := cached.(T); ok </span><span class="cov1" title="1">{
                        return result, nil
                }</span>
        }

        // Execute query
        <span class="cov2" title="2">result, err := queryFunc(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return zero, err
        }</span>

        // Store in cache
        <span class="cov1" title="1">_ = cache.Set(ctx, key, result, ttl)

        return result, nil</span>
}

// InvalidatePattern invalidates all cache entries matching a pattern
func InvalidatePattern(ctx context.Context, cache Cache, pattern string) error <span class="cov0" title="0">{
        // Note: This is a simple implementation
        // For production, consider using a cache that supports pattern matching
        return cache.Clear(ctx)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
)

// Config represents the application configuration
type Config struct {
        Log       LogConfig        `json:"log"`
        Listeners []ListenerConfig `json:"listeners"`
        Plugins   []PluginConfig   `json:"plugins"`
        Database  DatabaseConfig   `json:"database"`
        Services  ServicesConfig   `json:"services"`
        WebSocket WebSocketConfig  `json:"websocket"`
        Version   string           `json:"version,omitempty"`
}

// LogConfig represents logging configuration
type LogConfig struct {
        LogPath         string `json:"log_path"`
        LogfileBaseName string `json:"logfile_base_name"`
        LogSizeLimit    int64  `json:"log_size_limit"`
        Level           string `json:"level,omitempty"` // debug, info, warn, error
}

// ListenerConfig represents HTTP listener configuration
type ListenerConfig struct {
        Address  string `json:"address"`
        Port     int    `json:"port"`
        HTTPS    bool   `json:"https"`
        CertFile string `json:"cert_file,omitempty"`
        KeyFile  string `json:"key_file,omitempty"`
}

// PluginConfig represents plugin configuration
type PluginConfig struct {
        Name         string                 `json:"name"`
        Dependencies []string               `json:"dependencies"`
        Config       map[string]interface{} `json:"config"`
}

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Type             string `json:"type"` // sqlite or postgres
        SQLitePath       string `json:"sqlite_path,omitempty"`
        PostgresHost     string `json:"postgres_host,omitempty"`
        PostgresPort     int    `json:"postgres_port,omitempty"`
        PostgresUser     string `json:"postgres_user,omitempty"`
        PostgresPassword string `json:"postgres_password,omitempty"`
        PostgresDatabase string `json:"postgres_database,omitempty"`
        PostgresSSLMode  string `json:"postgres_ssl_mode,omitempty"`
}

// ServicesConfig represents external services configuration
type ServicesConfig struct {
        Authentication ServiceEndpoint            `json:"authentication"`
        Permissions    ServiceEndpoint            `json:"permissions"`
        Lokalisation   *ServiceEndpoint           `json:"lokalisation,omitempty"`
        Extensions     map[string]ServiceEndpoint `json:"extensions,omitempty"`
}

// ServiceEndpoint represents an external service endpoint
type ServiceEndpoint struct {
        Enabled bool   `json:"enabled"`
        URL     string `json:"url"`
        Timeout int    `json:"timeout,omitempty"` // in seconds
}

// WebSocketConfig represents WebSocket configuration
type WebSocketConfig struct {
        Enabled           bool     `json:"enabled"`
        Path              string   `json:"path"`
        ReadBufferSize    int      `json:"readBufferSize"`
        WriteBufferSize   int      `json:"writeBufferSize"`
        MaxMessageSize    int64    `json:"maxMessageSize"`
        WriteWaitSeconds  int      `json:"writeWaitSeconds"`
        PongWaitSeconds   int      `json:"pongWaitSeconds"`
        PingPeriodSeconds int      `json:"pingPeriodSeconds"`
        MaxClients        int      `json:"maxClients"`
        RequireAuth       bool     `json:"requireAuth"`
        AllowOrigins      []string `json:"allowOrigins"`
        EnableCompression bool     `json:"enableCompression"`
        HandshakeTimeout  int      `json:"handshakeTimeout"`
}

// LoadConfig loads configuration from a JSON file
func LoadConfig(path string) (*Config, error) <span class="cov8" title="7">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov7" title="6">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Apply defaults
        <span class="cov7" title="5">config.applyDefaults()

        // Validate configuration
        if err := config.Validate(); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov5" title="3">return &amp;config, nil</span>
}

// applyDefaults applies default values to missing configuration
func (c *Config) applyDefaults() <span class="cov7" title="6">{
        if c.Log.LogPath == "" </span><span class="cov1" title="1">{
                c.Log.LogPath = "/tmp/htCoreLogs"
        }</span>
        <span class="cov7" title="6">if c.Log.LogSizeLimit == 0 </span><span class="cov7" title="5">{
                c.Log.LogSizeLimit = 100000000 // 100MB
        }</span>
        <span class="cov7" title="6">if c.Log.Level == "" </span><span class="cov7" title="6">{
                c.Log.Level = "info"
        }</span>

        <span class="cov7" title="6">if c.Database.Type == "" </span><span class="cov1" title="1">{
                c.Database.Type = "sqlite"
        }</span>
        <span class="cov7" title="6">if c.Database.Type == "sqlite" &amp;&amp; c.Database.SQLitePath == "" </span><span class="cov1" title="1">{
                c.Database.SQLitePath = "Database/Definition.sqlite"
        }</span>
        <span class="cov7" title="6">if c.Database.Type == "postgres" &amp;&amp; c.Database.PostgresSSLMode == "" </span><span class="cov0" title="0">{
                c.Database.PostgresSSLMode = "disable"
        }</span>

        // Set default timeouts for services
        <span class="cov7" title="6">if c.Services.Authentication.Timeout == 0 </span><span class="cov7" title="6">{
                c.Services.Authentication.Timeout = 30
        }</span>
        <span class="cov7" title="6">if c.Services.Permissions.Timeout == 0 </span><span class="cov7" title="6">{
                c.Services.Permissions.Timeout = 30
        }</span>
        <span class="cov7" title="6">if c.Services.Lokalisation != nil &amp;&amp; c.Services.Lokalisation.Timeout == 0 </span><span class="cov0" title="0">{
                c.Services.Lokalisation.Timeout = 30
        }</span>
        <span class="cov7" title="6">for name, ext := range c.Services.Extensions </span><span class="cov0" title="0">{
                if ext.Timeout == 0 </span><span class="cov0" title="0">{
                        ext.Timeout = 30
                        c.Services.Extensions[name] = ext
                }</span>
        }

        // Set default WebSocket configuration
        <span class="cov7" title="6">if c.WebSocket.Path == "" </span><span class="cov7" title="6">{
                c.WebSocket.Path = "/ws"
        }</span>
        <span class="cov7" title="6">if c.WebSocket.ReadBufferSize == 0 </span><span class="cov7" title="6">{
                c.WebSocket.ReadBufferSize = 1024
        }</span>
        <span class="cov7" title="6">if c.WebSocket.WriteBufferSize == 0 </span><span class="cov7" title="6">{
                c.WebSocket.WriteBufferSize = 1024
        }</span>
        <span class="cov7" title="6">if c.WebSocket.MaxMessageSize == 0 </span><span class="cov7" title="6">{
                c.WebSocket.MaxMessageSize = 512 * 1024 // 512KB
        }</span>
        <span class="cov7" title="6">if c.WebSocket.WriteWaitSeconds == 0 </span><span class="cov7" title="6">{
                c.WebSocket.WriteWaitSeconds = 10
        }</span>
        <span class="cov7" title="6">if c.WebSocket.PongWaitSeconds == 0 </span><span class="cov7" title="6">{
                c.WebSocket.PongWaitSeconds = 60
        }</span>
        <span class="cov7" title="6">if c.WebSocket.PingPeriodSeconds == 0 </span><span class="cov7" title="6">{
                c.WebSocket.PingPeriodSeconds = 54 // Must be less than pongWait
        }</span>
        <span class="cov7" title="6">if c.WebSocket.MaxClients == 0 </span><span class="cov7" title="6">{
                c.WebSocket.MaxClients = 1000
        }</span>
        <span class="cov7" title="6">if c.WebSocket.HandshakeTimeout == 0 </span><span class="cov7" title="6">{
                c.WebSocket.HandshakeTimeout = 10
        }</span>
        <span class="cov7" title="6">if len(c.WebSocket.AllowOrigins) == 0 </span><span class="cov7" title="6">{
                c.WebSocket.AllowOrigins = []string{"*"}
        }</span>
        // RequireAuth defaults to true, Enabled defaults to false
        // No need to set defaults for these booleans
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov10" title="11">{
        if len(c.Listeners) == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("at least one listener must be configured")
        }</span>

        <span class="cov9" title="9">for i, listener := range c.Listeners </span><span class="cov9" title="9">{
                if listener.Address == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("listener %d: address is required", i)
                }</span>
                <span class="cov9" title="9">if listener.Port &lt;= 0 || listener.Port &gt; 65535 </span><span class="cov1" title="1">{
                        return fmt.Errorf("listener %d: invalid port %d", i, listener.Port)
                }</span>
                <span class="cov8" title="8">if listener.HTTPS </span><span class="cov3" title="2">{
                        if listener.CertFile == "" </span><span class="cov1" title="1">{
                                return fmt.Errorf("listener %d: cert_file is required for HTTPS", i)
                        }</span>
                        <span class="cov1" title="1">if listener.KeyFile == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("listener %d: key_file is required for HTTPS", i)
                        }</span>
                }
        }

        <span class="cov8" title="7">if c.Database.Type != "sqlite" &amp;&amp; c.Database.Type != "postgres" </span><span class="cov3" title="2">{
                return fmt.Errorf("database type must be 'sqlite' or 'postgres', got '%s'", c.Database.Type)
        }</span>

        <span class="cov7" title="5">if c.Database.Type == "sqlite" &amp;&amp; c.Database.SQLitePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("sqlite_path is required when using sqlite database")
        }</span>

        <span class="cov7" title="5">if c.Database.Type == "postgres" </span><span class="cov3" title="2">{
                if c.Database.PostgresHost == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("postgres_host is required when using postgres database")
                }</span>
                <span class="cov1" title="1">if c.Database.PostgresPort &lt;= 0 || c.Database.PostgresPort &gt; 65535 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid postgres_port: %d", c.Database.PostgresPort)
                }</span>
                <span class="cov1" title="1">if c.Database.PostgresUser == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("postgres_user is required when using postgres database")
                }</span>
                <span class="cov1" title="1">if c.Database.PostgresDatabase == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("postgres_database is required when using postgres database")
                }</span>
        }

        // Validate service endpoints
        <span class="cov6" title="4">if c.Services.Authentication.Enabled &amp;&amp; c.Services.Authentication.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication service URL is required when enabled")
        }</span>
        <span class="cov6" title="4">if c.Services.Permissions.Enabled &amp;&amp; c.Services.Permissions.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("permissions service URL is required when enabled")
        }</span>

        <span class="cov6" title="4">return nil</span>
}

// GetPrimaryListener returns the first configured listener
func (c *Config) GetPrimaryListener() *ListenerConfig <span class="cov6" title="4">{
        if len(c.Listeners) &gt; 0 </span><span class="cov3" title="2">{
                return &amp;c.Listeners[0]
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// GetListenerAddress returns the full address of the primary listener
func (c *Config) GetListenerAddress() string <span class="cov3" title="2">{
        listener := c.GetPrimaryListener()
        if listener == nil </span><span class="cov1" title="1">{
                return ":8080"
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s:%d", listener.Address, listener.Port)</span>
}

// GetWebSocketConfig converts config WebSocketConfig to models.WebSocketConfig
func (c *Config) GetWebSocketConfig() WebSocketConfig <span class="cov0" title="0">{
        return c.WebSocket
}</span>

// IsWebSocketEnabled returns whether WebSocket is enabled
func (c *Config) IsWebSocketEnabled() bool <span class="cov0" title="0">{
        return c.WebSocket.Enabled
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"

        _ "github.com/lib/pq"           // PostgreSQL driver
        _ "github.com/mattn/go-sqlite3" // SQLite driver
        "helixtrack.ru/core/internal/config"
)

// Database represents a database connection interface
type Database interface {
        // Query executes a query that returns rows
        Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)

        // QueryRow executes a query that returns a single row
        QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row

        // Exec executes a query that doesn't return rows
        Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error)

        // Begin starts a transaction
        Begin(ctx context.Context) (*sql.Tx, error)

        // Close closes the database connection
        Close() error

        // Ping verifies the database connection
        Ping(ctx context.Context) error

        // GetType returns the database type (sqlite or postgres)
        GetType() string
}

// db is the concrete implementation of Database interface
type db struct {
        conn   *sql.DB
        dbType string
}

// NewDatabase creates a new database connection based on configuration
func NewDatabase(cfg config.DatabaseConfig) (Database, error) <span class="cov10" title="14">{
        var conn *sql.DB
        var err error

        switch cfg.Type </span>{
        case "sqlite":<span class="cov9" title="13">
                conn, err = sql.Open("sqlite3", cfg.SQLitePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open sqlite database: %w", err)
                }</span>

                // Enable foreign keys for SQLite
                <span class="cov9" title="13">_, err = conn.Exec("PRAGMA foreign_keys = ON")
                if err != nil </span><span class="cov1" title="1">{
                        conn.Close()
                        return nil, fmt.Errorf("failed to enable foreign keys: %w", err)
                }</span>

                // Configure connection pool for SQLite
                <span class="cov9" title="12">conn.SetMaxOpenConns(1)</span> // SQLite only supports one write connection

        case "postgres":<span class="cov0" title="0">
                connStr := fmt.Sprintf(
                        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                        cfg.PostgresHost,
                        cfg.PostgresPort,
                        cfg.PostgresUser,
                        cfg.PostgresPassword,
                        cfg.PostgresDatabase,
                        cfg.PostgresSSLMode,
                )

                conn, err = sql.Open("postgres", connStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open postgres database: %w", err)
                }</span>

                // Configure connection pool for PostgreSQL
                <span class="cov0" title="0">conn.SetMaxOpenConns(25)
                conn.SetMaxIdleConns(5)</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported database type: %s", cfg.Type)</span>
        }

        // Verify connection
        <span class="cov9" title="12">if err := conn.Ping(); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov9" title="12">return &amp;db{
                conn:   conn,
                dbType: cfg.Type,
        }, nil</span>
}

// Query executes a query that returns rows
func (d *db) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov3" title="2">{
        return d.conn.QueryContext(ctx, query, args...)
}</span>

// QueryRow executes a query that returns a single row
func (d *db) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov6" title="5">{
        return d.conn.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a query that doesn't return rows
func (d *db) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov9" title="12">{
        return d.conn.ExecContext(ctx, query, args...)
}</span>

// Begin starts a transaction
func (d *db) Begin(ctx context.Context) (*sql.Tx, error) <span class="cov3" title="2">{
        return d.conn.BeginTx(ctx, nil)
}</span>

// Close closes the database connection
func (d *db) Close() error <span class="cov9" title="12">{
        return d.conn.Close()
}</span>

// Ping verifies the database connection
func (d *db) Ping(ctx context.Context) error <span class="cov4" title="3">{
        return d.conn.PingContext(ctx)
}</span>

// GetType returns the database type
func (d *db) GetType() string <span class="cov3" title="2">{
        return d.dbType
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "sync"
        "time"

        _ "github.com/mattn/go-sqlite3" // SQLite driver
        _ "github.com/lib/pq"           // PostgreSQL driver
        "helixtrack.ru/core/internal/config"
)

// OptimizedDatabase extends Database with performance features
type OptimizedDatabase interface {
        Database

        // PreparedQuery executes a prepared statement with caching
        PreparedQuery(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)

        // PreparedQueryRow executes a prepared statement that returns a single row
        PreparedQueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row

        // PreparedExec executes a prepared statement that doesn't return rows
        PreparedExec(ctx context.Context, query string, args ...interface{}) (sql.Result, error)

        // GetStats returns database performance statistics
        GetStats() *DatabaseStats

        // ClearPreparedStatements clears the prepared statement cache
        ClearPreparedStatements() error
}

// DatabaseStats contains performance metrics
type DatabaseStats struct {
        OpenConnections     int           // Current open connections
        InUseConnections    int           // Connections currently in use
        IdleConnections     int           // Idle connections
        WaitCount           int64         // Total connections waited for
        WaitDuration        time.Duration // Total time waited for connections
        MaxIdleClosed       int64         // Connections closed due to max idle
        MaxLifetimeClosed   int64         // Connections closed due to max lifetime
        PreparedStmtCount   int           // Number of cached prepared statements
        QueryCount          int64         // Total queries executed
        PreparedQueryCount  int64         // Total prepared queries executed
        AvgQueryDuration    time.Duration // Average query execution time
}

// optimizedDB is the high-performance implementation
type optimizedDB struct {
        conn               *sql.DB
        dbType             string
        encryptionKey      string

        // Prepared statement cache
        stmtCache          map[string]*sql.Stmt
        stmtCacheMu        sync.RWMutex

        // Performance metrics
        queryCount         int64
        preparedQueryCount int64
        totalQueryTime     time.Duration
        queryTimeMu        sync.RWMutex
}

// OptimizationConfig contains database optimization settings
type OptimizationConfig struct {
        // Connection Pool Settings
        MaxOpenConns        int           // Maximum number of open connections
        MaxIdleConns        int           // Maximum number of idle connections
        ConnMaxLifetime     time.Duration // Maximum connection lifetime
        ConnMaxIdleTime     time.Duration // Maximum connection idle time

        // SQLCipher Settings (SQLite only)
        EncryptionKey       string        // Encryption key for SQLCipher
        KDFIterations       int           // Key derivation iterations (default: 256000)
        CipherPageSize      int           // Page size in bytes (default: 4096)
        CipherUseHMAC       bool          // Use HMAC for integrity (default: true)

        // Performance Settings
        EnableWAL           bool          // Enable Write-Ahead Logging (SQLite)
        CacheSize           int           // Cache size in pages (SQLite, default: -2000 = 2MB)
        BusyTimeout         int           // Busy timeout in milliseconds (SQLite)
        JournalMode         string        // Journal mode (SQLite, default: WAL)
        Synchronous         string        // Synchronous mode (SQLite, default: NORMAL)
        TempStore           string        // Temp store location (SQLite, default: MEMORY)
        MMAPSize            int64         // Memory-mapped I/O size (SQLite, default: 0 = disabled)

        // PostgreSQL Settings
        StatementTimeout    int           // Statement timeout in milliseconds
        IdleInTxTimeout     int           // Idle in transaction timeout
        EnableJIT           bool          // Enable JIT compilation (PostgreSQL 11+)
}

// DefaultOptimizationConfig returns optimized default settings
func DefaultOptimizationConfig() OptimizationConfig <span class="cov5" title="14">{
        return OptimizationConfig{
                // Connection Pool - Optimized for high concurrency
                MaxOpenConns:      100,                  // High concurrency support
                MaxIdleConns:      25,                   // Keep connections warm
                ConnMaxLifetime:   time.Hour,            // Recycle connections hourly
                ConnMaxIdleTime:   15 * time.Minute,     // Close idle after 15min

                // SQLCipher - Secure with good performance
                KDFIterations:     256000,               // Strong key derivation
                CipherPageSize:    4096,                 // Optimal page size
                CipherUseHMAC:     true,                 // Integrity verification

                // SQLite Performance - Maximum performance
                EnableWAL:         true,                 // Write-Ahead Logging
                CacheSize:         -64000,               // 64MB cache
                BusyTimeout:       5000,                 // 5 second busy timeout
                JournalMode:       "WAL",                // Best concurrency
                Synchronous:       "NORMAL",             // Balance safety/performance
                TempStore:         "MEMORY",             // Fast temp tables
                MMAPSize:          268435456,            // 256MB memory-mapped I/O

                // PostgreSQL - Production optimized
                StatementTimeout:  30000,                // 30 second timeout
                IdleInTxTimeout:   60000,                // 1 minute idle in tx
                EnableJIT:         true,                 // JIT compilation
        }
}</span>

// NewOptimizedDatabase creates a high-performance encrypted database connection
func NewOptimizedDatabase(cfg config.DatabaseConfig, optCfg OptimizationConfig) (OptimizedDatabase, error) <span class="cov5" title="14">{
        var conn *sql.DB
        var err error

        switch cfg.Type </span>{
        case "sqlite":<span class="cov5" title="13">
                // Build SQLCipher connection string with encryption and optimizations
                connStr := cfg.SQLitePath

                // Check if the path already contains parameters (e.g., "file::memory:?cache=shared")
                hasParams := false
                if len(connStr) &gt; 0 &amp;&amp; (connStr[len(connStr)-1] != '/' &amp;&amp; connStr[len(connStr)-1] != '\\') </span><span class="cov5" title="13">{
                        // Check if string contains '?'
                        for i := 0; i &lt; len(connStr); i++ </span><span class="cov9" title="254">{
                                if connStr[i] == '?' </span><span class="cov5" title="12">{
                                        hasParams = true
                                        break</span>
                                }
                        }
                }

                <span class="cov5" title="13">if optCfg.EncryptionKey != "" </span><span class="cov1" title="1">{
                        // Use SQLCipher with encryption
                        if hasParams </span><span class="cov0" title="0">{
                                connStr += fmt.Sprintf("&amp;_pragma_key=%s", optCfg.EncryptionKey)
                        }</span> else<span class="cov1" title="1"> {
                                connStr += fmt.Sprintf("?_pragma_key=%s", optCfg.EncryptionKey)
                                hasParams = true
                        }</span>

                        // Add cipher configuration
                        <span class="cov1" title="1">connStr += fmt.Sprintf("&amp;_pragma_cipher_page_size=%d", optCfg.CipherPageSize)
                        connStr += fmt.Sprintf("&amp;_pragma_kdf_iter=%d", optCfg.KDFIterations)
                        if optCfg.CipherUseHMAC </span><span class="cov1" title="1">{
                                connStr += "&amp;_pragma_cipher_use_hmac=ON"
                        }</span>
                }

                // Add performance pragmas
                <span class="cov5" title="13">separator := "?"
                if hasParams </span><span class="cov5" title="13">{
                        separator = "&amp;"
                }</span>
                <span class="cov5" title="13">connStr += fmt.Sprintf("%s_pragma_foreign_keys=ON", separator)
                connStr += fmt.Sprintf("&amp;_pragma_journal_mode=%s", optCfg.JournalMode)
                connStr += fmt.Sprintf("&amp;_pragma_synchronous=%s", optCfg.Synchronous)
                connStr += fmt.Sprintf("&amp;_pragma_cache_size=%d", optCfg.CacheSize)
                connStr += fmt.Sprintf("&amp;_pragma_temp_store=%s", optCfg.TempStore)
                connStr += fmt.Sprintf("&amp;_pragma_mmap_size=%d", optCfg.MMAPSize)
                connStr += fmt.Sprintf("&amp;_pragma_busy_timeout=%d", optCfg.BusyTimeout)

                // Additional optimizations
                connStr += "&amp;_pragma_locking_mode=NORMAL"  // Allow multiple connections
                connStr += "&amp;_pragma_auto_vacuum=INCREMENTAL" // Incremental vacuum
                connStr += "&amp;_pragma_page_size=4096"       // Optimal page size

                // Open with SQLCipher driver
                if optCfg.EncryptionKey != "" </span><span class="cov1" title="1">{
                        conn, err = sql.Open("sqlite3", connStr)
                }</span> else<span class="cov5" title="12"> {
                        // Fallback to standard SQLite if no encryption
                        conn, err = sql.Open("sqlite3", connStr)
                }</span>

                <span class="cov5" title="13">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open sqlite database: %w", err)
                }</span>

                // Configure connection pool for SQLite
                // Note: SQLite with WAL mode supports multiple readers
                <span class="cov5" title="13">if optCfg.EnableWAL </span><span class="cov5" title="13">{
                        conn.SetMaxOpenConns(optCfg.MaxOpenConns)
                        conn.SetMaxIdleConns(optCfg.MaxIdleConns)
                }</span> else<span class="cov0" title="0"> {
                        conn.SetMaxOpenConns(1) // Single writer mode
                        conn.SetMaxIdleConns(1)
                }</span>

        case "postgres":<span class="cov0" title="0">
                connStr := fmt.Sprintf(
                        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                        cfg.PostgresHost,
                        cfg.PostgresPort,
                        cfg.PostgresUser,
                        cfg.PostgresPassword,
                        cfg.PostgresDatabase,
                        cfg.PostgresSSLMode,
                )

                // Add performance parameters
                if optCfg.StatementTimeout &gt; 0 </span><span class="cov0" title="0">{
                        connStr += fmt.Sprintf(" statement_timeout=%d", optCfg.StatementTimeout)
                }</span>
                <span class="cov0" title="0">if optCfg.IdleInTxTimeout &gt; 0 </span><span class="cov0" title="0">{
                        connStr += fmt.Sprintf(" idle_in_transaction_session_timeout=%d", optCfg.IdleInTxTimeout)
                }</span>

                <span class="cov0" title="0">conn, err = sql.Open("postgres", connStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open postgres database: %w", err)
                }</span>

                // Configure connection pool for PostgreSQL
                <span class="cov0" title="0">conn.SetMaxOpenConns(optCfg.MaxOpenConns)
                conn.SetMaxIdleConns(optCfg.MaxIdleConns)</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported database type: %s", cfg.Type)</span>
        }

        // Set connection pool timeouts
        <span class="cov5" title="13">conn.SetConnMaxLifetime(optCfg.ConnMaxLifetime)
        conn.SetConnMaxIdleTime(optCfg.ConnMaxIdleTime)

        // Verify connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := conn.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Apply PostgreSQL-specific optimizations
        <span class="cov5" title="13">if cfg.Type == "postgres" </span><span class="cov0" title="0">{
                if optCfg.EnableJIT </span><span class="cov0" title="0">{
                        _, _ = conn.Exec("SET jit = ON")
                }</span>
                // Set work_mem for better query performance
                <span class="cov0" title="0">_, _ = conn.Exec("SET work_mem = '64MB'")
                // Set shared_buffers recommendation
                _, _ = conn.Exec("SET shared_buffers = '256MB'")
                // Set effective_cache_size
                _, _ = conn.Exec("SET effective_cache_size = '1GB'")</span>
        }

        <span class="cov5" title="13">return &amp;optimizedDB{
                conn:          conn,
                dbType:        cfg.Type,
                encryptionKey: optCfg.EncryptionKey,
                stmtCache:     make(map[string]*sql.Stmt),
        }, nil</span>
}

// Query executes a query that returns rows
func (d *optimizedDB) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov1" title="1">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        d.incrementQueryCount()
        return d.conn.QueryContext(ctx, query, args...)
}</span>

// QueryRow executes a query that returns a single row
func (d *optimizedDB) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov2" title="2">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        d.incrementQueryCount()
        return d.conn.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a query that doesn't return rows
func (d *optimizedDB) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov8" title="133">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        d.incrementQueryCount()
        return d.conn.ExecContext(ctx, query, args...)
}</span>

// PreparedQuery executes a prepared statement with caching
func (d *optimizedDB) PreparedQuery(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov5" title="12">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        stmt, err := d.getOrCreateStmt(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="12">d.incrementPreparedQueryCount()
        return stmt.QueryContext(ctx, args...)</span>
}

// PreparedQueryRow executes a prepared statement that returns a single row
func (d *optimizedDB) PreparedQueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov8" title="106">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        stmt, err := d.getOrCreateStmt(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to regular query on error
                return d.conn.QueryRowContext(ctx, query, args...)
        }</span>

        <span class="cov8" title="106">d.incrementPreparedQueryCount()
        return stmt.QueryRowContext(ctx, args...)</span>
}

// PreparedExec executes a prepared statement that doesn't return rows
func (d *optimizedDB) PreparedExec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov2" title="3">{
        start := time.Now()
        defer d.trackQueryTime(time.Since(start))

        stmt, err := d.getOrCreateStmt(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">d.incrementPreparedQueryCount()
        return stmt.ExecContext(ctx, args...)</span>
}

// getOrCreateStmt gets a cached prepared statement or creates a new one
func (d *optimizedDB) getOrCreateStmt(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov8" title="121">{
        // Check cache first (read lock)
        d.stmtCacheMu.RLock()
        stmt, exists := d.stmtCache[query]
        d.stmtCacheMu.RUnlock()

        if exists </span><span class="cov8" title="103">{
                return stmt, nil
        }</span>

        // Create new statement (write lock)
        <span class="cov5" title="18">d.stmtCacheMu.Lock()
        defer d.stmtCacheMu.Unlock()

        // Double-check after acquiring write lock
        stmt, exists = d.stmtCache[query]
        if exists </span><span class="cov0" title="0">{
                return stmt, nil
        }</span>

        // Prepare new statement
        <span class="cov5" title="18">stmt, err := d.conn.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare statement: %w", err)
        }</span>

        <span class="cov5" title="18">d.stmtCache[query] = stmt
        return stmt, nil</span>
}

// ClearPreparedStatements clears the prepared statement cache
func (d *optimizedDB) ClearPreparedStatements() error <span class="cov5" title="14">{
        d.stmtCacheMu.Lock()
        defer d.stmtCacheMu.Unlock()

        var lastErr error
        for _, stmt := range d.stmtCache </span><span class="cov5" title="18">{
                if err := stmt.Close(); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                }</span>
        }

        <span class="cov5" title="14">d.stmtCache = make(map[string]*sql.Stmt)
        return lastErr</span>
}

// Begin starts a transaction
func (d *optimizedDB) Begin(ctx context.Context) (*sql.Tx, error) <span class="cov0" title="0">{
        return d.conn.BeginTx(ctx, &amp;sql.TxOptions{
                Isolation: sql.LevelReadCommitted, // Best balance for most workloads
        })
}</span>

// Close closes the database connection and cleans up resources
func (d *optimizedDB) Close() error <span class="cov5" title="13">{
        // Clear prepared statements first
        d.ClearPreparedStatements()

        return d.conn.Close()
}</span>

// Ping verifies the database connection
func (d *optimizedDB) Ping(ctx context.Context) error <span class="cov3" title="4">{
        return d.conn.PingContext(ctx)
}</span>

// GetType returns the database type
func (d *optimizedDB) GetType() string <span class="cov1" title="1">{
        return d.dbType
}</span>

// GetStats returns database performance statistics
func (d *optimizedDB) GetStats() *DatabaseStats <span class="cov5" title="12">{
        stats := d.conn.Stats()

        d.queryTimeMu.RLock()
        queryCount := d.queryCount
        preparedQueryCount := d.preparedQueryCount
        totalQueryTime := d.totalQueryTime
        d.queryTimeMu.RUnlock()

        var avgQueryDuration time.Duration
        totalQueries := queryCount + preparedQueryCount
        if totalQueries &gt; 0 </span><span class="cov5" title="12">{
                avgQueryDuration = totalQueryTime / time.Duration(totalQueries)
        }</span>

        <span class="cov5" title="12">d.stmtCacheMu.RLock()
        preparedStmtCount := len(d.stmtCache)
        d.stmtCacheMu.RUnlock()

        return &amp;DatabaseStats{
                OpenConnections:    stats.OpenConnections,
                InUseConnections:   stats.InUse,
                IdleConnections:    stats.Idle,
                WaitCount:          stats.WaitCount,
                WaitDuration:       stats.WaitDuration,
                MaxIdleClosed:      stats.MaxIdleClosed,
                MaxLifetimeClosed:  stats.MaxLifetimeClosed,
                PreparedStmtCount:  preparedStmtCount,
                QueryCount:         queryCount,
                PreparedQueryCount: preparedQueryCount,
                AvgQueryDuration:   avgQueryDuration,
        }</span>
}

// incrementQueryCount atomically increments the query counter
func (d *optimizedDB) incrementQueryCount() <span class="cov8" title="136">{
        d.queryTimeMu.Lock()
        d.queryCount++
        d.queryTimeMu.Unlock()
}</span>

// incrementPreparedQueryCount atomically increments the prepared query counter
func (d *optimizedDB) incrementPreparedQueryCount() <span class="cov8" title="121">{
        d.queryTimeMu.Lock()
        d.preparedQueryCount++
        d.queryTimeMu.Unlock()
}</span>

// trackQueryTime adds query execution time to total
func (d *optimizedDB) trackQueryTime(duration time.Duration) <span class="cov10" title="257">{
        d.queryTimeMu.Lock()
        d.totalQueryTime += duration
        d.queryTimeMu.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"

        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
)

// AccountCreate handles creating a new account
func (h *Handler) AccountCreate(c *gin.Context, req *models.Request) <span class="cov10" title="4">{
        // Parse the account data from request
        var account models.Account
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal account data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid account data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="4">if err := json.Unmarshal(dataBytes, &amp;account); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal account data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid account data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="4">if account.Title == "" </span><span class="cov5" title="2">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Account title is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov5" title="2">account.ID = uuid.New().String()
        account.Created = time.Now().Unix()
        account.Modified = account.Created
        account.Deleted = false

        // TODO: Store account in database
        // This will be implemented when database layer is updated
        logger.Info("Account created", zap.String("id", account.ID), zap.String("title", account.Title))

        response := models.NewSuccessResponse(map[string]interface{}{
                "account": account,
        })
        c.JSON(http.StatusOK, response)</span>
}

// AccountRead handles reading a single account by ID
func (h *Handler) AccountRead(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        // Get account ID from request data
        accountID, ok := req.Data["id"].(string)
        if !ok || accountID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Account ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve account from database
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Account read requested", zap.String("id", accountID))

        // For now, return a placeholder response
        response := models.NewErrorResponse(models.ErrorCodeInternalError, "Account read not yet implemented", "")
        c.JSON(http.StatusNotImplemented, response)</span>
}

// AccountList handles listing all accounts
func (h *Handler) AccountList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // TODO: Retrieve accounts from database with pagination
        // This will be implemented when database layer is updated
        logger.Info("Account list requested")

        // For now, return empty list
        accounts := []models.Account{}
        response := models.NewSuccessResponse(map[string]interface{}{
                "accounts": accounts,
                "count":    len(accounts),
        })
        c.JSON(http.StatusOK, response)
}</span>

// AccountModify handles updating an existing account
func (h *Handler) AccountModify(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        // Parse the account data from request
        var account models.Account
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal account data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid account data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov5" title="2">if err := json.Unmarshal(dataBytes, &amp;account); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal account data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid account data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov5" title="2">if account.ID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Account ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Update timestamp
        <span class="cov1" title="1">account.Modified = time.Now().Unix()

        // TODO: Update account in database
        // This will be implemented when database layer is updated
        logger.Info("Account modified", zap.String("id", account.ID))

        response := models.NewSuccessResponse(map[string]interface{}{
                "account": account,
        })
        c.JSON(http.StatusOK, response)</span>
}

// AccountRemove handles soft-deleting an account
func (h *Handler) AccountRemove(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        // Get account ID from request data
        accountID, ok := req.Data["id"].(string)
        if !ok || accountID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Account ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Soft-delete account in database (set deleted=true)
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Account removed", zap.String("id", accountID))

        response := models.NewSuccessResponse(map[string]interface{}{
                "id":      accountID,
                "deleted": true,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleAssetCreate creates a new asset
func (h *Handler) handleAssetCreate(c *gin.Context, req *models.Request) <span class="cov8" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse asset data from request
        <span class="cov7" title="4">url, ok := req.Data["url"].(string)
        if !ok || url == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing url",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">asset := &amp;models.Asset{
                ID:          uuid.New().String(),
                URL:         url,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO asset (id, url, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                asset.ID,
                asset.URL,
                asset.Description,
                asset.Created,
                asset.Modified,
                asset.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create asset", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create asset",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">logger.Info("Asset created",
                zap.String("asset_id", asset.ID),
                zap.String("url", asset.URL),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "asset": asset,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleAssetRead reads a single asset by ID
func (h *Handler) handleAssetRead(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get asset ID from request
        <span class="cov7" title="4">assetID, ok := req.Data["id"].(string)
        if !ok || assetID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        // Query asset from database
        <span class="cov6" title="3">query := `
                SELECT id, url, description, created, modified, deleted
                FROM asset
                WHERE id = ? AND deleted = 0
        `

        var asset models.Asset
        err := h.db.QueryRow(c.Request.Context(), query, assetID).Scan(
                &amp;asset.ID,
                &amp;asset.URL,
                &amp;asset.Description,
                &amp;asset.Created,
                &amp;asset.Modified,
                &amp;asset.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Asset not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read asset", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read asset",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Asset read",
                zap.String("asset_id", asset.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "asset": asset,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetList lists all assets
func (h *Handler) handleAssetList(c *gin.Context, req *models.Request) <span class="cov6" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted assets ordered by created
        <span class="cov6" title="3">query := `
                SELECT id, url, description, created, modified, deleted
                FROM asset
                WHERE deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list assets", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list assets",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="3">defer rows.Close()

        assets := make([]models.Asset, 0)
        for rows.Next() </span><span class="cov7" title="4">{
                var asset models.Asset
                err := rows.Scan(
                        &amp;asset.ID,
                        &amp;asset.URL,
                        &amp;asset.Description,
                        &amp;asset.Created,
                        &amp;asset.Modified,
                        &amp;asset.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan asset", zap.Error(err))
                        continue</span>
                }
                <span class="cov7" title="4">assets = append(assets, asset)</span>
        }

        <span class="cov6" title="3">logger.Info("Assets listed",
                zap.Int("count", len(assets)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "assets": assets,
                "count":  len(assets),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetModify updates an existing asset
func (h *Handler) handleAssetModify(c *gin.Context, req *models.Request) <span class="cov8" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov8" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID
        <span class="cov8" title="5">assetID, ok := req.Data["id"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        // Check if asset exists
        <span class="cov8" title="5">checkQuery := `SELECT COUNT(*) FROM asset WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, assetID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Asset not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov7" title="4">updates := make(map[string]interface{})

        if url, ok := req.Data["url"].(string); ok &amp;&amp; url != "" </span><span class="cov1" title="1">{
                updates["url"] = url
        }</span>
        <span class="cov7" title="4">if description, ok := req.Data["description"].(string); ok </span><span class="cov6" title="3">{
                updates["description"] = description
        }</span>

        <span class="cov7" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov6" title="3">query := "UPDATE asset SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov10" title="7">{
                if !first </span><span class="cov7" title="4">{
                        query += ", "
                }</span>
                <span class="cov10" title="7">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov6" title="3">query += " WHERE id = ?"
        args = append(args, assetID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update asset", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update asset",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">logger.Info("Asset updated",
                zap.String("asset_id", assetID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      assetID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetRemove soft-deletes an asset
func (h *Handler) handleAssetRemove(c *gin.Context, req *models.Request) <span class="cov6" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov6" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID
        <span class="cov6" title="3">assetID, ok := req.Data["id"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the asset
        <span class="cov6" title="3">query := `UPDATE asset SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), assetID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete asset", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete asset",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Asset not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Asset deleted",
                zap.String("asset_id", assetID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      assetID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetAddTicket adds an asset to a ticket
func (h *Handler) handleAssetAddTicket(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID and ticket ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov1" title="1">mappingID := uuid.New().String()
        query := `
                INSERT INTO asset_ticket_mapping (id, asset_id, ticket_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        now := time.Now().Unix()
        _, err = h.db.Exec(c.Request.Context(), query, mappingID, assetID, ticketID, now, now, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add asset to ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add asset to ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Asset added to ticket",
                zap.String("asset_id", assetID),
                zap.String("ticket_id", ticketID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "added":    true,
                "assetId":  assetID,
                "ticketId": ticketID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetRemoveTicket removes an asset from a ticket
func (h *Handler) handleAssetRemoveTicket(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID and ticket ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Remove mapping (soft delete)
        <span class="cov1" title="1">query := `UPDATE asset_ticket_mapping SET deleted = 1, modified = ? WHERE asset_id = ? AND ticket_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), assetID, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove asset from ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove asset from ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Asset-ticket mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Asset removed from ticket",
                zap.String("asset_id", assetID),
                zap.String("ticket_id", ticketID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":  true,
                "assetId":  assetID,
                "ticketId": ticketID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetListTickets lists all tickets for an asset
func (h *Handler) handleAssetListTickets(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get asset ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        // Query tickets
        <span class="cov1" title="1">query := `
                SELECT ticket_id
                FROM asset_ticket_mapping
                WHERE asset_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, assetID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list tickets for asset", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list tickets",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        ticketIDs := make([]string, 0)
        for rows.Next() </span><span class="cov6" title="3">{
                var ticketID string
                if err := rows.Scan(&amp;ticketID); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket ID", zap.Error(err))
                        continue</span>
                }
                <span class="cov6" title="3">ticketIDs = append(ticketIDs, ticketID)</span>
        }

        <span class="cov1" title="1">logger.Info("Tickets listed for asset",
                zap.String("asset_id", assetID),
                zap.Int("count", len(ticketIDs)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketIds": ticketIDs,
                "count":     len(ticketIDs),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetAddComment adds an asset to a comment
func (h *Handler) handleAssetAddComment(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID and comment ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">commentID, ok := req.Data["commentId"].(string)
        if !ok || commentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing comment ID",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov1" title="1">mappingID := uuid.New().String()
        query := `
                INSERT INTO asset_comment_mapping (id, asset_id, comment_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        now := time.Now().Unix()
        _, err = h.db.Exec(c.Request.Context(), query, mappingID, assetID, commentID, now, now, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add asset to comment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add asset to comment",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Asset added to comment",
                zap.String("asset_id", assetID),
                zap.String("comment_id", commentID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "added":     true,
                "assetId":   assetID,
                "commentId": commentID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetRemoveComment removes an asset from a comment
func (h *Handler) handleAssetRemoveComment(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID and comment ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">commentID, ok := req.Data["commentId"].(string)
        if !ok || commentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing comment ID",
                        "",
                ))
                return
        }</span>

        // Remove mapping (soft delete)
        <span class="cov1" title="1">query := `UPDATE asset_comment_mapping SET deleted = 1, modified = ? WHERE asset_id = ? AND comment_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), assetID, commentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove asset from comment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove asset from comment",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Asset-comment mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Asset removed from comment",
                zap.String("asset_id", assetID),
                zap.String("comment_id", commentID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":   true,
                "assetId":   assetID,
                "commentId": commentID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetListComments lists all comments for an asset
func (h *Handler) handleAssetListComments(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get asset ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        // Query comments
        <span class="cov1" title="1">query := `
                SELECT comment_id
                FROM asset_comment_mapping
                WHERE asset_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, assetID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list comments for asset", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list comments",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        commentIDs := make([]string, 0)
        for rows.Next() </span><span class="cov4" title="2">{
                var commentID string
                if err := rows.Scan(&amp;commentID); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan comment ID", zap.Error(err))
                        continue</span>
                }
                <span class="cov4" title="2">commentIDs = append(commentIDs, commentID)</span>
        }

        <span class="cov1" title="1">logger.Info("Comments listed for asset",
                zap.String("asset_id", assetID),
                zap.Int("count", len(commentIDs)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "commentIds": commentIDs,
                "count":      len(commentIDs),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetAddProject adds an asset to a project
func (h *Handler) handleAssetAddProject(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID and project ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project ID",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov1" title="1">mappingID := uuid.New().String()
        query := `
                INSERT INTO asset_project_mapping (id, asset_id, project_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        now := time.Now().Unix()
        _, err = h.db.Exec(c.Request.Context(), query, mappingID, assetID, projectID, now, now, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add asset to project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add asset to project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Asset added to project",
                zap.String("asset_id", assetID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "added":     true,
                "assetId":   assetID,
                "projectId": projectID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetRemoveProject removes an asset from a project
func (h *Handler) handleAssetRemoveProject(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "asset", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get asset ID and project ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project ID",
                        "",
                ))
                return
        }</span>

        // Remove mapping (soft delete)
        <span class="cov1" title="1">query := `UPDATE asset_project_mapping SET deleted = 1, modified = ? WHERE asset_id = ? AND project_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), assetID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove asset from project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove asset from project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Asset-project mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Asset removed from project",
                zap.String("asset_id", assetID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":   true,
                "assetId":   assetID,
                "projectId": projectID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAssetListProjects lists all projects for an asset
func (h *Handler) handleAssetListProjects(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get asset ID
        <span class="cov1" title="1">assetID, ok := req.Data["assetId"].(string)
        if !ok || assetID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing asset ID",
                        "",
                ))
                return
        }</span>

        // Query projects
        <span class="cov1" title="1">query := `
                SELECT project_id
                FROM asset_project_mapping
                WHERE asset_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, assetID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list projects for asset", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list projects",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        projectIDs := make([]string, 0)
        for rows.Next() </span><span class="cov7" title="4">{
                var projectID string
                if err := rows.Scan(&amp;projectID); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan project ID", zap.Error(err))
                        continue</span>
                }
                <span class="cov7" title="4">projectIDs = append(projectIDs, projectID)</span>
        }

        <span class="cov1" title="1">logger.Info("Projects listed for asset",
                zap.String("asset_id", assetID),
                zap.Int("count", len(projectIDs)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "projectIds": projectIDs,
                "count":      len(projectIDs),
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleAuditCreate creates a new audit log entry
func (h *Handler) handleAuditCreate(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Parse audit data from request
        <span class="cov6" title="3">action, ok := req.Data["action"].(string)
        if !ok || action == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing action",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">audit := &amp;models.Audit{
                ID:         uuid.New().String(),
                Action:     action,
                UserID:     getStringFromData(req.Data, "userId"),
                EntityID:   getStringFromData(req.Data, "entityId"),
                EntityType: getStringFromData(req.Data, "entityType"),
                Details:    getStringFromData(req.Data, "details"),
                Created:    time.Now().Unix(),
                Modified:   time.Now().Unix(),
                Deleted:    false,
        }

        // Validate audit
        if !audit.IsValidAction() </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid action",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov1" title="1">query := `
                INSERT INTO audit (id, action, user_id, entity_id, entity_type, details, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := h.db.Exec(c.Request.Context(), query,
                audit.ID,
                audit.Action,
                audit.UserID,
                audit.EntityID,
                audit.EntityType,
                audit.Details,
                audit.Created,
                audit.Modified,
                audit.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create audit entry", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create audit entry",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Audit entry created",
                zap.String("audit_id", audit.ID),
                zap.String("action", audit.Action),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "audit": audit,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleAuditRead reads a single audit entry by ID
func (h *Handler) handleAuditRead(c *gin.Context, req *models.Request) <span class="cov6" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get audit ID from request
        <span class="cov6" title="3">auditID, ok := req.Data["id"].(string)
        if !ok || auditID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing audit ID",
                        "",
                ))
                return
        }</span>

        // Query audit from database
        <span class="cov4" title="2">query := `
                SELECT id, action, user_id, entity_id, entity_type, details, created, modified, deleted
                FROM audit
                WHERE id = ? AND deleted = 0
        `

        var audit models.Audit
        var entityID, details sql.NullString
        err := h.db.QueryRow(c.Request.Context(), query, auditID).Scan(
                &amp;audit.ID,
                &amp;audit.Action,
                &amp;audit.UserID,
                &amp;entityID,
                &amp;audit.EntityType,
                &amp;details,
                &amp;audit.Created,
                &amp;audit.Modified,
                &amp;audit.Deleted,
        )

        // Handle nullable fields
        if entityID.Valid </span><span class="cov1" title="1">{
                audit.EntityID = entityID.String
        }</span>
        <span class="cov4" title="2">if details.Valid </span><span class="cov1" title="1">{
                audit.Details = details.String
        }</span>

        <span class="cov4" title="2">if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Audit entry not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read audit entry", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read audit entry",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Audit entry read",
                zap.String("audit_id", audit.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "audit": audit,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAuditList lists all audit entries
func (h *Handler) handleAuditList(c *gin.Context, req *models.Request) <span class="cov6" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted audit entries, ordered by creation time (newest first)
        <span class="cov6" title="3">query := `
                SELECT id, action, user_id, entity_id, entity_type, details, created, modified, deleted
                FROM audit
                WHERE deleted = 0
                ORDER BY created DESC
                LIMIT 1000
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list audit entries", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list audit entries",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="3">defer rows.Close()

        audits := make([]models.Audit, 0)
        for rows.Next() </span><span class="cov10" title="6">{
                var audit models.Audit
                var entityID, details sql.NullString
                err := rows.Scan(
                        &amp;audit.ID,
                        &amp;audit.Action,
                        &amp;audit.UserID,
                        &amp;entityID,
                        &amp;audit.EntityType,
                        &amp;details,
                        &amp;audit.Created,
                        &amp;audit.Modified,
                        &amp;audit.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan audit entry", zap.Error(err))
                        continue</span>
                }

                // Handle nullable fields
                <span class="cov10" title="6">if entityID.Valid </span><span class="cov0" title="0">{
                        audit.EntityID = entityID.String
                }</span>
                <span class="cov10" title="6">if details.Valid </span><span class="cov0" title="0">{
                        audit.Details = details.String
                }</span>

                <span class="cov10" title="6">audits = append(audits, audit)</span>
        }

        <span class="cov6" title="3">logger.Info("Audit entries listed",
                zap.Int("count", len(audits)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "audits": audits,
                "count":  len(audits),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAuditQuery queries audit entries with filters
func (h *Handler) handleAuditQuery(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Build query based on filters
        <span class="cov7" title="4">queryStr := `
                SELECT id, action, user_id, entity_id, entity_type, details, created, modified, deleted
                FROM audit
                WHERE deleted = 0
        `
        args := make([]interface{}, 0)

        // Add filters if provided
        if userID, ok := req.Data["userId"].(string); ok &amp;&amp; userID != "" </span><span class="cov4" title="2">{
                queryStr += " AND user_id = ?"
                args = append(args, userID)
        }</span>

        <span class="cov7" title="4">if action, ok := req.Data["action"].(string); ok &amp;&amp; action != "" </span><span class="cov4" title="2">{
                queryStr += " AND action = ?"
                args = append(args, action)
        }</span>

        <span class="cov7" title="4">if entityType, ok := req.Data["entityType"].(string); ok &amp;&amp; entityType != "" </span><span class="cov1" title="1">{
                queryStr += " AND entity_type = ?"
                args = append(args, entityType)
        }</span>

        <span class="cov7" title="4">if entityID, ok := req.Data["entityId"].(string); ok &amp;&amp; entityID != "" </span><span class="cov0" title="0">{
                queryStr += " AND entity_id = ?"
                args = append(args, entityID)
        }</span>

        // Add time range filters if provided
        <span class="cov7" title="4">if startTime, ok := req.Data["startTime"].(float64); ok </span><span class="cov1" title="1">{
                queryStr += " AND created &gt;= ?"
                args = append(args, int64(startTime))
        }</span>

        <span class="cov7" title="4">if endTime, ok := req.Data["endTime"].(float64); ok </span><span class="cov0" title="0">{
                queryStr += " AND created &lt;= ?"
                args = append(args, int64(endTime))
        }</span>

        // Add ordering and limit
        <span class="cov7" title="4">queryStr += " ORDER BY created DESC LIMIT 1000"

        rows, err := h.db.Query(c.Request.Context(), queryStr, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to query audit entries", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to query audit entries",
                        "",
                ))
                return
        }</span>
        <span class="cov7" title="4">defer rows.Close()

        audits := make([]models.Audit, 0)
        for rows.Next() </span><span class="cov7" title="4">{
                var audit models.Audit
                var entityID, details sql.NullString
                err := rows.Scan(
                        &amp;audit.ID,
                        &amp;audit.Action,
                        &amp;audit.UserID,
                        &amp;entityID,
                        &amp;audit.EntityType,
                        &amp;details,
                        &amp;audit.Created,
                        &amp;audit.Modified,
                        &amp;audit.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan audit entry", zap.Error(err))
                        continue</span>
                }

                // Handle nullable fields
                <span class="cov7" title="4">if entityID.Valid </span><span class="cov1" title="1">{
                        audit.EntityID = entityID.String
                }</span>
                <span class="cov7" title="4">if details.Valid </span><span class="cov0" title="0">{
                        audit.Details = details.String
                }</span>

                <span class="cov7" title="4">audits = append(audits, audit)</span>
        }

        <span class="cov7" title="4">logger.Info("Audit entries queried",
                zap.Int("count", len(audits)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "audits": audits,
                "count":  len(audits),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleAuditAddMeta adds metadata to an audit entry
func (h *Handler) handleAuditAddMeta(c *gin.Context, req *models.Request) <span class="cov6" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Parse metadata from request
        <span class="cov6" title="3">auditID, ok := req.Data["auditId"].(string)
        if !ok || auditID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing auditId",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Value can be any type, convert to JSON string
        <span class="cov1" title="1">var valueStr string
        if value, ok := req.Data["value"]; ok </span><span class="cov1" title="1">{
                valueBytes, err := json.Marshal(value)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid value format",
                                "",
                        ))
                        return
                }</span>
                <span class="cov1" title="1">valueStr = string(valueBytes)</span>
        }

        <span class="cov1" title="1">metadata := &amp;models.AuditMetaData{
                ID:       uuid.New().String(),
                AuditID:  auditID,
                Property: property,
                Value:    valueStr,
                Created:  time.Now().Unix(),
                Modified: time.Now().Unix(),
                Deleted:  false,
        }

        // Insert into database
        query := `
                INSERT INTO audit_metadata (id, audit_id, property, value, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err := h.db.Exec(c.Request.Context(), query,
                metadata.ID,
                metadata.AuditID,
                metadata.Property,
                metadata.Value,
                metadata.Created,
                metadata.Modified,
                metadata.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add audit metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add audit metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Audit metadata added",
                zap.String("metadata_id", metadata.ID),
                zap.String("audit_id", auditID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
        })
        c.JSON(http.StatusCreated, response)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// AuthHandler handles authentication operations
type AuthHandler struct {
        db         database.Database
        jwtService *services.JWTService
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(db database.Database) *AuthHandler <span class="cov7" title="19">{
        jwtService := services.NewJWTService("", "", 24) // Default JWT service
        return &amp;AuthHandler{
                db:         db,
                jwtService: jwtService,
        }
}</span>

// Register handles user registration
func (h *AuthHandler) Register(c *gin.Context) <span class="cov5" title="11">{
        var req models.UserRegistrationRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="6">{
                logger.Error("Failed to bind registration request", zap.Error(err))
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid registration data",
                        "",
                ))
                return
        }</span>

        // Hash password
        <span class="cov4" title="5">passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to hash password", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to process registration",
                        "",
                ))
                return
        }</span>

        // Create user
        <span class="cov4" title="5">user := models.User{
                ID:           uuid.New().String(),
                Username:     req.Username,
                PasswordHash: string(passwordHash),
                Email:        req.Email,
                Name:         req.Name,
                Role:         "user",
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
                Deleted:      false,
        }

        // Insert into database
        query := `
                INSERT INTO users (id, username, password_hash, email, name, role, created_at, updated_at, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(
                context.Background(),
                query,
                user.ID,
                user.Username,
                user.PasswordHash,
                user.Email,
                user.Name,
                user.Role,
                user.CreatedAt.Unix(),
                user.UpdatedAt.Unix(),
                0,
        )

        if err != nil </span><span class="cov2" title="2">{
                logger.Error("Failed to create user", zap.Error(err))
                c.JSON(http.StatusConflict, models.NewErrorResponse(
                        models.ErrorCodeEntityAlreadyExists,
                        "Username or email already exists",
                        "",
                ))
                return
        }</span>

        // Return user response
        <span class="cov3" title="3">response := models.NewSuccessResponse(map[string]interface{}{
                "id":       user.ID,
                "username": user.Username,
                "email":    user.Email,
                "name":     user.Name,
                "role":     user.Role,
        })

        c.JSON(http.StatusCreated, response)</span>
}

// Login handles user login
func (h *AuthHandler) Login(c *gin.Context) <span class="cov5" title="8">{
        var req models.UserLoginRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov2" title="2">{
                logger.Error("Failed to bind login request", zap.Error(err))
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid login data",
                        "",
                ))
                return
        }</span>

        // Get user from database
        <span class="cov4" title="6">query := `
                SELECT id, username, password_hash, email, name, role, created_at, updated_at
                FROM users
                WHERE username = ? AND deleted = 0
        `

        var user models.User
        var createdAt, updatedAt int64

        err := h.db.QueryRow(context.Background(), query, req.Username).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.PasswordHash,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Role,
                &amp;createdAt,
                &amp;updatedAt,
        )

        if err != nil </span><span class="cov2" title="2">{
                logger.Error("User not found", zap.Error(err), zap.String("username", req.Username))
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid username or password",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="4">user.CreatedAt = time.Unix(createdAt, 0)
        user.UpdatedAt = time.Unix(updatedAt, 0)

        // Verify password
        err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password))
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Invalid password", zap.String("username", req.Username))
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid username or password",
                        "",
                ))
                return
        }</span>

        // Generate JWT token
        <span class="cov3" title="3">token, err := h.jwtService.GenerateToken(user.Username, user.Email, user.Name, user.Role)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to generate JWT token", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to generate authentication token",
                        "",
                ))
                return
        }</span>

        // Return success with token
        <span class="cov3" title="3">response := models.NewSuccessResponse(map[string]interface{}{
                "token":    token,
                "username": user.Username,
                "email":    user.Email,
                "name":     user.Name,
                "role":     user.Role,
        })

        c.JSON(http.StatusOK, response)</span>
}

// Logout handles user logout
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov2" title="2">{
        // For a stateless JWT system, logout just returns success
        // In a real system with token blacklisting, you'd invalidate the token
        response := models.NewSuccessResponse(map[string]interface{}{
                "message": "Successfully logged out",
        })
        c.JSON(http.StatusOK, response)
}</span>

// InitializeUserTable creates the users table if it doesn't exist
func InitializeUserTable(db database.Database) error <span class="cov7" title="20">{
        createTableSQL := `
                CREATE TABLE IF NOT EXISTS users (
                        id TEXT PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        password_hash TEXT NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        name TEXT NOT NULL,
                        role TEXT DEFAULT 'user',
                        created_at INTEGER NOT NULL,
                        updated_at INTEGER NOT NULL,
                        deleted INTEGER DEFAULT 0
                );
        `

        _, err := db.Exec(context.Background(), createTableSQL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create indexes
        <span class="cov7" title="20">indexSQL := `
                CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
                CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
        `

        _, err = db.Exec(context.Background(), indexSQL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create default test users if they don't exist
        <span class="cov7" title="20">testUsers := []struct {
                username string
                password string
                email    string
                name     string
                role     string
        }{
                {"admin_user", "Admin@123456", "admin@test.com", "Admin User", "user"},
                {"viewer", "Viewer@123456", "viewer@helixtrack.test", "Viewer User", "user"},
                {"project_manager", "PM@123456", "pm@helixtrack.test", "Project Manager", "user"},
                {"developer", "Dev@123456", "dev@helixtrack.test", "Developer", "user"},
        }

        for _, testUser := range testUsers </span><span class="cov10" title="80">{
                var count int
                err = db.QueryRow(context.Background(), "SELECT COUNT(*) FROM users WHERE username = ?", testUser.username).Scan(&amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="80">if count == 0 </span><span class="cov10" title="80">{
                        // Hash the password
                        passwordHash, err := bcrypt.GenerateFromPassword([]byte(testUser.password), bcrypt.DefaultCost)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov10" title="80">now := time.Now().Unix()
                        _, err = db.Exec(context.Background(), `
                                INSERT INTO users (id, username, password_hash, email, name, role, created_at, updated_at, deleted)
                                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                        `, uuid.New().String(), testUser.username, string(passwordHash), testUser.email, testUser.name, testUser.role, now, now, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov7" title="20">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleBoardCreate creates a new board
func (h *Handler) handleBoardCreate(c *gin.Context, req *models.Request) <span class="cov10" title="13">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov9" title="12">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "board", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="12">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse board data from request
        <span class="cov9" title="12">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="11">board := &amp;models.Board{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Validate board
        if !board.IsValid() </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid board data",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov9" title="11">query := `
                INSERT INTO board (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                board.ID,
                board.Title,
                board.Description,
                board.Created,
                board.Modified,
                board.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create board", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create board",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="11">logger.Info("Board created",
                zap.String("board_id", board.ID),
                zap.String("title", board.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "board": board,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleBoardRead reads a single board by ID
func (h *Handler) handleBoardRead(c *gin.Context, req *models.Request) <span class="cov6" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get board ID from request
        <span class="cov6" title="5">boardID, ok := req.Data["id"].(string)
        if !ok || boardID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        // Query board from database
        <span class="cov5" title="4">query := `
                SELECT id, title, description, created, modified, deleted
                FROM board
                WHERE id = ? AND deleted = 0
        `

        var board models.Board
        err := h.db.QueryRow(c.Request.Context(), query, boardID).Scan(
                &amp;board.ID,
                &amp;board.Title,
                &amp;board.Description,
                &amp;board.Created,
                &amp;board.Modified,
                &amp;board.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Board not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read board", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read board",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Board read",
                zap.String("board_id", board.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "board": board,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardList lists all boards
func (h *Handler) handleBoardList(c *gin.Context, req *models.Request) <span class="cov4" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted boards ordered by modified date
        <span class="cov4" title="3">query := `
                SELECT id, title, description, created, modified, deleted
                FROM board
                WHERE deleted = 0
                ORDER BY modified DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list boards", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list boards",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        boards := make([]models.Board, 0)
        for rows.Next() </span><span class="cov5" title="4">{
                var board models.Board
                err := rows.Scan(
                        &amp;board.ID,
                        &amp;board.Title,
                        &amp;board.Description,
                        &amp;board.Created,
                        &amp;board.Modified,
                        &amp;board.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan board", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="4">boards = append(boards, board)</span>
        }

        <span class="cov4" title="3">logger.Info("Boards listed",
                zap.Int("count", len(boards)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "boards": boards,
                "count":  len(boards),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardModify updates an existing board
func (h *Handler) handleBoardModify(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "board", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get board ID
        <span class="cov5" title="4">boardID, ok := req.Data["id"].(string)
        if !ok || boardID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        // Check if board exists
        <span class="cov4" title="3">checkQuery := `SELECT COUNT(*) FROM board WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, boardID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Board not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov3" title="2">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov3" title="2">{
                updates["title"] = title
        }</span>
        <span class="cov3" title="2">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>

        <span class="cov3" title="2">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov3" title="2">query := "UPDATE board SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov6" title="5">{
                if !first </span><span class="cov4" title="3">{
                        query += ", "
                }</span>
                <span class="cov6" title="5">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov3" title="2">query += " WHERE id = ?"
        args = append(args, boardID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update board", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update board",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Board updated",
                zap.String("board_id", boardID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      boardID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardRemove soft-deletes a board
func (h *Handler) handleBoardRemove(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "board", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get board ID
        <span class="cov5" title="4">boardID, ok := req.Data["id"].(string)
        if !ok || boardID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the board
        <span class="cov4" title="3">query := `UPDATE board SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), boardID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete board", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete board",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Board not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Board deleted",
                zap.String("board_id", boardID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      boardID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardAddTicket adds a ticket to a board
func (h *Handler) handleBoardAddTicket(c *gin.Context, req *models.Request) <span class="cov0" title="0">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "board", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov0" title="0">boardID, ok := req.Data["boardId"].(string)
        if !ok || boardID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Check if board exists
        <span class="cov0" title="0">boardQuery := `SELECT COUNT(*) FROM board WHERE id = ? AND deleted = 0`
        var boardCount int
        err = h.db.QueryRow(c.Request.Context(), boardQuery, boardID).Scan(&amp;boardCount)
        if err != nil || boardCount == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Board not found",
                        "",
                ))
                return
        }</span>

        // Check if mapping already exists
        <span class="cov0" title="0">checkQuery := `SELECT COUNT(*) FROM ticket_board_mapping WHERE ticket_id = ? AND board_id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, ticketID, boardID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check existing mapping", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check existing mapping",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeEntityAlreadyExists,
                        "Ticket is already assigned to this board",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov0" title="0">mapping := &amp;models.TicketBoardMapping{
                ID:       uuid.New().String(),
                TicketID: ticketID,
                BoardID:  boardID,
                Created:  time.Now().Unix(),
                Modified: time.Now().Unix(),
                Deleted:  false,
        }

        // Insert into database
        query := `
                INSERT INTO ticket_board_mapping (id, ticket_id, board_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.TicketID,
                mapping.BoardID,
                mapping.Created,
                mapping.Modified,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add ticket to board", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add ticket to board",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">logger.Info("Ticket added to board",
                zap.String("ticket_id", ticketID),
                zap.String("board_id", boardID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleBoardRemoveTicket removes a ticket from a board
func (h *Handler) handleBoardRemoveTicket(c *gin.Context, req *models.Request) <span class="cov0" title="0">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "board", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov0" title="0">boardID, ok := req.Data["boardId"].(string)
        if !ok || boardID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov0" title="0">query := `UPDATE ticket_board_mapping SET deleted = 1, modified = ? WHERE ticket_id = ? AND board_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), ticketID, boardID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove ticket from board", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove ticket from board",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket not found on this board",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">logger.Info("Ticket removed from board",
                zap.String("ticket_id", ticketID),
                zap.String("board_id", boardID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":  true,
                "ticketId": ticketID,
                "boardId":  boardID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardListTickets lists all tickets on a board
func (h *Handler) handleBoardListTickets(c *gin.Context, req *models.Request) <span class="cov0" title="0">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get board ID from request
        <span class="cov0" title="0">boardID, ok := req.Data["boardId"].(string)
        if !ok || boardID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        // Query all ticket IDs mapped to this board
        <span class="cov0" title="0">query := `
                SELECT id, ticket_id, board_id, created, modified, deleted
                FROM ticket_board_mapping
                WHERE board_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, boardID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list board tickets", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list board tickets",
                        "",
                ))
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        mappings := make([]models.TicketBoardMapping, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var mapping models.TicketBoardMapping
                err := rows.Scan(
                        &amp;mapping.ID,
                        &amp;mapping.TicketID,
                        &amp;mapping.BoardID,
                        &amp;mapping.Created,
                        &amp;mapping.Modified,
                        &amp;mapping.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan mapping", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">mappings = append(mappings, mapping)</span>
        }

        <span class="cov0" title="0">logger.Info("Board tickets listed",
                zap.String("board_id", boardID),
                zap.Int("count", len(mappings)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mappings": mappings,
                "count":    len(mappings),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardSetMetadata sets metadata for a board
func (h *Handler) handleBoardSetMetadata(c *gin.Context, req *models.Request) <span class="cov0" title="0">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "board", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov0" title="0">boardID, ok := req.Data["boardId"].(string)
        if !ok || boardID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">value := getStringFromData(req.Data, "value")

        // Check if board exists
        boardQuery := `SELECT COUNT(*) FROM board WHERE id = ? AND deleted = 0`
        var boardCount int
        err = h.db.QueryRow(c.Request.Context(), boardQuery, boardID).Scan(&amp;boardCount)
        if err != nil || boardCount == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Board not found",
                        "",
                ))
                return
        }</span>

        // Check if metadata already exists for this property
        <span class="cov0" title="0">checkQuery := `SELECT id FROM board_meta_data WHERE board_id = ? AND property = ? AND deleted = 0`
        var existingID string
        err = h.db.QueryRow(c.Request.Context(), checkQuery, boardID, property).Scan(&amp;existingID)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Create new metadata
                metadata := &amp;models.BoardMetaData{
                        ID:       uuid.New().String(),
                        BoardID:  boardID,
                        Property: property,
                        Value:    value,
                        Created:  time.Now().Unix(),
                        Modified: time.Now().Unix(),
                        Deleted:  false,
                }

                query := `
                        INSERT INTO board_meta_data (id, board_id, property, value, created, modified, deleted)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                `

                _, err = h.db.Exec(c.Request.Context(), query,
                        metadata.ID,
                        metadata.BoardID,
                        metadata.Property,
                        metadata.Value,
                        metadata.Created,
                        metadata.Modified,
                        metadata.Deleted,
                )

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to set board metadata", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to set board metadata",
                                "",
                        ))
                        return
                }</span>

                <span class="cov0" title="0">logger.Info("Board metadata created",
                        zap.String("board_id", boardID),
                        zap.String("property", property),
                        zap.String("username", username),
                )

                response := models.NewSuccessResponse(map[string]interface{}{
                        "metadata": metadata,
                })
                c.JSON(http.StatusCreated, response)</span>
        } else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                // Update existing metadata
                updateQuery := `UPDATE board_meta_data SET value = ?, modified = ? WHERE id = ?`
                _, err = h.db.Exec(c.Request.Context(), updateQuery, value, time.Now().Unix(), existingID)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to update board metadata", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to update board metadata",
                                "",
                        ))
                        return
                }</span>

                <span class="cov0" title="0">logger.Info("Board metadata updated",
                        zap.String("board_id", boardID),
                        zap.String("property", property),
                        zap.String("username", username),
                )

                response := models.NewSuccessResponse(map[string]interface{}{
                        "updated":  true,
                        "id":       existingID,
                        "property": property,
                        "value":    value,
                })
                c.JSON(http.StatusOK, response)</span>
        } else<span class="cov0" title="0"> {
                logger.Error("Failed to check existing metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check existing metadata",
                        "",
                ))
        }</span>
}

// handleBoardGetMetadata gets a specific metadata property for a board
func (h *Handler) handleBoardGetMetadata(c *gin.Context, req *models.Request) <span class="cov0" title="0">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov0" title="0">boardID, ok := req.Data["boardId"].(string)
        if !ok || boardID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Query metadata from database
        <span class="cov0" title="0">query := `
                SELECT id, board_id, property, value, created, modified, deleted
                FROM board_meta_data
                WHERE board_id = ? AND property = ? AND deleted = 0
        `

        var metadata models.BoardMetaData
        err := h.db.QueryRow(c.Request.Context(), query, boardID, property).Scan(
                &amp;metadata.ID,
                &amp;metadata.BoardID,
                &amp;metadata.Property,
                &amp;metadata.Value,
                &amp;metadata.Created,
                &amp;metadata.Modified,
                &amp;metadata.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Metadata not found",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get board metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to get board metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">logger.Info("Board metadata retrieved",
                zap.String("board_id", boardID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardListMetadata lists all metadata for a board
func (h *Handler) handleBoardListMetadata(c *gin.Context, req *models.Request) <span class="cov0" title="0">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get board ID from request
        <span class="cov0" title="0">boardID, ok := req.Data["boardId"].(string)
        if !ok || boardID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        // Query all metadata for this board
        <span class="cov0" title="0">query := `
                SELECT id, board_id, property, value, created, modified, deleted
                FROM board_meta_data
                WHERE board_id = ? AND deleted = 0
                ORDER BY property ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query, boardID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list board metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list board metadata",
                        "",
                ))
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        metadata := make([]models.BoardMetaData, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var meta models.BoardMetaData
                err := rows.Scan(
                        &amp;meta.ID,
                        &amp;meta.BoardID,
                        &amp;meta.Property,
                        &amp;meta.Value,
                        &amp;meta.Created,
                        &amp;meta.Modified,
                        &amp;meta.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan metadata", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">metadata = append(metadata, meta)</span>
        }

        <span class="cov0" title="0">logger.Info("Board metadata listed",
                zap.String("board_id", boardID),
                zap.Int("count", len(metadata)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
                "count":    len(metadata),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleBoardRemoveMetadata removes a specific metadata property from a board
func (h *Handler) handleBoardRemoveMetadata(c *gin.Context, req *models.Request) <span class="cov0" title="0">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "board", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov0" title="0">boardID, ok := req.Data["boardId"].(string)
        if !ok || boardID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing board ID",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Soft delete the metadata
        <span class="cov0" title="0">query := `UPDATE board_meta_data SET deleted = 1, modified = ? WHERE board_id = ? AND property = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), boardID, property)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove board metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove board metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Metadata not found",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">logger.Info("Board metadata removed",
                zap.String("board_id", boardID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted":  true,
                "boardId":  boardID,
                "property": property,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleCreateComment creates a new comment
func (h *Handler) handleCreateComment(c *gin.Context, req *models.Request) <span class="cov10" title="18">{
        commentData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov10" title="18">{
                commentData = req.Data
        }</span>

        <span class="cov10" title="18">ticketID, _ := commentData["ticket_id"].(string)
        if ticketID == "" </span><span class="cov3" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket_id",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="16">commentText, _ := commentData["comment"].(string)
        if commentText == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing comment text",
                        "",
                ))
                return
        }</span>

        // Create comment
        <span class="cov9" title="15">commentID := uuid.New().String()
        now := time.Now().Unix()

        query := `
                INSERT INTO comment (id, comment, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err := h.db.Exec(
                context.Background(),
                query,
                commentID,
                commentText,
                now,
                now,
                0,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create comment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create comment",
                        "",
                ))
                return
        }</span>

        // Create ticket-comment mapping
        <span class="cov9" title="15">mappingID := uuid.New().String()
        mappingQuery := `
                INSERT INTO comment_ticket_mapping (id, comment_id, ticket_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(
                context.Background(),
                mappingQuery,
                mappingID,
                commentID,
                ticketID,
                now,
                now,
                0,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create comment mapping", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create comment",
                        "",
                ))
                return
        }</span>

        // Get project_id from ticket for event context
        <span class="cov9" title="15">var projectID string
        h.db.QueryRow(context.Background(),
                "SELECT project_id FROM ticket WHERE id = ? AND deleted = 0", ticketID).Scan(&amp;projectID)

        // Get username from context
        username, _ := middleware.GetUsername(c)

        // Publish comment created event
        if projectID != "" </span><span class="cov9" title="15">{
                h.publisher.PublishEntityEvent(
                        models.ActionCreate,
                        "comment",
                        commentID,
                        username,
                        map[string]interface{}{
                                "id":        commentID,
                                "comment":   commentText,
                                "ticket_id": ticketID,
                        },
                        websocket.NewProjectContext(projectID, []string{"READ"}),
                )
        }</span>

        <span class="cov9" title="15">response := models.NewSuccessResponse(map[string]interface{}{
                "comment": map[string]interface{}{
                        "id":        commentID,
                        "comment":   commentText,
                        "ticket_id": ticketID,
                        "created":   now,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleModifyComment updates an existing comment
func (h *Handler) handleModifyComment(c *gin.Context, req *models.Request) <span class="cov6" title="5">{
        commentData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov6" title="5">{
                commentData = req.Data
        }</span>

        <span class="cov6" title="5">commentID, _ := commentData["id"].(string)
        if commentID == "" </span><span class="cov3" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing comment ID",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="3">commentText, _ := commentData["comment"].(string)
        if commentText == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing comment text",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">query := "UPDATE comment SET comment = ?, modified = ? WHERE id = ? AND deleted = 0"
        _, err := h.db.Exec(context.Background(), query, commentText, time.Now().Unix(), commentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update comment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update comment",
                        "",
                ))
                return
        }</span>

        // Get project_id from ticket for event context
        <span class="cov3" title="2">var ticketID, projectID string
        h.db.QueryRow(context.Background(),
                `SELECT t.id, t.project_id FROM ticket t
                 JOIN comment_ticket_mapping ctm ON t.id = ctm.ticket_id
                 WHERE ctm.comment_id = ? AND t.deleted = 0`, commentID).Scan(&amp;ticketID, &amp;projectID)

        // Get username from context
        username, _ := middleware.GetUsername(c)

        // Publish comment updated event
        if projectID != "" </span><span class="cov3" title="2">{
                h.publisher.PublishEntityEvent(
                        models.ActionModify,
                        "comment",
                        commentID,
                        username,
                        map[string]interface{}{
                                "id":        commentID,
                                "comment":   commentText,
                                "ticket_id": ticketID,
                        },
                        websocket.NewProjectContext(projectID, []string{"READ"}),
                )
        }</span>

        <span class="cov3" title="2">response := models.NewSuccessResponse(map[string]interface{}{
                "comment": map[string]interface{}{
                        "id":      commentID,
                        "updated": true,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleRemoveComment soft-deletes a comment
func (h *Handler) handleRemoveComment(c *gin.Context, req *models.Request) <span class="cov6" title="6">{
        commentData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov6" title="6">{
                commentData = req.Data
        }</span>

        <span class="cov6" title="6">commentID, _ := commentData["id"].(string)
        if commentID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing comment ID",
                        "",
                ))
                return
        }</span>

        // Get project_id from ticket before deletion for event context
        <span class="cov6" title="5">var ticketID, projectID string
        err := h.db.QueryRow(context.Background(),
                `SELECT t.id, t.project_id FROM ticket t
                 JOIN comment_ticket_mapping ctm ON t.id = ctm.ticket_id
                 WHERE ctm.comment_id = ? AND t.deleted = 0`, commentID).Scan(&amp;ticketID, &amp;projectID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Comment not found", zap.Error(err))
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Comment not found",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">query := "UPDATE comment SET deleted = 1, modified = ? WHERE id = ?"
        _, err = h.db.Exec(context.Background(), query, time.Now().Unix(), commentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete comment", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete comment",
                        "",
                ))
                return
        }</span>

        // Get username from context
        <span class="cov5" title="4">username, _ := middleware.GetUsername(c)

        // Publish comment deleted event
        h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "comment",
                commentID,
                username,
                map[string]interface{}{
                        "id":        commentID,
                        "ticket_id": ticketID,
                },
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "comment": map[string]interface{}{
                        "id":      commentID,
                        "deleted": true,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleReadComment retrieves a single comment
func (h *Handler) handleReadComment(c *gin.Context, req *models.Request) <span class="cov6" title="5">{
        commentData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov6" title="5">{
                commentData = req.Data
        }</span>

        <span class="cov6" title="5">commentID, _ := commentData["id"].(string)
        if commentID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing comment ID",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">query := `
                SELECT id, comment, created, modified
                FROM comment
                WHERE id = ? AND deleted = 0
        `

        var id, comment string
        var created, modified int64

        err := h.db.QueryRow(context.Background(), query, commentID).Scan(
                &amp;id, &amp;comment, &amp;created, &amp;modified)

        if err != nil </span><span class="cov3" title="2">{
                logger.Error("Comment not found", zap.Error(err))
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Comment not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">response := models.NewSuccessResponse(map[string]interface{}{
                "comment": map[string]interface{}{
                        "id":       id,
                        "comment":  comment,
                        "created":  created,
                        "modified": modified,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleListComments retrieves all comments for a ticket
func (h *Handler) handleListComments(c *gin.Context, req *models.Request) <span class="cov6" title="5">{
        // Get ticket_id from request data
        var ticketID string
        if req.Data != nil </span><span class="cov6" title="5">{
                if data, ok := req.Data["data"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        ticketID, _ = data["ticket_id"].(string)
                }</span> else<span class="cov6" title="5"> {
                        ticketID, _ = req.Data["ticket_id"].(string)
                }</span>
        }

        <span class="cov6" title="5">if ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket_id",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">query := `
                SELECT c.id, c.comment, c.created, c.modified
                FROM comment c
                JOIN comment_ticket_mapping ctm ON c.id = ctm.comment_id
                WHERE ctm.ticket_id = ? AND c.deleted = 0
                ORDER BY c.created DESC
        `

        rows, err := h.db.Query(context.Background(), query, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list comments", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list comments",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="4">defer rows.Close()

        comments := []map[string]interface{}{}

        for rows.Next() </span><span class="cov7" title="7">{
                var id, comment string
                var created, modified int64

                err := rows.Scan(&amp;id, &amp;comment, &amp;created, &amp;modified)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan comment", zap.Error(err))
                        continue</span>
                }

                <span class="cov7" title="7">comments = append(comments, map[string]interface{}{
                        "id":       id,
                        "comment":  comment,
                        "created":  created,
                        "modified": modified,
                })</span>
        }

        <span class="cov5" title="4">response := models.NewSuccessResponse(map[string]interface{}{
                "items": comments,
                "total": len(comments),
        })

        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleComponentCreate creates a new component
func (h *Handler) handleComponentCreate(c *gin.Context, req *models.Request) <span class="cov10" title="9">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="9">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "component", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="9">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse component data from request
        <span class="cov10" title="9">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">component := &amp;models.Component{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO component (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                component.ID,
                component.Title,
                component.Description,
                component.Created,
                component.Modified,
                component.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create component", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create component",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">logger.Info("Component created",
                zap.String("component_id", component.ID),
                zap.String("title", component.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "component": component,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleComponentRead reads a single component by ID
func (h *Handler) handleComponentRead(c *gin.Context, req *models.Request) <span class="cov7" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get component ID from request
        <span class="cov7" title="5">componentID, ok := req.Data["id"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        // Query component from database
        <span class="cov7" title="5">query := `
                SELECT id, title, description, created, modified, deleted
                FROM component
                WHERE id = ? AND deleted = 0
        `

        var component models.Component
        err := h.db.QueryRow(c.Request.Context(), query, componentID).Scan(
                &amp;component.ID,
                &amp;component.Title,
                &amp;component.Description,
                &amp;component.Created,
                &amp;component.Modified,
                &amp;component.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Component not found",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read component", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read component",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Component read",
                zap.String("component_id", component.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "component": component,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentList lists all components
func (h *Handler) handleComponentList(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted components ordered by title
        <span class="cov6" title="4">query := `
                SELECT id, title, description, created, modified, deleted
                FROM component
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list components", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list components",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="4">defer rows.Close()

        components := make([]models.Component, 0)
        for rows.Next() </span><span class="cov8" title="7">{
                var component models.Component
                err := rows.Scan(
                        &amp;component.ID,
                        &amp;component.Title,
                        &amp;component.Description,
                        &amp;component.Created,
                        &amp;component.Modified,
                        &amp;component.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan component", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="7">components = append(components, component)</span>
        }

        <span class="cov6" title="4">logger.Info("Components listed",
                zap.Int("count", len(components)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "components": components,
                "count":      len(components),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentModify updates an existing component
func (h *Handler) handleComponentModify(c *gin.Context, req *models.Request) <span class="cov7" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "component", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get component ID
        <span class="cov7" title="5">componentID, ok := req.Data["id"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        // Check if component exists
        <span class="cov7" title="5">checkQuery := `SELECT COUNT(*) FROM component WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, componentID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Component not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov6" title="4">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov5" title="3">{
                updates["title"] = title
        }</span>
        <span class="cov6" title="4">if description, ok := req.Data["description"].(string); ok </span><span class="cov3" title="2">{
                updates["description"] = description
        }</span>

        <span class="cov6" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov5" title="3">query := "UPDATE component SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov9" title="8">{
                if !first </span><span class="cov7" title="5">{
                        query += ", "
                }</span>
                <span class="cov9" title="8">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov5" title="3">query += " WHERE id = ?"
        args = append(args, componentID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update component", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update component",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Component updated",
                zap.String("component_id", componentID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      componentID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentRemove soft-deletes a component
func (h *Handler) handleComponentRemove(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "component", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get component ID
        <span class="cov5" title="3">componentID, ok := req.Data["id"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the component
        <span class="cov5" title="3">query := `UPDATE component SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), componentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete component", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete component",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Component not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Component deleted",
                zap.String("component_id", componentID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      componentID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentAddTicket adds a component to a ticket
func (h *Handler) handleComponentAddTicket(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "component", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get component ID and ticket ID
        <span class="cov5" title="3">componentID, ok := req.Data["componentId"].(string)
        if !ok || componentID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov3" title="2">mappingID := uuid.New().String()
        query := `
                INSERT INTO component_ticket_mapping (id, component_id, ticket_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        now := time.Now().Unix()
        _, err = h.db.Exec(c.Request.Context(), query, mappingID, componentID, ticketID, now, now, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add component to ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add component to ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Component added to ticket",
                zap.String("component_id", componentID),
                zap.String("ticket_id", ticketID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "added":       true,
                "componentId": componentID,
                "ticketId":    ticketID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentRemoveTicket removes a component from a ticket
func (h *Handler) handleComponentRemoveTicket(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "component", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get component ID and ticket ID
        <span class="cov3" title="2">componentID, ok := req.Data["componentId"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Remove mapping (soft delete)
        <span class="cov3" title="2">query := `UPDATE component_ticket_mapping SET deleted = 1, modified = ? WHERE component_id = ? AND ticket_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), componentID, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove component from ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove component from ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Component-ticket mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Component removed from ticket",
                zap.String("component_id", componentID),
                zap.String("ticket_id", ticketID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":     true,
                "componentId": componentID,
                "ticketId":    ticketID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentListTickets lists all tickets for a component
func (h *Handler) handleComponentListTickets(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get component ID
        <span class="cov3" title="2">componentID, ok := req.Data["componentId"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        // Query tickets
        <span class="cov3" title="2">query := `
                SELECT ticket_id
                FROM component_ticket_mapping
                WHERE component_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, componentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list tickets for component", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list tickets",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        ticketIDs := make([]string, 0)
        for rows.Next() </span><span class="cov5" title="3">{
                var ticketID string
                if err := rows.Scan(&amp;ticketID); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket ID", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="3">ticketIDs = append(ticketIDs, ticketID)</span>
        }

        <span class="cov3" title="2">logger.Info("Tickets listed for component",
                zap.String("component_id", componentID),
                zap.Int("count", len(ticketIDs)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketIds": ticketIDs,
                "count":     len(ticketIDs),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentSetMetadata sets metadata for a component
func (h *Handler) handleComponentSetMetadata(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "component", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get component ID, property, and value
        <span class="cov5" title="3">componentID, ok := req.Data["componentId"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">value := getStringFromData(req.Data, "value")

        // Check if metadata exists, update or insert
        checkQuery := `SELECT id FROM component_meta_data WHERE component_id = ? AND property = ? AND deleted = 0`
        var existingID string
        err = h.db.QueryRow(c.Request.Context(), checkQuery, componentID, property).Scan(&amp;existingID)

        now := time.Now().Unix()

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                // Insert new metadata
                metadataID := uuid.New().String()
                insertQuery := `
                        INSERT INTO component_meta_data (id, component_id, property, value, created, modified, deleted)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                `
                _, err = h.db.Exec(c.Request.Context(), insertQuery, metadataID, componentID, property, value, now, now, false)
        }</span> else<span class="cov1" title="1"> {
                // Update existing metadata
                updateQuery := `UPDATE component_meta_data SET value = ?, modified = ? WHERE id = ?`
                _, err = h.db.Exec(c.Request.Context(), updateQuery, value, now, existingID)
        }</span>

        <span class="cov5" title="3">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to set component metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to set metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Component metadata set",
                zap.String("component_id", componentID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "set":         true,
                "componentId": componentID,
                "property":    property,
                "value":       value,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentGetMetadata gets metadata for a component
func (h *Handler) handleComponentGetMetadata(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get component ID and property
        <span class="cov3" title="2">componentID, ok := req.Data["componentId"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Query metadata
        <span class="cov3" title="2">query := `
                SELECT id, component_id, property, value, created, modified, deleted
                FROM component_meta_data
                WHERE component_id = ? AND property = ? AND deleted = 0
        `

        var metadata models.ComponentMetaData
        err := h.db.QueryRow(c.Request.Context(), query, componentID, property).Scan(
                &amp;metadata.ID,
                &amp;metadata.ComponentID,
                &amp;metadata.Property,
                &amp;metadata.Value,
                &amp;metadata.Created,
                &amp;metadata.Modified,
                &amp;metadata.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Metadata not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get component metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to get metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Component metadata retrieved",
                zap.String("component_id", componentID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentListMetadata lists all metadata for a component
func (h *Handler) handleComponentListMetadata(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get component ID
        <span class="cov3" title="2">componentID, ok := req.Data["componentId"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        // Query all metadata
        <span class="cov3" title="2">query := `
                SELECT id, component_id, property, value, created, modified, deleted
                FROM component_meta_data
                WHERE component_id = ? AND deleted = 0
                ORDER BY property ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query, componentID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list component metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list metadata",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        metadata := make([]models.ComponentMetaData, 0)
        for rows.Next() </span><span class="cov5" title="3">{
                var md models.ComponentMetaData
                err := rows.Scan(
                        &amp;md.ID,
                        &amp;md.ComponentID,
                        &amp;md.Property,
                        &amp;md.Value,
                        &amp;md.Created,
                        &amp;md.Modified,
                        &amp;md.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan metadata", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="3">metadata = append(metadata, md)</span>
        }

        <span class="cov3" title="2">logger.Info("Component metadata listed",
                zap.String("component_id", componentID),
                zap.Int("count", len(metadata)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
                "count":    len(metadata),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleComponentRemoveMetadata removes metadata from a component
func (h *Handler) handleComponentRemoveMetadata(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "component", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get component ID and property
        <span class="cov3" title="2">componentID, ok := req.Data["componentId"].(string)
        if !ok || componentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing component ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Soft delete metadata
        <span class="cov3" title="2">query := `UPDATE component_meta_data SET deleted = 1, modified = ? WHERE component_id = ? AND property = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), componentID, property)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove component metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Metadata not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Component metadata removed",
                zap.String("component_id", componentID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":     true,
                "componentId": componentID,
                "property":    property,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleCustomFieldCreate creates a new custom field definition
func (h *Handler) handleCustomFieldCreate(c *gin.Context, req *models.Request) <span class="cov10" title="18">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="18">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "customfield", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="18">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse custom field data from request
        <span class="cov10" title="18">fieldName, ok := req.Data["fieldName"].(string)
        if !ok || fieldName == "" </span><span class="cov3" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing fieldName",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="16">fieldType, ok := req.Data["fieldType"].(string)
        if !ok || fieldType == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing fieldType",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="15">customField := &amp;models.CustomField{
                ID:        uuid.New().String(),
                FieldName: fieldName,
                FieldType: fieldType,
                Description: getStringFromData(req.Data, "description"),
                IsRequired:  getBoolFromData(req.Data, "isRequired"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Handle optional projectId
        if projectID, ok := req.Data["projectId"].(string); ok &amp;&amp; projectID != "" </span><span class="cov3" title="2">{
                customField.ProjectID = &amp;projectID
        }</span>

        // Handle optional defaultValue
        <span class="cov9" title="15">if defaultValue, ok := req.Data["defaultValue"].(string); ok &amp;&amp; defaultValue != "" </span><span class="cov1" title="1">{
                customField.DefaultValue = &amp;defaultValue
        }</span>

        // Handle optional configuration (JSON object)
        <span class="cov9" title="15">if configuration, ok := req.Data["configuration"]; ok &amp;&amp; configuration != nil </span><span class="cov1" title="1">{
                configJSON, err := json.Marshal(configuration)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid configuration format",
                                "",
                        ))
                        return
                }</span>
                <span class="cov1" title="1">configStr := string(configJSON)
                customField.Configuration = &amp;configStr</span>
        }

        // Validate field type
        <span class="cov9" title="15">if !customField.IsValidFieldType() </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid field type",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov9" title="14">query := `
                INSERT INTO custom_field (id, field_name, field_type, description, project_id, is_required, default_value, configuration, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                customField.ID,
                customField.FieldName,
                customField.FieldType,
                customField.Description,
                customField.ProjectID,
                customField.IsRequired,
                customField.DefaultValue,
                customField.Configuration,
                customField.Created,
                customField.Modified,
                customField.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create custom field", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create custom field",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="14">logger.Info("Custom field created",
                zap.String("custom_field_id", customField.ID),
                zap.String("field_name", customField.FieldName),
                zap.String("username", username),
        )

        // Publish custom field created event
        projectContext := ""
        if customField.ProjectID != nil </span><span class="cov3" title="2">{
                projectContext = *customField.ProjectID
        }</span>
        <span class="cov9" title="14">h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "customfield",
                customField.ID,
                username,
                map[string]interface{}{
                        "id":          customField.ID,
                        "field_name":  customField.FieldName,
                        "field_type":  customField.FieldType,
                        "description": customField.Description,
                        "project_id":  customField.ProjectID,
                        "is_required": customField.IsRequired,
                },
                websocket.NewProjectContext(projectContext, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "customField": customField,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleCustomFieldRead reads a single custom field by ID
func (h *Handler) handleCustomFieldRead(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get custom field ID from request
        <span class="cov3" title="2">customFieldID, ok := req.Data["id"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing custom field ID",
                        "",
                ))
                return
        }</span>

        // Query custom field from database
        <span class="cov3" title="2">query := `
                SELECT id, field_name, field_type, description, project_id, is_required, default_value, configuration, created, modified, deleted
                FROM custom_field
                WHERE id = ? AND deleted = 0
        `

        var customField models.CustomField
        err := h.db.QueryRow(c.Request.Context(), query, customFieldID).Scan(
                &amp;customField.ID,
                &amp;customField.FieldName,
                &amp;customField.FieldType,
                &amp;customField.Description,
                &amp;customField.ProjectID,
                &amp;customField.IsRequired,
                &amp;customField.DefaultValue,
                &amp;customField.Configuration,
                &amp;customField.Created,
                &amp;customField.Modified,
                &amp;customField.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read custom field", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read custom field",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Custom field read",
                zap.String("custom_field_id", customField.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "customField": customField,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldList lists all custom fields (optionally filtered by project_id)
func (h *Handler) handleCustomFieldList(c *gin.Context, req *models.Request) <span class="cov4" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check for optional projectId filter
        <span class="cov4" title="3">projectID, hasProjectFilter := req.Data["projectId"].(string)

        var query string
        var args []interface{}

        if hasProjectFilter &amp;&amp; projectID != "" </span><span class="cov1" title="1">{
                // List custom fields for specific project + global fields
                query = `
                        SELECT id, field_name, field_type, description, project_id, is_required, default_value, configuration, created, modified, deleted
                        FROM custom_field
                        WHERE deleted = 0 AND (project_id = ? OR project_id IS NULL)
                        ORDER BY field_name ASC
                `
                args = []interface{}{projectID}
        }</span> else<span class="cov3" title="2"> {
                // List all custom fields
                query = `
                        SELECT id, field_name, field_type, description, project_id, is_required, default_value, configuration, created, modified, deleted
                        FROM custom_field
                        WHERE deleted = 0
                        ORDER BY field_name ASC
                `
                args = []interface{}{}
        }</span>

        <span class="cov4" title="3">rows, err := h.db.Query(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list custom fields", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list custom fields",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        customFields := make([]models.CustomField, 0)
        for rows.Next() </span><span class="cov6" title="5">{
                var customField models.CustomField
                err := rows.Scan(
                        &amp;customField.ID,
                        &amp;customField.FieldName,
                        &amp;customField.FieldType,
                        &amp;customField.Description,
                        &amp;customField.ProjectID,
                        &amp;customField.IsRequired,
                        &amp;customField.DefaultValue,
                        &amp;customField.Configuration,
                        &amp;customField.Created,
                        &amp;customField.Modified,
                        &amp;customField.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan custom field", zap.Error(err))
                        continue</span>
                }
                <span class="cov6" title="5">customFields = append(customFields, customField)</span>
        }

        <span class="cov4" title="3">logger.Info("Custom fields listed",
                zap.Int("count", len(customFields)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "customFields": customFields,
                "count":        len(customFields),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldModify updates an existing custom field
func (h *Handler) handleCustomFieldModify(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "customfield", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get custom field ID
        <span class="cov5" title="4">customFieldID, ok := req.Data["id"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing custom field ID",
                        "",
                ))
                return
        }</span>

        // Check if custom field exists
        <span class="cov5" title="4">checkQuery := `SELECT COUNT(*) FROM custom_field WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, customFieldID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov4" title="3">updates := make(map[string]interface{})

        if fieldName, ok := req.Data["fieldName"].(string); ok &amp;&amp; fieldName != "" </span><span class="cov3" title="2">{
                updates["field_name"] = fieldName
        }</span>
        <span class="cov4" title="3">if description, ok := req.Data["description"].(string); ok </span><span class="cov3" title="2">{
                updates["description"] = description
        }</span>
        <span class="cov4" title="3">if isRequired, ok := req.Data["isRequired"].(bool); ok </span><span class="cov3" title="2">{
                updates["is_required"] = isRequired
        }</span>
        <span class="cov4" title="3">if defaultValue, ok := req.Data["defaultValue"].(string); ok </span><span class="cov0" title="0">{
                updates["default_value"] = defaultValue
        }</span>
        <span class="cov4" title="3">if configuration, ok := req.Data["configuration"]; ok &amp;&amp; configuration != nil </span><span class="cov0" title="0">{
                configJSON, err := json.Marshal(configuration)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid configuration format",
                                "",
                        ))
                        return
                }</span>
                <span class="cov0" title="0">updates["configuration"] = string(configJSON)</span>
        }

        <span class="cov4" title="3">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov3" title="2">query := "UPDATE custom_field SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov7" title="8">{
                if !first </span><span class="cov6" title="6">{
                        query += ", "
                }</span>
                <span class="cov7" title="8">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov3" title="2">query += " WHERE id = ?"
        args = append(args, customFieldID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update custom field", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update custom field",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Custom field updated",
                zap.String("custom_field_id", customFieldID),
                zap.String("username", username),
        )

        // Get project context for event publishing
        var projectID *string
        contextQuery := `SELECT project_id FROM custom_field WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), contextQuery, customFieldID).Scan(&amp;projectID)

        projectContext := ""
        if err == nil &amp;&amp; projectID != nil </span><span class="cov1" title="1">{
                projectContext = *projectID
        }</span>

        // Publish custom field updated event
        <span class="cov3" title="2">h.publisher.PublishEntityEvent(
                models.ActionModify,
                "customfield",
                customFieldID,
                username,
                updates,
                websocket.NewProjectContext(projectContext, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      customFieldID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldRemove soft-deletes a custom field
func (h *Handler) handleCustomFieldRemove(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "customfield", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get custom field ID
        <span class="cov5" title="4">customFieldID, ok := req.Data["id"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing custom field ID",
                        "",
                ))
                return
        }</span>

        // Get project context before deletion for event publishing
        <span class="cov5" title="4">var projectID *string
        contextQuery := `SELECT project_id FROM custom_field WHERE id = ? AND deleted = 0`
        _ = h.db.QueryRow(c.Request.Context(), contextQuery, customFieldID).Scan(&amp;projectID)

        // Soft delete the custom field
        query := `UPDATE custom_field SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), customFieldID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete custom field", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete custom field",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="3">logger.Info("Custom field deleted",
                zap.String("custom_field_id", customFieldID),
                zap.String("username", username),
        )

        // Publish custom field deleted event
        projectContext := ""
        if projectID != nil </span><span class="cov0" title="0">{
                projectContext = *projectID
        }</span>
        <span class="cov4" title="3">h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "customfield",
                customFieldID,
                username,
                map[string]interface{}{
                        "id":         customFieldID,
                        "project_id": projectID,
                },
                websocket.NewProjectContext(projectContext, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      customFieldID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldOptionCreate creates an option for a select/multi-select field
func (h *Handler) handleCustomFieldOptionCreate(c *gin.Context, req *models.Request) <span class="cov6" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov6" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "customfield", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse option data from request
        <span class="cov6" title="5">customFieldID, ok := req.Data["customFieldId"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing customFieldId",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="5">value, ok := req.Data["value"].(string)
        if !ok || value == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing value",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="5">displayValue, ok := req.Data["displayValue"].(string)
        if !ok || displayValue == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing displayValue",
                        "",
                ))
                return
        }</span>

        // Verify custom field exists and is a select type
        <span class="cov6" title="5">var fieldType string
        checkQuery := `SELECT field_type FROM custom_field WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, customFieldID).Scan(&amp;fieldType)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field not found",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="5">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to verify custom field", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to verify custom field",
                        "",
                ))
                return
        }</span>

        // Validate that field type requires options
        <span class="cov6" title="5">tempField := &amp;models.CustomField{FieldType: fieldType}
        if !tempField.RequiresOptions() </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Custom field type does not support options",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">option := &amp;models.CustomFieldOption{
                ID:            uuid.New().String(),
                CustomFieldID: customFieldID,
                Value:         value,
                DisplayValue:  displayValue,
                Position:      getIntFromData(req.Data, "position"),
                IsDefault:     getBoolFromData(req.Data, "isDefault"),
                Created:       time.Now().Unix(),
                Modified:      time.Now().Unix(),
                Deleted:       false,
        }

        // Insert into database
        query := `
                INSERT INTO custom_field_option (id, custom_field_id, value, display_value, position, is_default, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                option.ID,
                option.CustomFieldID,
                option.Value,
                option.DisplayValue,
                option.Position,
                option.IsDefault,
                option.Created,
                option.Modified,
                option.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create custom field option", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create custom field option",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">logger.Info("Custom field option created",
                zap.String("option_id", option.ID),
                zap.String("custom_field_id", customFieldID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "option": option,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleCustomFieldOptionModify updates an option
func (h *Handler) handleCustomFieldOptionModify(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "customfield", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get option ID
        <span class="cov1" title="1">optionID, ok := req.Data["id"].(string)
        if !ok || optionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing option ID",
                        "",
                ))
                return
        }</span>

        // Check if option exists
        <span class="cov1" title="1">checkQuery := `SELECT COUNT(*) FROM custom_field_option WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, optionID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field option not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov1" title="1">updates := make(map[string]interface{})

        if value, ok := req.Data["value"].(string); ok &amp;&amp; value != "" </span><span class="cov1" title="1">{
                updates["value"] = value
        }</span>
        <span class="cov1" title="1">if displayValue, ok := req.Data["displayValue"].(string); ok &amp;&amp; displayValue != "" </span><span class="cov1" title="1">{
                updates["display_value"] = displayValue
        }</span>
        <span class="cov1" title="1">if position, ok := req.Data["position"].(float64); ok </span><span class="cov0" title="0">{
                updates["position"] = int(position)
        }</span>
        <span class="cov1" title="1">if isDefault, ok := req.Data["isDefault"].(bool); ok </span><span class="cov1" title="1">{
                updates["is_default"] = isDefault
        }</span>

        <span class="cov1" title="1">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov1" title="1">query := "UPDATE custom_field_option SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov5" title="4">{
                if !first </span><span class="cov4" title="3">{
                        query += ", "
                }</span>
                <span class="cov5" title="4">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov1" title="1">query += " WHERE id = ?"
        args = append(args, optionID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update custom field option", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update custom field option",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Custom field option updated",
                zap.String("option_id", optionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      optionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldOptionRemove soft-deletes an option
func (h *Handler) handleCustomFieldOptionRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "customfield", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get option ID
        <span class="cov1" title="1">optionID, ok := req.Data["id"].(string)
        if !ok || optionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing option ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the option
        <span class="cov1" title="1">query := `UPDATE custom_field_option SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), optionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete custom field option", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete custom field option",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field option not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Custom field option deleted",
                zap.String("option_id", optionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      optionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldOptionList lists all options for a custom field
func (h *Handler) handleCustomFieldOptionList(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get custom field ID from request
        <span class="cov3" title="2">customFieldID, ok := req.Data["customFieldId"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing customFieldId",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted options ordered by position
        <span class="cov3" title="2">query := `
                SELECT id, custom_field_id, value, display_value, position, is_default, created, modified, deleted
                FROM custom_field_option
                WHERE custom_field_id = ? AND deleted = 0
                ORDER BY position ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query, customFieldID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list custom field options", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list custom field options",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        options := make([]models.CustomFieldOption, 0)
        for rows.Next() </span><span class="cov6" title="6">{
                var option models.CustomFieldOption
                err := rows.Scan(
                        &amp;option.ID,
                        &amp;option.CustomFieldID,
                        &amp;option.Value,
                        &amp;option.DisplayValue,
                        &amp;option.Position,
                        &amp;option.IsDefault,
                        &amp;option.Created,
                        &amp;option.Modified,
                        &amp;option.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan custom field option", zap.Error(err))
                        continue</span>
                }
                <span class="cov6" title="6">options = append(options, option)</span>
        }

        <span class="cov3" title="2">logger.Info("Custom field options listed",
                zap.Int("count", len(options)),
                zap.String("custom_field_id", customFieldID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "options": options,
                "count":   len(options),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldValueSet sets/updates a custom field value for a ticket
func (h *Handler) handleCustomFieldValueSet(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov5" title="4">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">customFieldID, ok := req.Data["customFieldId"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing customFieldId",
                        "",
                ))
                return
        }</span>

        // Value can be null/empty for clearing a field
        <span class="cov5" title="4">var valuePtr *string
        if value, ok := req.Data["value"].(string); ok &amp;&amp; value != "" </span><span class="cov5" title="4">{
                valuePtr = &amp;value
        }</span>

        // Check if value already exists
        <span class="cov5" title="4">checkQuery := `SELECT id FROM ticket_custom_field_value WHERE ticket_id = ? AND custom_field_id = ? AND deleted = 0`
        var existingID string
        err = h.db.QueryRow(c.Request.Context(), checkQuery, ticketID, customFieldID).Scan(&amp;existingID)

        now := time.Now().Unix()

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                // Create new value
                newID := uuid.New().String()
                insertQuery := `
                        INSERT INTO ticket_custom_field_value (id, ticket_id, custom_field_id, value, created, modified, deleted)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                `
                _, err = h.db.Exec(c.Request.Context(), insertQuery, newID, ticketID, customFieldID, valuePtr, now, now, false)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to create custom field value", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to create custom field value",
                                "",
                        ))
                        return
                }</span>

                <span class="cov3" title="2">logger.Info("Custom field value created",
                        zap.String("ticket_id", ticketID),
                        zap.String("custom_field_id", customFieldID),
                        zap.String("username", username),
                )

                response := models.NewSuccessResponse(map[string]interface{}{
                        "created": true,
                        "id":      newID,
                })
                c.JSON(http.StatusCreated, response)</span>
        } else<span class="cov3" title="2"> if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check existing custom field value", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check existing custom field value",
                        "",
                ))
                return
        }</span> else<span class="cov3" title="2"> {
                // Update existing value
                updateQuery := `UPDATE ticket_custom_field_value SET value = ?, modified = ? WHERE id = ?`
                _, err = h.db.Exec(c.Request.Context(), updateQuery, valuePtr, now, existingID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to update custom field value", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to update custom field value",
                                "",
                        ))
                        return
                }</span>

                <span class="cov3" title="2">logger.Info("Custom field value updated",
                        zap.String("ticket_id", ticketID),
                        zap.String("custom_field_id", customFieldID),
                        zap.String("username", username),
                )

                response := models.NewSuccessResponse(map[string]interface{}{
                        "updated": true,
                        "id":      existingID,
                })
                c.JSON(http.StatusOK, response)</span>
        }
}

// handleCustomFieldValueGet gets a custom field value for a ticket
func (h *Handler) handleCustomFieldValueGet(c *gin.Context, req *models.Request) <span class="cov4" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov4" title="3">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="3">customFieldID, ok := req.Data["customFieldId"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing customFieldId",
                        "",
                ))
                return
        }</span>

        // Query custom field value
        <span class="cov4" title="3">query := `
                SELECT id, ticket_id, custom_field_id, value, created, modified, deleted
                FROM ticket_custom_field_value
                WHERE ticket_id = ? AND custom_field_id = ? AND deleted = 0
        `

        var fieldValue models.TicketCustomFieldValue
        err := h.db.QueryRow(c.Request.Context(), query, ticketID, customFieldID).Scan(
                &amp;fieldValue.ID,
                &amp;fieldValue.TicketID,
                &amp;fieldValue.CustomFieldID,
                &amp;fieldValue.Value,
                &amp;fieldValue.Created,
                &amp;fieldValue.Modified,
                &amp;fieldValue.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field value not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read custom field value", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read custom field value",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Custom field value read",
                zap.String("ticket_id", ticketID),
                zap.String("custom_field_id", customFieldID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "fieldValue": fieldValue,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldValueList lists all custom field values for a ticket
func (h *Handler) handleCustomFieldValueList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket ID from request
        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted custom field values for the ticket
        <span class="cov1" title="1">query := `
                SELECT id, ticket_id, custom_field_id, value, created, modified, deleted
                FROM ticket_custom_field_value
                WHERE ticket_id = ? AND deleted = 0
                ORDER BY created ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list custom field values", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list custom field values",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        fieldValues := make([]models.TicketCustomFieldValue, 0)
        for rows.Next() </span><span class="cov4" title="3">{
                var fieldValue models.TicketCustomFieldValue
                err := rows.Scan(
                        &amp;fieldValue.ID,
                        &amp;fieldValue.TicketID,
                        &amp;fieldValue.CustomFieldID,
                        &amp;fieldValue.Value,
                        &amp;fieldValue.Created,
                        &amp;fieldValue.Modified,
                        &amp;fieldValue.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan custom field value", zap.Error(err))
                        continue</span>
                }
                <span class="cov4" title="3">fieldValues = append(fieldValues, fieldValue)</span>
        }

        <span class="cov1" title="1">logger.Info("Custom field values listed",
                zap.Int("count", len(fieldValues)),
                zap.String("ticket_id", ticketID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "fieldValues": fieldValues,
                "count":       len(fieldValues),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCustomFieldValueRemove removes a custom field value from a ticket
func (h *Handler) handleCustomFieldValueRemove(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov3" title="2">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">customFieldID, ok := req.Data["customFieldId"].(string)
        if !ok || customFieldID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing customFieldId",
                        "",
                ))
                return
        }</span>

        // Soft delete the custom field value
        <span class="cov3" title="2">query := `UPDATE ticket_custom_field_value SET deleted = 1, modified = ? WHERE ticket_id = ? AND custom_field_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), ticketID, customFieldID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete custom field value", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete custom field value",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Custom field value not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Custom field value deleted",
                zap.String("ticket_id", ticketID),
                zap.String("custom_field_id", customFieldID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// Helper function to safely get int from map
func getIntFromData(data map[string]interface{}, key string) int <span class="cov5" title="4">{
        if val, ok := data[key].(float64); ok </span><span class="cov1" title="1">{
                return int(val)
        }</span>
        <span class="cov4" title="3">return 0</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleCycleCreate creates a new cycle (Sprint/Milestone/Release)
func (h *Handler) handleCycleCreate(c *gin.Context, req *models.Request) <span class="cov10" title="9">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="9">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "cycle", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="9">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse cycle data from request
        <span class="cov10" title="9">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">cycleType, ok := req.Data["type"].(float64) // JSON numbers are float64
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing type",
                        "",
                ))
                return
        }</span>

        // Get description as pointer
        <span class="cov9" title="8">var descPtr *string
        if descStr := getStringFromData(req.Data, "description"); descStr != "" </span><span class="cov3" title="2">{
                descPtr = &amp;descStr
        }</span>

        // Get parent cycle ID as pointer
        <span class="cov9" title="8">var cycleIDPtr *string
        if cycleIDStr := getStringFromData(req.Data, "cycleId"); cycleIDStr != "" </span><span class="cov3" title="2">{
                cycleIDPtr = &amp;cycleIDStr
        }</span>

        <span class="cov9" title="8">cycle := &amp;models.Cycle{
                ID:          uuid.New().String(),
                Title:       title,
                Description: descPtr,    // NULL if not provided
                CycleID:     cycleIDPtr, // Parent cycle ID (NULL for top-level)
                Type:        int(cycleType),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Validate cycle type
        if !cycle.IsValidType() </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid cycle type (must be 10, 100, or 1000)",
                        "",
                ))
                return
        }</span>

        // If parent cycle is specified, validate it exists and type hierarchy
        <span class="cov8" title="7">if cycle.CycleID != nil &amp;&amp; *cycle.CycleID != "" </span><span class="cov3" title="2">{
                var parentType int
                checkQuery := `SELECT type FROM cycle WHERE id = ? AND deleted = 0`
                err := h.db.QueryRow(c.Request.Context(), checkQuery, *cycle.CycleID).Scan(&amp;parentType)
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeEntityNotFound,
                                "Parent cycle not found",
                                "",
                        ))
                        return
                }</span>
                <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to check parent cycle", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to validate parent cycle",
                                "",
                        ))
                        return
                }</span>

                // Validate parent type hierarchy
                <span class="cov3" title="2">if !cycle.IsValidParent(parentType) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid parent cycle type (must be greater than current type)",
                                "",
                        ))
                        return
                }</span>
        }

        // Insert into database
        <span class="cov8" title="6">query := `
                INSERT INTO cycle (id, title, description, cycle_id, type, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                cycle.ID,
                cycle.Title,
                cycle.Description,
                cycle.CycleID,
                cycle.Type,
                cycle.Created,
                cycle.Modified,
                cycle.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create cycle", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create cycle",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="6">logger.Info("Cycle created",
                zap.String("cycle_id", cycle.ID),
                zap.String("title", cycle.Title),
                zap.String("type", cycle.GetTypeName()),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "cycle": cycle,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleCycleRead reads a single cycle by ID
func (h *Handler) handleCycleRead(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get cycle ID from request
        <span class="cov6" title="4">cycleID, ok := req.Data["id"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        // Query cycle from database
        <span class="cov6" title="4">query := `
                SELECT id, title, description, cycle_id, type, created, modified, deleted
                FROM cycle
                WHERE id = ? AND deleted = 0
        `

        var cycle models.Cycle
        err := h.db.QueryRow(c.Request.Context(), query, cycleID).Scan(
                &amp;cycle.ID,
                &amp;cycle.Title,
                &amp;cycle.Description,
                &amp;cycle.CycleID,
                &amp;cycle.Type,
                &amp;cycle.Created,
                &amp;cycle.Modified,
                &amp;cycle.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Cycle not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read cycle", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read cycle",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Cycle read",
                zap.String("cycle_id", cycle.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "cycle": cycle,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCycleList lists all cycles with optional filtering
func (h *Handler) handleCycleList(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Build query with optional filters
        <span class="cov5" title="3">query := `
                SELECT id, title, description, cycle_id, type, created, modified, deleted
                FROM cycle
                WHERE deleted = 0
        `
        args := make([]interface{}, 0)

        // Filter by type if provided
        if cycleType, ok := req.Data["type"].(float64); ok </span><span class="cov1" title="1">{
                query += " AND type = ?"
                args = append(args, int(cycleType))
        }</span>

        // Filter by parent cycle if provided
        <span class="cov5" title="3">if parentID, ok := req.Data["cycleId"].(string); ok &amp;&amp; parentID != "" </span><span class="cov0" title="0">{
                query += " AND cycle_id = ?"
                args = append(args, parentID)
        }</span>

        <span class="cov5" title="3">query += " ORDER BY type DESC, created DESC"

        rows, err := h.db.Query(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list cycles", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list cycles",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="3">defer rows.Close()

        cycles := make([]models.Cycle, 0)
        for rows.Next() </span><span class="cov6" title="4">{
                var cycle models.Cycle
                err := rows.Scan(
                        &amp;cycle.ID,
                        &amp;cycle.Title,
                        &amp;cycle.Description,
                        &amp;cycle.CycleID,
                        &amp;cycle.Type,
                        &amp;cycle.Created,
                        &amp;cycle.Modified,
                        &amp;cycle.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan cycle", zap.Error(err))
                        continue</span>
                }
                <span class="cov6" title="4">cycles = append(cycles, cycle)</span>
        }

        <span class="cov5" title="3">logger.Info("Cycles listed",
                zap.Int("count", len(cycles)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "cycles": cycles,
                "count":  len(cycles),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCycleModify updates an existing cycle
func (h *Handler) handleCycleModify(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "cycle", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get cycle ID
        <span class="cov5" title="3">cycleID, ok := req.Data["id"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        // Check if cycle exists and get current type
        <span class="cov5" title="3">var currentType int
        checkQuery := `SELECT type FROM cycle WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, cycleID).Scan(&amp;currentType)
        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Cycle not found",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check cycle", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to validate cycle",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov3" title="2">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov3" title="2">{
                updates["title"] = title
        }</span>
        <span class="cov3" title="2">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                if description != "" </span><span class="cov1" title="1">{
                        updates["description"] = description
                }</span> else<span class="cov0" title="0"> {
                        updates["description"] = nil
                }</span>
        }
        <span class="cov3" title="2">if cycleType, ok := req.Data["type"].(float64); ok </span><span class="cov0" title="0">{
                typeInt := int(cycleType)
                if typeInt != models.CycleTypeSprint &amp;&amp; typeInt != models.CycleTypeMilestone &amp;&amp; typeInt != models.CycleTypeRelease </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid cycle type (must be 10, 100, or 1000)",
                                "",
                        ))
                        return
                }</span>
                <span class="cov0" title="0">updates["type"] = typeInt</span>
        }
        <span class="cov3" title="2">if cycleIDStr, ok := req.Data["cycleId"].(string); ok </span><span class="cov0" title="0">{
                if cycleIDStr != "" </span><span class="cov0" title="0">{
                        updates["cycle_id"] = cycleIDStr
                }</span> else<span class="cov0" title="0"> {
                        updates["cycle_id"] = nil
                }</span>
        }

        <span class="cov3" title="2">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov3" title="2">query := "UPDATE cycle SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov7" title="5">{
                if !first </span><span class="cov5" title="3">{
                        query += ", "
                }</span>
                <span class="cov7" title="5">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov3" title="2">query += " WHERE id = ?"
        args = append(args, cycleID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update cycle", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update cycle",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Cycle updated",
                zap.String("cycle_id", cycleID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      cycleID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCycleRemove soft-deletes a cycle
func (h *Handler) handleCycleRemove(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "cycle", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get cycle ID
        <span class="cov5" title="3">cycleID, ok := req.Data["id"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the cycle
        <span class="cov5" title="3">query := `UPDATE cycle SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), cycleID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete cycle", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete cycle",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Cycle not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Cycle deleted",
                zap.String("cycle_id", cycleID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      cycleID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCycleAssignProject assigns a cycle to a project
func (h *Handler) handleCycleAssignProject(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "cycle", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get cycle ID and project ID
        <span class="cov3" title="2">cycleID, ok := req.Data["cycleId"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project ID",
                        "",
                ))
                return
        }</span>

        // Check if cycle exists
        <span class="cov3" title="2">var count int
        checkQuery := `SELECT COUNT(*) FROM cycle WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, cycleID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Cycle not found",
                        "",
                ))
                return
        }</span>

        // Check if project exists
        <span class="cov3" title="2">checkQuery = `SELECT COUNT(*) FROM project WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, projectID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Project not found",
                        "",
                ))
                return
        }</span>

        // Check if mapping already exists
        <span class="cov3" title="2">checkQuery = `SELECT COUNT(*) FROM cycle_project_mapping WHERE cycle_id = ? AND project_id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, cycleID, projectID).Scan(&amp;count)
        if err == nil &amp;&amp; count &gt; 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusConflict, models.NewErrorResponse(
                        models.ErrorCodeEntityAlreadyExists,
                        "Cycle already assigned to project",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov1" title="1">mapping := &amp;models.CycleProjectMapping{
                ID:        uuid.New().String(),
                CycleID:   cycleID,
                ProjectID: projectID,
                Created:   time.Now().Unix(),
                Modified:  time.Now().Unix(),
                Deleted:   false,
        }

        query := `
                INSERT INTO cycle_project_mapping (id, cycle_id, project_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.CycleID,
                mapping.ProjectID,
                mapping.Created,
                mapping.Modified,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to assign cycle to project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to assign cycle to project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Cycle assigned to project",
                zap.String("cycle_id", cycleID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleCycleUnassignProject unassigns a cycle from a project
func (h *Handler) handleCycleUnassignProject(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "cycle", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get cycle ID and project ID
        <span class="cov1" title="1">cycleID, ok := req.Data["cycleId"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov1" title="1">query := `
                UPDATE cycle_project_mapping
                SET deleted = 1, modified = ?
                WHERE cycle_id = ? AND project_id = ? AND deleted = 0
        `
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), cycleID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unassign cycle from project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to unassign cycle from project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Cycle-project mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Cycle unassigned from project",
                zap.String("cycle_id", cycleID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "unassigned": true,
                "cycleId":    cycleID,
                "projectId":  projectID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCycleListProjects lists all projects assigned to a cycle
func (h *Handler) handleCycleListProjects(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get cycle ID
        <span class="cov1" title="1">cycleID, ok := req.Data["cycleId"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        // Query projects assigned to cycle
        <span class="cov1" title="1">query := `
                SELECT p.id, p.title, p.description, p.created, p.modified
                FROM project p
                INNER JOIN cycle_project_mapping cpm ON p.id = cpm.project_id
                WHERE cpm.cycle_id = ? AND cpm.deleted = 0 AND p.deleted = 0
                ORDER BY p.title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query, cycleID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list cycle projects", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list cycle projects",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        projects := make([]map[string]interface{}, 0)
        for rows.Next() </span><span class="cov1" title="1">{
                var id, title, description string
                var created, modified int64
                err := rows.Scan(&amp;id, &amp;title, &amp;description, &amp;created, &amp;modified)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan project", zap.Error(err))
                        continue</span>
                }
                <span class="cov1" title="1">projects = append(projects, map[string]interface{}{
                        "id":          id,
                        "title":       title,
                        "description": description,
                        "created":     created,
                        "modified":    modified,
                })</span>
        }

        <span class="cov1" title="1">logger.Info("Cycle projects listed",
                zap.String("cycle_id", cycleID),
                zap.Int("count", len(projects)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "projects": projects,
                "count":    len(projects),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCycleAddTicket adds a ticket to a cycle
func (h *Handler) handleCycleAddTicket(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "cycle", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get cycle ID and ticket ID
        <span class="cov1" title="1">cycleID, ok := req.Data["cycleId"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Check if cycle exists
        <span class="cov1" title="1">var count int
        checkQuery := `SELECT COUNT(*) FROM cycle WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, cycleID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Cycle not found",
                        "",
                ))
                return
        }</span>

        // Check if ticket exists
        <span class="cov1" title="1">checkQuery = `SELECT COUNT(*) FROM ticket WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, ticketID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket not found",
                        "",
                ))
                return
        }</span>

        // Check if mapping already exists
        <span class="cov1" title="1">checkQuery = `SELECT COUNT(*) FROM ticket_cycle_mapping WHERE ticket_id = ? AND cycle_id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), checkQuery, ticketID, cycleID).Scan(&amp;count)
        if err == nil &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, models.NewErrorResponse(
                        models.ErrorCodeEntityAlreadyExists,
                        "Ticket already in cycle",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov1" title="1">mapping := &amp;models.TicketCycleMapping{
                ID:       uuid.New().String(),
                TicketID: ticketID,
                CycleID:  cycleID,
                Created:  time.Now().Unix(),
                Modified: time.Now().Unix(),
                Deleted:  false,
        }

        query := `
                INSERT INTO ticket_cycle_mapping (id, ticket_id, cycle_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.TicketID,
                mapping.CycleID,
                mapping.Created,
                mapping.Modified,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add ticket to cycle", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add ticket to cycle",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket added to cycle",
                zap.String("ticket_id", ticketID),
                zap.String("cycle_id", cycleID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleCycleRemoveTicket removes a ticket from a cycle
func (h *Handler) handleCycleRemoveTicket(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "cycle", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get cycle ID and ticket ID
        <span class="cov1" title="1">cycleID, ok := req.Data["cycleId"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov1" title="1">query := `
                UPDATE ticket_cycle_mapping
                SET deleted = 1, modified = ?
                WHERE ticket_id = ? AND cycle_id = ? AND deleted = 0
        `
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), ticketID, cycleID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove ticket from cycle", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove ticket from cycle",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket-cycle mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket removed from cycle",
                zap.String("ticket_id", ticketID),
                zap.String("cycle_id", cycleID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":  true,
                "ticketId": ticketID,
                "cycleId":  cycleID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCycleListTickets lists all tickets in a cycle
func (h *Handler) handleCycleListTickets(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get cycle ID
        <span class="cov1" title="1">cycleID, ok := req.Data["cycleId"].(string)
        if !ok || cycleID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing cycle ID",
                        "",
                ))
                return
        }</span>

        // Query tickets in cycle
        <span class="cov1" title="1">query := `
                SELECT t.id, t.title, t.description, t.ticket_status_id, t.created, t.modified
                FROM ticket t
                INNER JOIN ticket_cycle_mapping tcm ON t.id = tcm.ticket_id
                WHERE tcm.cycle_id = ? AND tcm.deleted = 0 AND t.deleted = 0
                ORDER BY t.created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, cycleID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list cycle tickets", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list cycle tickets",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        tickets := make([]map[string]interface{}, 0)
        for rows.Next() </span><span class="cov1" title="1">{
                var id, title, description, ticketStatusID string
                var created, modified int64
                err := rows.Scan(&amp;id, &amp;title, &amp;description, &amp;ticketStatusID, &amp;created, &amp;modified)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket", zap.Error(err))
                        continue</span>
                }
                <span class="cov1" title="1">tickets = append(tickets, map[string]interface{}{
                        "id":               id,
                        "title":            title,
                        "description":      description,
                        "ticket_status_id": ticketStatusID,
                        "created":          created,
                        "modified":         modified,
                })</span>
        }

        <span class="cov1" title="1">logger.Info("Cycle tickets listed",
                zap.String("cycle_id", cycleID),
                zap.Int("count", len(tickets)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "tickets": tickets,
                "count":   len(tickets),
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "context"
        "time"

        "github.com/google/uuid"
        "helixtrack.ru/core/internal/database"
)

// InitializeProjectTables creates the projects, tickets, and comments tables if they don't exist
func InitializeProjectTables(db database.Database) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Create workflow table (simplified)
        workflowSQL := `
                CREATE TABLE IF NOT EXISTS workflow (
                        id TEXT NOT NULL PRIMARY KEY UNIQUE,
                        title TEXT NOT NULL,
                        description TEXT,
                        created INTEGER NOT NULL,
                        modified INTEGER NOT NULL,
                        deleted BOOLEAN NOT NULL DEFAULT 0
                );
        `
        if _, err := db.Exec(ctx, workflowSQL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create project table
        <span class="cov0" title="0">projectSQL := `
                CREATE TABLE IF NOT EXISTS project (
                        id TEXT NOT NULL PRIMARY KEY UNIQUE,
                        identifier TEXT NOT NULL UNIQUE,
                        title TEXT NOT NULL,
                        description TEXT,
                        workflow_id TEXT NOT NULL,
                        created INTEGER NOT NULL,
                        modified INTEGER NOT NULL,
                        deleted BOOLEAN NOT NULL DEFAULT 0
                );
                CREATE INDEX IF NOT EXISTS projects_get_by_identifier ON project (identifier);
                CREATE INDEX IF NOT EXISTS projects_get_by_title ON project (title);
                CREATE INDEX IF NOT EXISTS projects_get_by_deleted ON project (deleted);
        `
        if _, err := db.Exec(ctx, projectSQL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create ticket_type table
        <span class="cov0" title="0">ticketTypeSQL := `
                CREATE TABLE IF NOT EXISTS ticket_type (
                        id TEXT NOT NULL PRIMARY KEY UNIQUE,
                        title TEXT NOT NULL UNIQUE,
                        description TEXT,
                        created INTEGER NOT NULL,
                        modified INTEGER NOT NULL,
                        deleted BOOLEAN NOT NULL DEFAULT 0
                );
                CREATE INDEX IF NOT EXISTS ticket_types_get_by_title ON ticket_type (title);
        `
        if _, err := db.Exec(ctx, ticketTypeSQL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create ticket_status table
        <span class="cov0" title="0">ticketStatusSQL := `
                CREATE TABLE IF NOT EXISTS ticket_status (
                        id TEXT NOT NULL PRIMARY KEY UNIQUE,
                        title TEXT NOT NULL UNIQUE,
                        description TEXT,
                        created INTEGER NOT NULL,
                        modified INTEGER NOT NULL,
                        deleted BOOLEAN NOT NULL DEFAULT 0
                );
                CREATE INDEX IF NOT EXISTS ticket_statuses_get_by_title ON ticket_status (title);
        `
        if _, err := db.Exec(ctx, ticketStatusSQL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create ticket table
        <span class="cov0" title="0">ticketSQL := `
                CREATE TABLE IF NOT EXISTS ticket (
                        id TEXT NOT NULL PRIMARY KEY UNIQUE,
                        ticket_number INTEGER NOT NULL,
                        position INTEGER NOT NULL DEFAULT 0,
                        title TEXT,
                        description TEXT,
                        created INTEGER NOT NULL,
                        modified INTEGER NOT NULL,
                        ticket_type_id TEXT NOT NULL,
                        ticket_status_id TEXT NOT NULL,
                        project_id TEXT NOT NULL,
                        user_id TEXT,
                        estimation REAL NOT NULL DEFAULT 0,
                        story_points INTEGER NOT NULL DEFAULT 0,
                        creator TEXT NOT NULL,
                        deleted BOOLEAN NOT NULL DEFAULT 0,
                        UNIQUE (ticket_number, project_id)
                );
                CREATE INDEX IF NOT EXISTS tickets_get_by_project_id ON ticket (project_id);
                CREATE INDEX IF NOT EXISTS tickets_get_by_title ON ticket (title);
                CREATE INDEX IF NOT EXISTS tickets_get_by_deleted ON ticket (deleted);
        `
        if _, err := db.Exec(ctx, ticketSQL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create comment table
        <span class="cov0" title="0">commentSQL := `
                CREATE TABLE IF NOT EXISTS comment (
                        id TEXT NOT NULL PRIMARY KEY UNIQUE,
                        comment TEXT NOT NULL,
                        created INTEGER NOT NULL,
                        modified INTEGER NOT NULL,
                        deleted BOOLEAN NOT NULL DEFAULT 0
                );
                CREATE INDEX IF NOT EXISTS comments_get_by_created ON comment (created);
        `
        if _, err := db.Exec(ctx, commentSQL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create comment_ticket_mapping table
        <span class="cov0" title="0">commentTicketMappingSQL := `
                CREATE TABLE IF NOT EXISTS comment_ticket_mapping (
                        id TEXT NOT NULL PRIMARY KEY UNIQUE,
                        comment_id TEXT NOT NULL,
                        ticket_id TEXT NOT NULL,
                        created INTEGER NOT NULL,
                        modified INTEGER NOT NULL
                );
                CREATE INDEX IF NOT EXISTS comment_ticket_mapping_by_ticket ON comment_ticket_mapping (ticket_id);
                CREATE INDEX IF NOT EXISTS comment_ticket_mapping_by_comment ON comment_ticket_mapping (comment_id);
        `
        if _, err := db.Exec(ctx, commentTicketMappingSQL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Seed default data
        <span class="cov0" title="0">if err := seedDefaultData(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// seedDefaultData inserts default workflow, ticket types, and statuses
func seedDefaultData(db database.Database) error <span class="cov0" title="0">{
        ctx := context.Background()
        now := time.Now().Unix()

        // Check if workflow already exists
        var count int
        err := db.QueryRow(ctx, "SELECT COUNT(*) FROM workflow").Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                // Insert default workflow
                defaultWorkflowID := uuid.New().String()
                _, err = db.Exec(ctx, `
                        INSERT INTO workflow (id, title, description, created, modified, deleted)
                        VALUES (?, ?, ?, ?, ?, ?)
                `, defaultWorkflowID, "Default Workflow", "Default workflow for projects", now, now, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Seed ticket types
        <span class="cov0" title="0">ticketTypes := []struct {
                title       string
                description string
        }{
                {"bug", "Bug or defect"},
                {"feature", "New feature request"},
                {"task", "General task"},
                {"story", "User story"},
                {"epic", "Epic"},
        }

        for _, tt := range ticketTypes </span><span class="cov0" title="0">{
                // Check if exists
                err := db.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_type WHERE title = ?", tt.title).Scan(&amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                        _, err = db.Exec(ctx, `
                                INSERT INTO ticket_type (id, title, description, created, modified, deleted)
                                VALUES (?, ?, ?, ?, ?, ?)
                        `, uuid.New().String(), tt.title, tt.description, now, now, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Seed ticket statuses
        <span class="cov0" title="0">ticketStatuses := []struct {
                title       string
                description string
        }{
                {"open", "Ticket is open"},
                {"in_progress", "Work in progress"},
                {"review", "Under review"},
                {"testing", "Being tested"},
                {"done", "Completed"},
                {"closed", "Closed"},
        }

        for _, ts := range ticketStatuses </span><span class="cov0" title="0">{
                // Check if exists
                err := db.QueryRow(ctx, "SELECT COUNT(*) FROM ticket_status WHERE title = ?", ts.title).Scan(&amp;count)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                        _, err = db.Exec(ctx, `
                                INSERT INTO ticket_status (id, title, description, created, modified, deleted)
                                VALUES (?, ?, ?, ?, ?, ?)
                        `, uuid.New().String(), ts.title, ts.description, now, now, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleExtensionCreate creates a new extension
func (h *Handler) handleExtensionCreate(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "extension", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse extension data from request
        <span class="cov5" title="2">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">enabled := false
        if enabledVal, ok := req.Data["enabled"].(bool); ok </span><span class="cov1" title="1">{
                enabled = enabledVal
        }</span>

        // Get description as pointer
        <span class="cov1" title="1">var descPtr *string
        if descStr := getStringFromData(req.Data, "description"); descStr != "" </span><span class="cov1" title="1">{
                descPtr = &amp;descStr
        }</span>

        <span class="cov1" title="1">extension := &amp;models.Extension{
                ID:          uuid.New().String(),
                Title:       title,
                Description: descPtr,
                Version:     getStringFromData(req.Data, "version"),
                Enabled:     enabled,
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Validate extension
        if !extension.IsValid() </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid extension data",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov1" title="1">query := `
                INSERT INTO extension (id, title, description, version, enabled, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                extension.ID,
                extension.Title,
                extension.Description,
                extension.Version,
                extension.Enabled,
                extension.Created,
                extension.Modified,
                extension.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create extension", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create extension",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Extension created",
                zap.String("extension_id", extension.ID),
                zap.String("title", extension.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "extension": extension,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleExtensionRead reads a single extension by ID
func (h *Handler) handleExtensionRead(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get extension ID from request
        <span class="cov5" title="2">extensionID, ok := req.Data["id"].(string)
        if !ok || extensionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing extension ID",
                        "",
                ))
                return
        }</span>

        // Query extension from database
        <span class="cov5" title="2">query := `
                SELECT id, title, description, version, enabled, created, modified, deleted
                FROM extension
                WHERE id = ? AND deleted = 0
        `

        var extension models.Extension
        err := h.db.QueryRow(c.Request.Context(), query, extensionID).Scan(
                &amp;extension.ID,
                &amp;extension.Title,
                &amp;extension.Description,
                &amp;extension.Version,
                &amp;extension.Enabled,
                &amp;extension.Created,
                &amp;extension.Modified,
                &amp;extension.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Extension not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read extension", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read extension",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Extension read",
                zap.String("extension_id", extension.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "extension": extension,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleExtensionList lists all extensions
func (h *Handler) handleExtensionList(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted extensions
        <span class="cov5" title="2">query := `
                SELECT id, title, description, version, enabled, created, modified, deleted
                FROM extension
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list extensions", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list extensions",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="2">defer rows.Close()

        extensions := make([]models.Extension, 0)
        for rows.Next() </span><span class="cov8" title="3">{
                var extension models.Extension
                err := rows.Scan(
                        &amp;extension.ID,
                        &amp;extension.Title,
                        &amp;extension.Description,
                        &amp;extension.Version,
                        &amp;extension.Enabled,
                        &amp;extension.Created,
                        &amp;extension.Modified,
                        &amp;extension.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan extension", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="3">extensions = append(extensions, extension)</span>
        }

        <span class="cov5" title="2">logger.Info("Extensions listed",
                zap.Int("count", len(extensions)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "extensions": extensions,
                "count":      len(extensions),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleExtensionModify updates an existing extension
func (h *Handler) handleExtensionModify(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "extension", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get extension ID
        <span class="cov5" title="2">extensionID, ok := req.Data["id"].(string)
        if !ok || extensionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing extension ID",
                        "",
                ))
                return
        }</span>

        // Check if extension exists
        <span class="cov5" title="2">checkQuery := `SELECT COUNT(*) FROM extension WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, extensionID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Extension not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov1" title="1">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov1" title="1">{
                updates["title"] = title
        }</span>
        <span class="cov1" title="1">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                if description != "" </span><span class="cov1" title="1">{
                        updates["description"] = description
                }</span> else<span class="cov0" title="0"> {
                        updates["description"] = nil
                }</span>
        }
        <span class="cov1" title="1">if version, ok := req.Data["version"].(string); ok </span><span class="cov1" title="1">{
                updates["version"] = version
        }</span>
        <span class="cov1" title="1">if enabled, ok := req.Data["enabled"].(bool); ok </span><span class="cov0" title="0">{
                updates["enabled"] = enabled
        }</span>

        <span class="cov1" title="1">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov1" title="1">queryStr := "UPDATE extension SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov10" title="4">{
                if !first </span><span class="cov8" title="3">{
                        queryStr += ", "
                }</span>
                <span class="cov10" title="4">queryStr += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov1" title="1">queryStr += " WHERE id = ?"
        args = append(args, extensionID)

        _, err = h.db.Exec(c.Request.Context(), queryStr, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update extension", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update extension",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Extension updated",
                zap.String("extension_id", extensionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      extensionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleExtensionRemove soft-deletes an extension
func (h *Handler) handleExtensionRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "extension", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get extension ID
        <span class="cov1" title="1">extensionID, ok := req.Data["id"].(string)
        if !ok || extensionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing extension ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the extension
        <span class="cov1" title="1">query := `UPDATE extension SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), extensionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete extension", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete extension",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Extension not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Extension deleted",
                zap.String("extension_id", extensionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      extensionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleExtensionEnable enables an extension
func (h *Handler) handleExtensionEnable(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "extension", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get extension ID
        <span class="cov5" title="2">extensionID, ok := req.Data["id"].(string)
        if !ok || extensionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing extension ID",
                        "",
                ))
                return
        }</span>

        // Enable the extension
        <span class="cov5" title="2">query := `UPDATE extension SET enabled = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), extensionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to enable extension", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to enable extension",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Extension not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Extension enabled",
                zap.String("extension_id", extensionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "enabled": true,
                "id":      extensionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleExtensionDisable disables an extension
func (h *Handler) handleExtensionDisable(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "extension", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get extension ID
        <span class="cov1" title="1">extensionID, ok := req.Data["id"].(string)
        if !ok || extensionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing extension ID",
                        "",
                ))
                return
        }</span>

        // Disable the extension
        <span class="cov1" title="1">query := `UPDATE extension SET enabled = 0, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), extensionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to disable extension", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to disable extension",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Extension not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Extension disabled",
                zap.String("extension_id", extensionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "disabled": true,
                "id":       extensionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleExtensionSetMetadata sets metadata for an extension
func (h *Handler) handleExtensionSetMetadata(c *gin.Context, req *models.Request) <span class="cov8" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Parse metadata from request
        <span class="cov8" title="3">extensionID, ok := req.Data["extensionId"].(string)
        if !ok || extensionID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing extensionId",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Value can be any type, convert to JSON string
        <span class="cov1" title="1">var valueStr string
        if value, ok := req.Data["value"]; ok </span><span class="cov1" title="1">{
                valueBytes, err := json.Marshal(value)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid value format",
                                "",
                        ))
                        return
                }</span>
                <span class="cov1" title="1">valueStr = string(valueBytes)</span>
        }

        <span class="cov1" title="1">metadata := &amp;models.ExtensionMetaData{
                ID:          uuid.New().String(),
                ExtensionID: extensionID,
                Property:    property,
                Value:       valueStr,
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO extension_metadata (id, extension_id, property, value, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err := h.db.Exec(c.Request.Context(), query,
                metadata.ID,
                metadata.ExtensionID,
                metadata.Property,
                metadata.Value,
                metadata.Created,
                metadata.Modified,
                metadata.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to set extension metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to set extension metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Extension metadata set",
                zap.String("metadata_id", metadata.ID),
                zap.String("extension_id", extensionID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
        })
        c.JSON(http.StatusCreated, response)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleFilterSave creates a new filter or updates an existing one
func (h *Handler) handleFilterSave(c *gin.Context, req *models.Request) <span class="cov7" title="13">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get user ID from context (should be available from JWT)
        <span class="cov7" title="13">userID := username // In a real system, this would be the actual user ID from JWT claims

        // Parse filter data from request
        title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="11">query, ok := req.Data["query"].(string)
        if !ok || query == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing query",
                        "",
                ))
                return
        }</span>

        // Validate query is valid JSON
        <span class="cov6" title="10">var queryObj interface{}
        if err := json.Unmarshal([]byte(query), &amp;queryObj); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid query format (must be valid JSON)",
                        "",
                ))
                return
        }</span>

        // Check if this is an update (ID provided) or create (no ID)
        <span class="cov6" title="9">filterID, hasID := req.Data["id"].(string)
        isUpdate := hasID &amp;&amp; filterID != ""

        if isUpdate </span><span class="cov4" title="4">{
                // Update existing filter - check ownership first
                ownerCheckQuery := `SELECT owner_id FROM filter WHERE id = ? AND deleted = 0`
                var ownerID string
                err := h.db.QueryRow(c.Request.Context(), ownerCheckQuery, filterID).Scan(&amp;ownerID)
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, models.NewErrorResponse(
                                models.ErrorCodeEntityNotFound,
                                "Filter not found",
                                "",
                        ))
                        return
                }</span>
                <span class="cov3" title="3">if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to check filter ownership", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to check filter ownership",
                                "",
                        ))
                        return
                }</span>

                // Verify ownership
                <span class="cov3" title="3">if ownerID != userID </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, models.NewErrorResponse(
                                models.ErrorCodeForbidden,
                                "You can only modify your own filters",
                                "",
                        ))
                        return
                }</span>

                // Update the filter
                <span class="cov2" title="2">updateQuery := `
                        UPDATE filter
                        SET title = ?, description = ?, query = ?, is_public = ?, is_favorite = ?, modified = ?
                        WHERE id = ? AND deleted = 0
                `

                description := getStringFromData(req.Data, "description")
                isPublic := getBoolFromData(req.Data, "isPublic")
                isFavorite := getBoolFromData(req.Data, "isFavorite")

                _, err = h.db.Exec(c.Request.Context(), updateQuery,
                        title,
                        description,
                        query,
                        isPublic,
                        isFavorite,
                        time.Now().Unix(),
                        filterID,
                )

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to update filter", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to update filter",
                                "",
                        ))
                        return
                }</span>

                <span class="cov2" title="2">logger.Info("Filter updated",
                        zap.String("filter_id", filterID),
                        zap.String("title", title),
                        zap.String("username", username),
                )

                // Publish filter updated event
                h.publisher.PublishEntityEvent(
                        models.ActionModify,
                        "filter",
                        filterID,
                        username,
                        map[string]interface{}{
                                "id":          filterID,
                                "title":       title,
                                "description": description,
                                "owner_id":    userID,
                                "is_public":   isPublic,
                                "is_favorite": isFavorite,
                        },
                        websocket.NewProjectContext("", []string{"READ"}), // User-level entity, system-wide context
                )

                response := models.NewSuccessResponse(map[string]interface{}{
                        "filter": map[string]interface{}{
                                "id":          filterID,
                                "title":       title,
                                "description": description,
                                "ownerId":     userID,
                                "query":       query,
                                "isPublic":    isPublic,
                                "isFavorite":  isFavorite,
                                "modified":    time.Now().Unix(),
                        },
                })
                c.JSON(http.StatusOK, response)
                return</span>
        }

        // Create new filter
        <span class="cov5" title="5">filter := &amp;models.Filter{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                OwnerID:     userID,
                Query:       query,
                IsPublic:    getBoolFromData(req.Data, "isPublic"),
                IsFavorite:  getBoolFromData(req.Data, "isFavorite"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        insertQuery := `
                INSERT INTO filter (id, title, description, owner_id, query, is_public, is_favorite, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := h.db.Exec(c.Request.Context(), insertQuery,
                filter.ID,
                filter.Title,
                filter.Description,
                filter.OwnerID,
                filter.Query,
                filter.IsPublic,
                filter.IsFavorite,
                filter.Created,
                filter.Modified,
                filter.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create filter", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create filter",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="5">logger.Info("Filter created",
                zap.String("filter_id", filter.ID),
                zap.String("title", filter.Title),
                zap.String("username", username),
        )

        // Publish filter created event
        h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "filter",
                filter.ID,
                username,
                map[string]interface{}{
                        "id":          filter.ID,
                        "title":       filter.Title,
                        "description": filter.Description,
                        "owner_id":    filter.OwnerID,
                        "is_public":   filter.IsPublic,
                        "is_favorite": filter.IsFavorite,
                },
                websocket.NewProjectContext("", []string{"READ"}), // User-level entity, system-wide context
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "filter": filter,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleFilterLoad loads a filter by ID
func (h *Handler) handleFilterLoad(c *gin.Context, req *models.Request) <span class="cov6" title="7">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="7">userID := username // In a real system, this would be the actual user ID from JWT claims

        // Get filter ID from request
        filterID, ok := req.Data["id"].(string)
        if !ok || filterID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing filter ID",
                        "",
                ))
                return
        }</span>

        // Query filter from database
        <span class="cov6" title="7">query := `
                SELECT id, title, description, owner_id, query, is_public, is_favorite, created, modified, deleted
                FROM filter
                WHERE id = ? AND deleted = 0
        `

        var filter models.Filter
        err := h.db.QueryRow(c.Request.Context(), query, filterID).Scan(
                &amp;filter.ID,
                &amp;filter.Title,
                &amp;filter.Description,
                &amp;filter.OwnerID,
                &amp;filter.Query,
                &amp;filter.IsPublic,
                &amp;filter.IsFavorite,
                &amp;filter.Created,
                &amp;filter.Modified,
                &amp;filter.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov2" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Filter not found",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="5">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load filter", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to load filter",
                        "",
                ))
                return
        }</span>

        // Check if user has access to this filter
        // User has access if: they own it, it's public, or it's shared with them
        <span class="cov5" title="5">hasAccess := filter.OwnerID == userID || filter.IsPublic

        if !hasAccess </span><span class="cov2" title="2">{
                // Check if shared with user
                shareQuery := `
                        SELECT COUNT(*)
                        FROM filter_share_mapping
                        WHERE filter_id = ? AND user_id = ? AND deleted = 0
                `
                var shareCount int
                err = h.db.QueryRow(c.Request.Context(), shareQuery, filterID, userID).Scan(&amp;shareCount)
                if err == nil &amp;&amp; shareCount &gt; 0 </span><span class="cov1" title="1">{
                        hasAccess = true
                }</span>
        }

        <span class="cov5" title="5">if !hasAccess </span><span class="cov1" title="1">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "You do not have access to this filter",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="4">logger.Info("Filter loaded",
                zap.String("filter_id", filter.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "filter": filter,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleFilterList lists all filters accessible to the user
func (h *Handler) handleFilterList(c *gin.Context, req *models.Request) <span class="cov5" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="5">userID := username // In a real system, this would be the actual user ID from JWT claims

        // Query all filters that the user has access to:
        // 1. Filters owned by the user
        // 2. Public filters
        // 3. Filters shared with the user
        query := `
                SELECT DISTINCT f.id, f.title, f.description, f.owner_id, f.query, f.is_public, f.is_favorite, f.created, f.modified, f.deleted
                FROM filter f
                LEFT JOIN filter_share_mapping fsm ON f.id = fsm.filter_id AND fsm.deleted = 0
                WHERE f.deleted = 0
                AND (
                        f.owner_id = ?           -- User's own filters
                        OR f.is_public = 1       -- Public filters
                        OR fsm.user_id = ?       -- Shared with user
                )
                ORDER BY f.is_favorite DESC, f.modified DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, userID, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list filters", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list filters",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="5">defer rows.Close()

        filters := make([]models.Filter, 0)
        for rows.Next() </span><span class="cov6" title="8">{
                var filter models.Filter
                err := rows.Scan(
                        &amp;filter.ID,
                        &amp;filter.Title,
                        &amp;filter.Description,
                        &amp;filter.OwnerID,
                        &amp;filter.Query,
                        &amp;filter.IsPublic,
                        &amp;filter.IsFavorite,
                        &amp;filter.Created,
                        &amp;filter.Modified,
                        &amp;filter.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan filter", zap.Error(err))
                        continue</span>
                }
                <span class="cov6" title="8">filters = append(filters, filter)</span>
        }

        <span class="cov5" title="5">logger.Info("Filters listed",
                zap.Int("count", len(filters)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "filters": filters,
                "count":   len(filters),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleFilterShare shares a filter with a user, team, or project
func (h *Handler) handleFilterShare(c *gin.Context, req *models.Request) <span class="cov6" title="8">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="8">userID := username // In a real system, this would be the actual user ID from JWT claims

        // Get filter ID
        filterID, ok := req.Data["filterId"].(string)
        if !ok || filterID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing filter ID",
                        "",
                ))
                return
        }</span>

        // Check if filter exists and user owns it
        <span class="cov6" title="8">ownerCheckQuery := `SELECT owner_id FROM filter WHERE id = ? AND deleted = 0`
        var ownerID string
        err := h.db.QueryRow(c.Request.Context(), ownerCheckQuery, filterID).Scan(&amp;ownerID)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Filter not found",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="8">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check filter ownership", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check filter ownership",
                        "",
                ))
                return
        }</span>

        // Verify ownership
        <span class="cov6" title="8">if ownerID != userID </span><span class="cov2" title="2">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "You can only share your own filters",
                        "",
                ))
                return
        }</span>

        // Determine share type
        <span class="cov5" title="6">shareType, ok := req.Data["shareType"].(string)
        if !ok || shareType == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing share type (user, team, project, or public)",
                        "",
                ))
                return
        }</span>

        // Handle public sharing separately
        <span class="cov5" title="6">if shareType == string(models.ShareTypePublic) </span><span class="cov3" title="3">{
                updateQuery := `UPDATE filter SET is_public = 1, modified = ? WHERE id = ?`
                _, err = h.db.Exec(c.Request.Context(), updateQuery, time.Now().Unix(), filterID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to make filter public", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Failed to make filter public",
                                "",
                        ))
                        return
                }</span>

                <span class="cov3" title="3">logger.Info("Filter made public",
                        zap.String("filter_id", filterID),
                        zap.String("username", username),
                )

                // Publish filter shared event (public)
                h.publisher.PublishEntityEvent(
                        models.ActionModify,
                        "filter",
                        filterID,
                        username,
                        map[string]interface{}{
                                "id":         filterID,
                                "owner_id":   ownerID,
                                "share_type": shareType,
                                "is_public":  true,
                        },
                        websocket.NewProjectContext("", []string{"READ"}), // User-level entity, system-wide context
                )

                response := models.NewSuccessResponse(map[string]interface{}{
                        "shared":     true,
                        "filterId":   filterID,
                        "shareType":  shareType,
                        "isPublic":   true,
                })
                c.JSON(http.StatusOK, response)
                return</span>
        }

        // Create share mapping
        <span class="cov3" title="3">shareMapping := &amp;models.FilterShareMapping{
                ID:       uuid.New().String(),
                FilterID: filterID,
                Created:  time.Now().Unix(),
                Deleted:  false,
        }

        // Set the appropriate ID based on share type
        switch models.ShareType(shareType) </span>{
        case models.ShareTypeUser:<span class="cov2" title="2">
                shareUserID, ok := req.Data["userId"].(string)
                if !ok || shareUserID == "" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeMissingData,
                                "Missing user ID for user share",
                                "",
                        ))
                        return
                }</span>
                <span class="cov1" title="1">shareMapping.UserID = &amp;shareUserID</span>

        case models.ShareTypeTeam:<span class="cov1" title="1">
                shareTeamID, ok := req.Data["teamId"].(string)
                if !ok || shareTeamID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeMissingData,
                                "Missing team ID for team share",
                                "",
                        ))
                        return
                }</span>
                <span class="cov1" title="1">shareMapping.TeamID = &amp;shareTeamID</span>

        case models.ShareTypeProject:<span class="cov0" title="0">
                shareProjectID, ok := req.Data["projectId"].(string)
                if !ok || shareProjectID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeMissingData,
                                "Missing project ID for project share",
                                "",
                        ))
                        return
                }</span>
                <span class="cov0" title="0">shareMapping.ProjectID = &amp;shareProjectID</span>

        default:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid share type (must be user, team, project, or public)",
                        "",
                ))
                return</span>
        }

        // Insert share mapping
        <span class="cov2" title="2">insertQuery := `
                INSERT INTO filter_share_mapping (id, filter_id, user_id, team_id, project_id, created, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), insertQuery,
                shareMapping.ID,
                shareMapping.FilterID,
                shareMapping.UserID,
                shareMapping.TeamID,
                shareMapping.ProjectID,
                shareMapping.Created,
                shareMapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to share filter", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to share filter",
                        "",
                ))
                return
        }</span>

        <span class="cov2" title="2">logger.Info("Filter shared",
                zap.String("filter_id", filterID),
                zap.String("share_type", shareType),
                zap.String("username", username),
        )

        // Publish filter shared event (user/team/project)
        eventData := map[string]interface{}{
                "id":         filterID,
                "owner_id":   ownerID,
                "share_type": shareType,
                "share_id":   shareMapping.ID,
        }
        if shareMapping.UserID != nil </span><span class="cov1" title="1">{
                eventData["user_id"] = *shareMapping.UserID
        }</span>
        <span class="cov2" title="2">if shareMapping.TeamID != nil </span><span class="cov1" title="1">{
                eventData["team_id"] = *shareMapping.TeamID
        }</span>
        <span class="cov2" title="2">if shareMapping.ProjectID != nil </span><span class="cov0" title="0">{
                eventData["project_id"] = *shareMapping.ProjectID
        }</span>
        <span class="cov2" title="2">h.publisher.PublishEntityEvent(
                models.ActionModify,
                "filter",
                filterID,
                username,
                eventData,
                websocket.NewProjectContext("", []string{"READ"}), // User-level entity, system-wide context
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "shared":    true,
                "filterId":  filterID,
                "shareType": shareType,
                "shareId":   shareMapping.ID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleFilterModify modifies an existing filter
func (h *Handler) handleFilterModify(c *gin.Context, req *models.Request) <span class="cov5" title="6">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="6">userID := username // In a real system, this would be the actual user ID from JWT claims

        // Get filter ID
        filterID, ok := req.Data["id"].(string)
        if !ok || filterID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing filter ID",
                        "",
                ))
                return
        }</span>

        // Check if filter exists and user owns it
        <span class="cov5" title="6">ownerCheckQuery := `SELECT owner_id FROM filter WHERE id = ? AND deleted = 0`
        var ownerID string
        err := h.db.QueryRow(c.Request.Context(), ownerCheckQuery, filterID).Scan(&amp;ownerID)
        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Filter not found",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="5">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check filter ownership", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check filter ownership",
                        "",
                ))
                return
        }</span>

        // Verify ownership
        <span class="cov5" title="5">if ownerID != userID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "You can only modify your own filters",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov5" title="5">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov3" title="3">{
                updates["title"] = title
        }</span>
        <span class="cov5" title="5">if description, ok := req.Data["description"].(string); ok </span><span class="cov0" title="0">{
                updates["description"] = description
        }</span>
        <span class="cov5" title="5">if query, ok := req.Data["query"].(string); ok &amp;&amp; query != "" </span><span class="cov4" title="4">{
                // Validate query is valid JSON
                var queryObj interface{}
                if err := json.Unmarshal([]byte(query), &amp;queryObj); err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid query format (must be valid JSON)",
                                "",
                        ))
                        return
                }</span>
                <span class="cov3" title="3">updates["query"] = query</span>
        }
        <span class="cov4" title="4">if isPublic, ok := req.Data["isPublic"].(bool); ok </span><span class="cov0" title="0">{
                updates["is_public"] = isPublic
        }</span>
        <span class="cov4" title="4">if isFavorite, ok := req.Data["isFavorite"].(bool); ok </span><span class="cov0" title="0">{
                updates["is_favorite"] = isFavorite
        }</span>

        <span class="cov4" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov3" title="3">query := "UPDATE filter SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov6" title="9">{
                if !first </span><span class="cov5" title="6">{
                        query += ", "
                }</span>
                <span class="cov6" title="9">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov3" title="3">query += " WHERE id = ?"
        args = append(args, filterID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update filter", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update filter",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="3">logger.Info("Filter modified",
                zap.String("filter_id", filterID),
                zap.String("username", username),
        )

        // Publish filter updated event
        h.publisher.PublishEntityEvent(
                models.ActionModify,
                "filter",
                filterID,
                username,
                updates,
                websocket.NewProjectContext("", []string{"READ"}), // User-level entity, system-wide context
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      filterID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleFilterRemove soft-deletes a filter
func (h *Handler) handleFilterRemove(c *gin.Context, req *models.Request) <span class="cov5" title="6">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="6">userID := username // In a real system, this would be the actual user ID from JWT claims

        // Get filter ID
        filterID, ok := req.Data["id"].(string)
        if !ok || filterID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing filter ID",
                        "",
                ))
                return
        }</span>

        // Check if filter exists and user owns it
        <span class="cov5" title="6">ownerCheckQuery := `SELECT owner_id FROM filter WHERE id = ? AND deleted = 0`
        var ownerID string
        err := h.db.QueryRow(c.Request.Context(), ownerCheckQuery, filterID).Scan(&amp;ownerID)
        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Filter not found",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="5">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check filter ownership", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check filter ownership",
                        "",
                ))
                return
        }</span>

        // Verify ownership
        <span class="cov5" title="5">if ownerID != userID </span><span class="cov1" title="1">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "You can only delete your own filters",
                        "",
                ))
                return
        }</span>

        // Soft delete the filter
        <span class="cov4" title="4">query := `UPDATE filter SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), filterID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete filter", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete filter",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="4">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Filter not found",
                        "",
                ))
                return
        }</span>

        // Also soft-delete all share mappings for this filter
        <span class="cov4" title="4">shareDeleteQuery := `UPDATE filter_share_mapping SET deleted = 1 WHERE filter_id = ? AND deleted = 0`
        _, err = h.db.Exec(c.Request.Context(), shareDeleteQuery, filterID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to delete filter share mappings", zap.Error(err))
                // Don't fail the request if share deletion fails
        }</span>

        <span class="cov4" title="4">logger.Info("Filter deleted",
                zap.String("filter_id", filterID),
                zap.String("username", username),
        )

        // Publish filter deleted event
        h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "filter",
                filterID,
                username,
                map[string]interface{}{
                        "id":       filterID,
                        "owner_id": ownerID,
                },
                websocket.NewProjectContext("", []string{"READ"}), // User-level entity, system-wide context
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      filterID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// Helper function to safely get bool from map
func getBoolFromData(data map[string]interface{}, key string) bool <span class="cov10" title="33">{
        if val, ok := data[key].(bool); ok </span><span class="cov7" title="14">{
                return val
        }</span>
        <span class="cov8" title="19">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
        "helixtrack.ru/core/internal/websocket"
)

// Handler manages all HTTP handlers
type Handler struct {
        db          database.Database
        authService services.AuthService
        permService services.PermissionService
        version     string
        publisher   websocket.EventPublisher
}

// NewHandler creates a new handler instance
func NewHandler(db database.Database, authService services.AuthService, permService services.PermissionService, version string) *Handler <span class="cov9" title="633">{
        return &amp;Handler{
                db:          db,
                authService: authService,
                permService: permService,
                version:     version,
                publisher:   websocket.NewNoOpPublisher(), // Default to no-op publisher
        }
}</span>

// SetEventPublisher sets the event publisher for the handler
func (h *Handler) SetEventPublisher(publisher websocket.EventPublisher) <span class="cov6" title="60">{
        h.publisher = publisher
}</span>

// DoAction handles the unified /do endpoint with action-based routing
func (h *Handler) DoAction(c *gin.Context) <span class="cov10" title="640">{
        // Get the already-parsed request from context (set by server.go)
        reqInterface, exists := c.Get("request")
        if !exists </span><span class="cov1" title="1">{
                logger.Error("Request not found in context")
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid request format",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="639">req, ok := reqInterface.(*models.Request)
        if !ok </span><span class="cov0" title="0">{
                logger.Error("Invalid request type in context")
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid request format",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="639">logger.Info("Processing action",
                zap.String("action", req.Action),
                zap.String("object", req.Object),
        )

        // Route to appropriate handler based on action
        switch req.Action </span>{
        // System actions
        case models.ActionVersion:<span class="cov1" title="1">
                h.handleVersion(c, req)</span>
        case models.ActionJWTCapable:<span class="cov1" title="1">
                h.handleJWTCapable(c, req)</span>
        case models.ActionDBCapable:<span class="cov1" title="1">
                h.handleDBCapable(c, req)</span>
        case models.ActionHealth:<span class="cov1" title="1">
                h.handleHealth(c, req)</span>
        case models.ActionAuthenticate:<span class="cov2" title="4">
                h.handleAuthenticate(c, req)</span>

        // Generic CRUD actions
        case models.ActionCreate:<span class="cov7" title="86">
                h.handleCreate(c, req)</span>
        case models.ActionModify:<span class="cov4" title="17">
                h.handleModify(c, req)</span>
        case models.ActionRemove:<span class="cov5" title="18">
                h.handleRemove(c, req)</span>
        case models.ActionRead:<span class="cov4" title="13">
                h.handleRead(c, req)</span>
        case models.ActionList:<span class="cov4" title="13">
                h.handleList(c, req)</span>

        // Priority actions
        case models.ActionPriorityCreate:<span class="cov4" title="16">
                h.handlePriorityCreate(c, req)</span>
        case models.ActionPriorityRead:<span class="cov2" title="4">
                h.handlePriorityRead(c, req)</span>
        case models.ActionPriorityList:<span class="cov2" title="3">
                h.handlePriorityList(c, req)</span>
        case models.ActionPriorityModify:<span class="cov3" title="7">
                h.handlePriorityModify(c, req)</span>
        case models.ActionPriorityRemove:<span class="cov3" title="5">
                h.handlePriorityRemove(c, req)</span>

        // Resolution actions
        case models.ActionResolutionCreate:<span class="cov4" title="12">
                h.handleResolutionCreate(c, req)</span>
        case models.ActionResolutionRead:<span class="cov2" title="4">
                h.handleResolutionRead(c, req)</span>
        case models.ActionResolutionList:<span class="cov2" title="3">
                h.handleResolutionList(c, req)</span>
        case models.ActionResolutionModify:<span class="cov3" title="6">
                h.handleResolutionModify(c, req)</span>
        case models.ActionResolutionRemove:<span class="cov3" title="5">
                h.handleResolutionRemove(c, req)</span>

        // Watcher actions
        case models.ActionWatcherAdd:<span class="cov4" title="15">
                h.handleWatcherAdd(c, req)</span>
        case models.ActionWatcherRemove:<span class="cov3" title="7">
                h.handleWatcherRemove(c, req)</span>
        case models.ActionWatcherList:<span class="cov3" title="8">
                h.handleWatcherList(c, req)</span>

        // Version actions
        case models.ActionVersionCreate:<span class="cov3" title="6">
                h.handleVersionCreate(c, req)</span>
        case models.ActionVersionRead:<span class="cov1" title="2">
                h.handleVersionRead(c, req)</span>
        case models.ActionVersionList:<span class="cov2" title="3">
                h.handleVersionList(c, req)</span>
        case models.ActionVersionModify:<span class="cov2" title="4">
                h.handleVersionModify(c, req)</span>
        case models.ActionVersionRemove:<span class="cov2" title="4">
                h.handleVersionRemove(c, req)</span>
        case models.ActionVersionRelease:<span class="cov2" title="4">
                h.handleVersionRelease(c, req)</span>
        case models.ActionVersionArchive:<span class="cov2" title="4">
                h.handleVersionArchive(c, req)</span>
        case models.ActionVersionAddAffected:<span class="cov1" title="1">
                h.handleVersionAddAffected(c, req)</span>
        case models.ActionVersionRemoveAffected:<span class="cov1" title="1">
                h.handleVersionRemoveAffected(c, req)</span>
        case models.ActionVersionListAffected:<span class="cov1" title="1">
                h.handleVersionListAffected(c, req)</span>
        case models.ActionVersionAddFix:<span class="cov1" title="1">
                h.handleVersionAddFix(c, req)</span>
        case models.ActionVersionRemoveFix:<span class="cov1" title="1">
                h.handleVersionRemoveFix(c, req)</span>
        case models.ActionVersionListFix:<span class="cov1" title="1">
                h.handleVersionListFix(c, req)</span>

        // Filter actions
        case models.ActionFilterSave:<span class="cov4" title="13">
                h.handleFilterSave(c, req)</span>
        case models.ActionFilterLoad:<span class="cov3" title="7">
                h.handleFilterLoad(c, req)</span>
        case models.ActionFilterList:<span class="cov3" title="5">
                h.handleFilterList(c, req)</span>
        case models.ActionFilterShare:<span class="cov3" title="8">
                h.handleFilterShare(c, req)</span>
        case models.ActionFilterModify:<span class="cov3" title="6">
                h.handleFilterModify(c, req)</span>
        case models.ActionFilterRemove:<span class="cov3" title="6">
                h.handleFilterRemove(c, req)</span>

        // Custom field actions
        case models.ActionCustomFieldCreate:<span class="cov5" title="18">
                h.handleCustomFieldCreate(c, req)</span>
        case models.ActionCustomFieldRead:<span class="cov1" title="2">
                h.handleCustomFieldRead(c, req)</span>
        case models.ActionCustomFieldList:<span class="cov2" title="3">
                h.handleCustomFieldList(c, req)</span>
        case models.ActionCustomFieldModify:<span class="cov2" title="4">
                h.handleCustomFieldModify(c, req)</span>
        case models.ActionCustomFieldRemove:<span class="cov2" title="4">
                h.handleCustomFieldRemove(c, req)</span>

        // Custom field option actions
        case models.ActionCustomFieldOptionCreate:<span class="cov3" title="5">
                h.handleCustomFieldOptionCreate(c, req)</span>
        case models.ActionCustomFieldOptionModify:<span class="cov1" title="1">
                h.handleCustomFieldOptionModify(c, req)</span>
        case models.ActionCustomFieldOptionRemove:<span class="cov1" title="1">
                h.handleCustomFieldOptionRemove(c, req)</span>
        case models.ActionCustomFieldOptionList:<span class="cov1" title="2">
                h.handleCustomFieldOptionList(c, req)</span>

        // Custom field value actions
        case models.ActionCustomFieldValueSet:<span class="cov2" title="4">
                h.handleCustomFieldValueSet(c, req)</span>
        case models.ActionCustomFieldValueGet:<span class="cov2" title="3">
                h.handleCustomFieldValueGet(c, req)</span>
        case models.ActionCustomFieldValueList:<span class="cov1" title="1">
                h.handleCustomFieldValueList(c, req)</span>
        case models.ActionCustomFieldValueRemove:<span class="cov1" title="2">
                h.handleCustomFieldValueRemove(c, req)</span>

        // Board actions
        case models.ActionBoardCreate:<span class="cov4" title="13">
                h.handleBoardCreate(c, req)</span>
        case models.ActionBoardRead:<span class="cov3" title="5">
                h.handleBoardRead(c, req)</span>
        case models.ActionBoardList:<span class="cov2" title="3">
                h.handleBoardList(c, req)</span>
        case models.ActionBoardModify:<span class="cov2" title="4">
                h.handleBoardModify(c, req)</span>
        case models.ActionBoardRemove:<span class="cov2" title="4">
                h.handleBoardRemove(c, req)</span>

        // Board ticket assignment
        case models.ActionBoardAddTicket:<span class="cov0" title="0">
                h.handleBoardAddTicket(c, req)</span>
        case models.ActionBoardRemoveTicket:<span class="cov0" title="0">
                h.handleBoardRemoveTicket(c, req)</span>
        case models.ActionBoardListTickets:<span class="cov0" title="0">
                h.handleBoardListTickets(c, req)</span>

        // Board metadata
        case models.ActionBoardSetMetadata:<span class="cov0" title="0">
                h.handleBoardSetMetadata(c, req)</span>
        case models.ActionBoardGetMetadata:<span class="cov0" title="0">
                h.handleBoardGetMetadata(c, req)</span>
        case models.ActionBoardListMetadata:<span class="cov0" title="0">
                h.handleBoardListMetadata(c, req)</span>
        case models.ActionBoardRemoveMetadata:<span class="cov0" title="0">
                h.handleBoardRemoveMetadata(c, req)</span>

        // Cycle actions
        case models.ActionCycleCreate:<span class="cov4" title="9">
                h.handleCycleCreate(c, req)</span>
        case models.ActionCycleRead:<span class="cov2" title="4">
                h.handleCycleRead(c, req)</span>
        case models.ActionCycleList:<span class="cov2" title="3">
                h.handleCycleList(c, req)</span>
        case models.ActionCycleModify:<span class="cov2" title="3">
                h.handleCycleModify(c, req)</span>
        case models.ActionCycleRemove:<span class="cov2" title="3">
                h.handleCycleRemove(c, req)</span>

        // Cycle-project mapping
        case models.ActionCycleAssignProject:<span class="cov1" title="2">
                h.handleCycleAssignProject(c, req)</span>
        case models.ActionCycleUnassignProject:<span class="cov1" title="1">
                h.handleCycleUnassignProject(c, req)</span>
        case models.ActionCycleListProjects:<span class="cov1" title="1">
                h.handleCycleListProjects(c, req)</span>

        // Cycle-ticket mapping
        case models.ActionCycleAddTicket:<span class="cov1" title="1">
                h.handleCycleAddTicket(c, req)</span>
        case models.ActionCycleRemoveTicket:<span class="cov1" title="1">
                h.handleCycleRemoveTicket(c, req)</span>
        case models.ActionCycleListTickets:<span class="cov1" title="1">
                h.handleCycleListTickets(c, req)</span>

        // Workflow actions
        case models.ActionWorkflowCreate:<span class="cov4" title="15">
                h.handleWorkflowCreate(c, req)</span>
        case models.ActionWorkflowRead:<span class="cov2" title="4">
                h.handleWorkflowRead(c, req)</span>
        case models.ActionWorkflowList:<span class="cov2" title="4">
                h.handleWorkflowList(c, req)</span>
        case models.ActionWorkflowModify:<span class="cov3" title="5">
                h.handleWorkflowModify(c, req)</span>
        case models.ActionWorkflowRemove:<span class="cov2" title="4">
                h.handleWorkflowRemove(c, req)</span>

        // Workflow step actions
        case models.ActionWorkflowStepCreate:<span class="cov4" title="9">
                h.handleWorkflowStepCreate(c, req)</span>
        case models.ActionWorkflowStepRead:<span class="cov2" title="4">
                h.handleWorkflowStepRead(c, req)</span>
        case models.ActionWorkflowStepList:<span class="cov2" title="4">
                h.handleWorkflowStepList(c, req)</span>
        case models.ActionWorkflowStepModify:<span class="cov3" title="5">
                h.handleWorkflowStepModify(c, req)</span>
        case models.ActionWorkflowStepRemove:<span class="cov2" title="3">
                h.handleWorkflowStepRemove(c, req)</span>

        // Ticket status actions
        case models.ActionTicketStatusCreate:<span class="cov4" title="10">
                h.handleTicketStatusCreate(c, req)</span>
        case models.ActionTicketStatusRead:<span class="cov3" title="5">
                h.handleTicketStatusRead(c, req)</span>
        case models.ActionTicketStatusList:<span class="cov2" title="4">
                h.handleTicketStatusList(c, req)</span>
        case models.ActionTicketStatusModify:<span class="cov3" title="5">
                h.handleTicketStatusModify(c, req)</span>
        case models.ActionTicketStatusRemove:<span class="cov2" title="3">
                h.handleTicketStatusRemove(c, req)</span>

        // Ticket type actions
        case models.ActionTicketTypeCreate:<span class="cov4" title="9">
                h.handleTicketTypeCreate(c, req)</span>
        case models.ActionTicketTypeRead:<span class="cov2" title="4">
                h.handleTicketTypeRead(c, req)</span>
        case models.ActionTicketTypeList:<span class="cov2" title="3">
                h.handleTicketTypeList(c, req)</span>
        case models.ActionTicketTypeModify:<span class="cov2" title="4">
                h.handleTicketTypeModify(c, req)</span>
        case models.ActionTicketTypeRemove:<span class="cov2" title="3">
                h.handleTicketTypeRemove(c, req)</span>
        case models.ActionTicketTypeAssign:<span class="cov1" title="2">
                h.handleTicketTypeAssign(c, req)</span>
        case models.ActionTicketTypeUnassign:<span class="cov1" title="2">
                h.handleTicketTypeUnassign(c, req)</span>
        case models.ActionTicketTypeListByProject:<span class="cov1" title="2">
                h.handleTicketTypeListByProject(c, req)</span>

        // Account actions (Multi-tenancy support)
        case models.ActionAccountCreate:<span class="cov0" title="0">
                h.AccountCreate(c, req)</span>
        case models.ActionAccountRead:<span class="cov0" title="0">
                h.AccountRead(c, req)</span>
        case models.ActionAccountList:<span class="cov0" title="0">
                h.AccountList(c, req)</span>
        case models.ActionAccountModify:<span class="cov0" title="0">
                h.AccountModify(c, req)</span>
        case models.ActionAccountRemove:<span class="cov0" title="0">
                h.AccountRemove(c, req)</span>

        // Organization actions
        case models.ActionOrganizationCreate:<span class="cov0" title="0">
                h.OrganizationCreate(c, req)</span>
        case models.ActionOrganizationRead:<span class="cov0" title="0">
                h.OrganizationRead(c, req)</span>
        case models.ActionOrganizationList:<span class="cov0" title="0">
                h.OrganizationList(c, req)</span>
        case models.ActionOrganizationModify:<span class="cov0" title="0">
                h.OrganizationModify(c, req)</span>
        case models.ActionOrganizationRemove:<span class="cov0" title="0">
                h.OrganizationRemove(c, req)</span>
        case models.ActionOrganizationAssignAccount:<span class="cov0" title="0">
                h.OrganizationAssignAccount(c, req)</span>
        case models.ActionOrganizationListAccounts:<span class="cov0" title="0">
                h.OrganizationListAccounts(c, req)</span>

        // Team actions
        case models.ActionTeamCreate:<span class="cov0" title="0">
                h.TeamCreate(c, req)</span>
        case models.ActionTeamRead:<span class="cov0" title="0">
                h.TeamRead(c, req)</span>
        case models.ActionTeamList:<span class="cov0" title="0">
                h.TeamList(c, req)</span>
        case models.ActionTeamModify:<span class="cov0" title="0">
                h.TeamModify(c, req)</span>
        case models.ActionTeamRemove:<span class="cov0" title="0">
                h.TeamRemove(c, req)</span>
        case models.ActionTeamAssignOrganization:<span class="cov0" title="0">
                h.TeamAssignOrganization(c, req)</span>
        case models.ActionTeamUnassignOrganization:<span class="cov0" title="0">
                h.TeamUnassignOrganization(c, req)</span>
        case models.ActionTeamListOrganizations:<span class="cov0" title="0">
                h.TeamListOrganizations(c, req)</span>
        case models.ActionTeamAssignProject:<span class="cov0" title="0">
                h.TeamAssignProject(c, req)</span>
        case models.ActionTeamUnassignProject:<span class="cov0" title="0">
                h.TeamUnassignProject(c, req)</span>
        case models.ActionTeamListProjects:<span class="cov0" title="0">
                h.TeamListProjects(c, req)</span>

        // User-Organization mapping
        case models.ActionUserAssignOrganization:<span class="cov0" title="0">
                h.UserAssignOrganization(c, req)</span>
        case models.ActionUserListOrganizations:<span class="cov0" title="0">
                h.UserListOrganizations(c, req)</span>
        case models.ActionOrganizationListUsers:<span class="cov0" title="0">
                h.OrganizationListUsers(c, req)</span>

        // User-Team mapping
        case models.ActionUserAssignTeam:<span class="cov0" title="0">
                h.UserAssignTeam(c, req)</span>
        case models.ActionUserListTeams:<span class="cov0" title="0">
                h.UserListTeams(c, req)</span>
        case models.ActionTeamListUsers:<span class="cov0" title="0">
                h.TeamListUsers(c, req)</span>

        // Component actions
        case models.ActionComponentCreate:<span class="cov4" title="9">
                h.handleComponentCreate(c, req)</span>
        case models.ActionComponentRead:<span class="cov3" title="5">
                h.handleComponentRead(c, req)</span>
        case models.ActionComponentList:<span class="cov2" title="4">
                h.handleComponentList(c, req)</span>
        case models.ActionComponentModify:<span class="cov3" title="5">
                h.handleComponentModify(c, req)</span>
        case models.ActionComponentRemove:<span class="cov2" title="3">
                h.handleComponentRemove(c, req)</span>

        // Component-ticket mapping
        case models.ActionComponentAddTicket:<span class="cov2" title="3">
                h.handleComponentAddTicket(c, req)</span>
        case models.ActionComponentRemoveTicket:<span class="cov1" title="2">
                h.handleComponentRemoveTicket(c, req)</span>
        case models.ActionComponentListTickets:<span class="cov1" title="2">
                h.handleComponentListTickets(c, req)</span>

        // Component metadata
        case models.ActionComponentSetMetadata:<span class="cov2" title="3">
                h.handleComponentSetMetadata(c, req)</span>
        case models.ActionComponentGetMetadata:<span class="cov1" title="2">
                h.handleComponentGetMetadata(c, req)</span>
        case models.ActionComponentListMetadata:<span class="cov1" title="2">
                h.handleComponentListMetadata(c, req)</span>
        case models.ActionComponentRemoveMetadata:<span class="cov1" title="2">
                h.handleComponentRemoveMetadata(c, req)</span>

        // Label actions
        case models.ActionLabelCreate:<span class="cov4" title="9">
                h.handleLabelCreate(c, req)</span>
        case models.ActionLabelRead:<span class="cov3" title="5">
                h.handleLabelRead(c, req)</span>
        case models.ActionLabelList:<span class="cov2" title="4">
                h.handleLabelList(c, req)</span>
        case models.ActionLabelModify:<span class="cov3" title="5">
                h.handleLabelModify(c, req)</span>
        case models.ActionLabelRemove:<span class="cov2" title="3">
                h.handleLabelRemove(c, req)</span>

        // Label category actions
        case models.ActionLabelCategoryCreate:<span class="cov2" title="3">
                h.handleLabelCategoryCreate(c, req)</span>
        case models.ActionLabelCategoryRead:<span class="cov1" title="1">
                h.handleLabelCategoryRead(c, req)</span>
        case models.ActionLabelCategoryList:<span class="cov1" title="1">
                h.handleLabelCategoryList(c, req)</span>
        case models.ActionLabelCategoryModify:<span class="cov1" title="1">
                h.handleLabelCategoryModify(c, req)</span>
        case models.ActionLabelCategoryRemove:<span class="cov1" title="1">
                h.handleLabelCategoryRemove(c, req)</span>

        // Label-ticket mapping
        case models.ActionLabelAddTicket:<span class="cov2" title="3">
                h.handleLabelAddTicket(c, req)</span>
        case models.ActionLabelRemoveTicket:<span class="cov1" title="2">
                h.handleLabelRemoveTicket(c, req)</span>
        case models.ActionLabelListTickets:<span class="cov1" title="2">
                h.handleLabelListTickets(c, req)</span>

        // Label-category mapping
        case models.ActionLabelAssignCategory:<span class="cov2" title="3">
                h.handleLabelAssignCategory(c, req)</span>
        case models.ActionLabelUnassignCategory:<span class="cov1" title="2">
                h.handleLabelUnassignCategory(c, req)</span>
        case models.ActionLabelListCategories:<span class="cov1" title="2">
                h.handleLabelListCategories(c, req)</span>

        // Asset actions
        case models.ActionAssetCreate:<span class="cov0" title="0">
                h.handleAssetCreate(c, req)</span>
        case models.ActionAssetRead:<span class="cov0" title="0">
                h.handleAssetRead(c, req)</span>
        case models.ActionAssetList:<span class="cov0" title="0">
                h.handleAssetList(c, req)</span>
        case models.ActionAssetModify:<span class="cov0" title="0">
                h.handleAssetModify(c, req)</span>
        case models.ActionAssetRemove:<span class="cov0" title="0">
                h.handleAssetRemove(c, req)</span>

        // Asset-ticket mapping
        case models.ActionAssetAddTicket:<span class="cov0" title="0">
                h.handleAssetAddTicket(c, req)</span>
        case models.ActionAssetRemoveTicket:<span class="cov0" title="0">
                h.handleAssetRemoveTicket(c, req)</span>
        case models.ActionAssetListTickets:<span class="cov0" title="0">
                h.handleAssetListTickets(c, req)</span>

        // Asset-comment mapping
        case models.ActionAssetAddComment:<span class="cov0" title="0">
                h.handleAssetAddComment(c, req)</span>
        case models.ActionAssetRemoveComment:<span class="cov0" title="0">
                h.handleAssetRemoveComment(c, req)</span>
        case models.ActionAssetListComments:<span class="cov0" title="0">
                h.handleAssetListComments(c, req)</span>

        // Asset-project mapping
        case models.ActionAssetAddProject:<span class="cov0" title="0">
                h.handleAssetAddProject(c, req)</span>
        case models.ActionAssetRemoveProject:<span class="cov0" title="0">
                h.handleAssetRemoveProject(c, req)</span>
        case models.ActionAssetListProjects:<span class="cov0" title="0">
                h.handleAssetListProjects(c, req)</span>

        // Repository actions
        case models.ActionRepositoryCreate:<span class="cov0" title="0">
                h.handleRepositoryCreate(c, req)</span>
        case models.ActionRepositoryRead:<span class="cov0" title="0">
                h.handleRepositoryRead(c, req)</span>
        case models.ActionRepositoryList:<span class="cov0" title="0">
                h.handleRepositoryList(c, req)</span>
        case models.ActionRepositoryModify:<span class="cov0" title="0">
                h.handleRepositoryModify(c, req)</span>
        case models.ActionRepositoryRemove:<span class="cov0" title="0">
                h.handleRepositoryRemove(c, req)</span>

        // Repository type actions
        case models.ActionRepositoryTypeCreate:<span class="cov0" title="0">
                h.handleRepositoryTypeCreate(c, req)</span>
        case models.ActionRepositoryTypeRead:<span class="cov0" title="0">
                h.handleRepositoryTypeRead(c, req)</span>
        case models.ActionRepositoryTypeList:<span class="cov0" title="0">
                h.handleRepositoryTypeList(c, req)</span>
        case models.ActionRepositoryTypeModify:<span class="cov0" title="0">
                h.handleRepositoryTypeModify(c, req)</span>
        case models.ActionRepositoryTypeRemove:<span class="cov0" title="0">
                h.handleRepositoryTypeRemove(c, req)</span>

        // Repository-project mapping
        case models.ActionRepositoryAssignProject:<span class="cov0" title="0">
                h.handleRepositoryAssignProject(c, req)</span>
        case models.ActionRepositoryUnassignProject:<span class="cov0" title="0">
                h.handleRepositoryUnassignProject(c, req)</span>
        case models.ActionRepositoryListProjects:<span class="cov0" title="0">
                h.handleRepositoryListProjects(c, req)</span>

        // Repository-commit-ticket mapping
        case models.ActionRepositoryAddCommit:<span class="cov0" title="0">
                h.handleRepositoryAddCommit(c, req)</span>
        case models.ActionRepositoryRemoveCommit:<span class="cov0" title="0">
                h.handleRepositoryRemoveCommit(c, req)</span>
        case models.ActionRepositoryListCommits:<span class="cov0" title="0">
                h.handleRepositoryListCommits(c, req)</span>
        case models.ActionRepositoryGetCommit:<span class="cov0" title="0">
                h.handleRepositoryGetCommit(c, req)</span>

        // Ticket relationship type actions
        case models.ActionTicketRelationshipTypeCreate:<span class="cov0" title="0">
                h.handleTicketRelationshipTypeCreate(c, req)</span>
        case models.ActionTicketRelationshipTypeRead:<span class="cov0" title="0">
                h.handleTicketRelationshipTypeRead(c, req)</span>
        case models.ActionTicketRelationshipTypeList:<span class="cov0" title="0">
                h.handleTicketRelationshipTypeList(c, req)</span>
        case models.ActionTicketRelationshipTypeModify:<span class="cov0" title="0">
                h.handleTicketRelationshipTypeModify(c, req)</span>
        case models.ActionTicketRelationshipTypeRemove:<span class="cov0" title="0">
                h.handleTicketRelationshipTypeRemove(c, req)</span>

        // Ticket relationship actions
        case models.ActionTicketRelationshipCreate:<span class="cov0" title="0">
                h.handleTicketRelationshipCreate(c, req)</span>
        case models.ActionTicketRelationshipRemove:<span class="cov0" title="0">
                h.handleTicketRelationshipRemove(c, req)</span>
        case models.ActionTicketRelationshipList:<span class="cov0" title="0">
                h.handleTicketRelationshipList(c, req)</span>

        default:<span class="cov1" title="1">
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidAction,
                        "Unknown action: "+req.Action,
                        "",
                ))</span>
        }
}

// handleVersion returns the API version
func (h *Handler) handleVersion(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        response := models.NewSuccessResponse(map[string]interface{}{
                "version": h.version,
                "api":     "1.0.0",
        })
        c.JSON(http.StatusOK, response)
}</span>

// handleJWTCapable returns whether JWT authentication is available
func (h *Handler) handleJWTCapable(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        capable := h.authService != nil &amp;&amp; h.authService.IsEnabled()
        response := models.NewSuccessResponse(map[string]interface{}{
                "jwtCapable": capable,
                "enabled":    capable,
        })
        c.JSON(http.StatusOK, response)
}</span>

// handleDBCapable returns whether database is available
func (h *Handler) handleDBCapable(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        capable := h.db != nil
        dbType := ""
        if h.db != nil </span><span class="cov1" title="1">{
                dbType = h.db.GetType()
                // Try to ping the database
                if err := h.db.Ping(c.Request.Context()); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Database ping failed", zap.Error(err))
                        capable = false
                }</span>
        }

        <span class="cov1" title="1">response := models.NewSuccessResponse(map[string]interface{}{
                "dbCapable": capable,
                "type":      dbType,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleHealth returns the health status of the service
func (h *Handler) handleHealth(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        healthy := true
        checks := make(map[string]interface{})

        // Check database
        if h.db != nil </span><span class="cov1" title="1">{
                if err := h.db.Ping(c.Request.Context()); err != nil </span><span class="cov0" title="0">{
                        checks["database"] = "unhealthy"
                        healthy = false
                }</span> else<span class="cov1" title="1"> {
                        checks["database"] = "healthy"
                }</span>
        }

        // Check auth service
        <span class="cov1" title="1">if h.authService != nil &amp;&amp; h.authService.IsEnabled() </span><span class="cov1" title="1">{
                checks["authService"] = "enabled"
        }</span> else<span class="cov0" title="0"> {
                checks["authService"] = "disabled"
        }</span>

        // Check permission service
        <span class="cov1" title="1">if h.permService != nil &amp;&amp; h.permService.IsEnabled() </span><span class="cov1" title="1">{
                checks["permissionService"] = "enabled"
        }</span> else<span class="cov0" title="0"> {
                checks["permissionService"] = "disabled"
        }</span>

        <span class="cov1" title="1">status := "healthy"
        if !healthy </span><span class="cov0" title="0">{
                status = "unhealthy"
        }</span>

        <span class="cov1" title="1">response := models.NewSuccessResponse(map[string]interface{}{
                "status": status,
                "checks": checks,
        })

        statusCode := http.StatusOK
        if !healthy </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
                response.ErrorCode = models.ErrorCodeServiceUnavailable
                response.ErrorMessage = "Service is unhealthy"
        }</span>

        <span class="cov1" title="1">c.JSON(statusCode, response)</span>
}

// handleAuthenticate handles authentication requests
func (h *Handler) handleAuthenticate(c *gin.Context, req *models.Request) <span class="cov2" title="4">{
        username, ok := req.Data["username"].(string)
        if !ok || username == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing username",
                        "",
                ))
                return
        }</span>

        <span class="cov2" title="3">password, ok := req.Data["password"].(string)
        if !ok || password == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing password",
                        "",
                ))
                return
        }</span>

        // Try external auth service first if enabled
        <span class="cov1" title="2">if h.authService != nil &amp;&amp; h.authService.IsEnabled() </span><span class="cov1" title="2">{
                claims, err := h.authService.Authenticate(c.Request.Context(), username, password)
                if err != nil </span><span class="cov1" title="1">{
                        logger.Error("Authentication failed", zap.Error(err), zap.String("username", username))
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "Authentication failed",
                                "",
                        ))
                        return
                }</span>

                <span class="cov1" title="1">response := models.NewSuccessResponse(map[string]interface{}{
                        "username": claims.Username,
                        "role":     claims.Role,
                        "name":     claims.Name,
                })
                c.JSON(http.StatusOK, response)
                return</span>
        }

        // Fall back to local authentication (for testing)
        // Get user from database
        <span class="cov0" title="0">query := `
                SELECT id, username, password_hash, email, name, role, created_at, updated_at
                FROM users
                WHERE username = ? AND deleted = 0
        `

        var user models.User
        var createdAt, updatedAt int64

        err := h.db.QueryRow(context.Background(), query, username).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.PasswordHash,
                &amp;user.Email,
                &amp;user.Name,
                &amp;user.Role,
                &amp;createdAt,
                &amp;updatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("User not found", zap.Error(err), zap.String("username", username))
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid username or password",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">user.CreatedAt = time.Unix(createdAt, 0)
        user.UpdatedAt = time.Unix(updatedAt, 0)

        // Verify password
        err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid password", zap.String("username", username))
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid username or password",
                        "",
                ))
                return
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">jwtService := services.NewJWTService("", "", 24)
        token, err := jwtService.GenerateToken(user.Username, user.Email, user.Name, user.Role)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to generate JWT token", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to generate authentication token",
                        "",
                ))
                return
        }</span>

        // Return success response with token
        <span class="cov0" title="0">response := models.NewSuccessResponse(map[string]interface{}{
                "token":    token,
                "username": user.Username,
                "email":    user.Email,
                "name":     user.Name,
                "role":     user.Role,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleCreate handles create operations
func (h *Handler) handleCreate(c *gin.Context, req *models.Request) <span class="cov7" title="87">{
        if req.Object == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingObject,
                        "Missing object type",
                        "",
                ))
                return
        }</span>

        // Get username from middleware
        <span class="cov7" title="86">username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="85">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, req.Object, models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="85">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission - forbidden",
                        "",
                ))
                return
        }</span>

        // Route to specific handler based on object type
        <span class="cov7" title="85">switch req.Object </span>{
        case "project":<span class="cov5" title="20">
                h.handleCreateProject(c, req)</span>
        case "ticket":<span class="cov6" title="47">
                h.handleCreateTicket(c, req)</span>
        case "comment":<span class="cov5" title="18">
                h.handleCreateComment(c, req)</span>
        default:<span class="cov0" title="0">
                logger.Info("Create operation for unsupported object",
                        zap.String("object", req.Object),
                        zap.String("username", username),
                )
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidObject,
                        "Unsupported object type: "+req.Object,
                        "",
                ))</span>
        }
}

// handleModify handles modify operations
func (h *Handler) handleModify(c *gin.Context, req *models.Request) <span class="cov5" title="20">{
        if req.Object == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingObject,
                        "Missing object type",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="19">username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="18">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, req.Object, models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="18">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission - forbidden",
                        "",
                ))
                return
        }</span>

        // Route to specific handler based on object type
        <span class="cov5" title="18">switch req.Object </span>{
        case "project":<span class="cov3" title="7">
                h.handleModifyProject(c, req)</span>
        case "ticket":<span class="cov3" title="6">
                h.handleModifyTicket(c, req)</span>
        case "comment":<span class="cov3" title="5">
                h.handleModifyComment(c, req)</span>
        default:<span class="cov0" title="0">
                logger.Info("Modify operation for unsupported object",
                        zap.String("object", req.Object),
                        zap.String("username", username),
                )
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidObject,
                        "Unsupported object type: "+req.Object,
                        "",
                ))</span>
        }
}

// handleRemove handles remove operations
func (h *Handler) handleRemove(c *gin.Context, req *models.Request) <span class="cov5" title="21">{
        if req.Object == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingObject,
                        "Missing object type",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="20">username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="19">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, req.Object, models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        // If permission service is disabled, check user role from JWT claims
        <span class="cov5" title="19">if !h.permService.IsEnabled() </span><span class="cov0" title="0">{
                if claims, exists := middleware.GetClaims(c); exists </span><span class="cov0" title="0">{
                        // Viewer role cannot delete
                        if username == "viewer" || claims.Role == "viewer" </span><span class="cov0" title="0">{
                                allowed = false
                        }</span>
                }
        }

        <span class="cov5" title="19">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission - forbidden",
                        "",
                ))
                return
        }</span>

        // Route to specific handler based on object type
        <span class="cov5" title="19">switch req.Object </span>{
        case "project":<span class="cov3" title="7">
                h.handleRemoveProject(c, req)</span>
        case "ticket":<span class="cov3" title="6">
                h.handleRemoveTicket(c, req)</span>
        case "comment":<span class="cov3" title="6">
                h.handleRemoveComment(c, req)</span>
        default:<span class="cov0" title="0">
                logger.Info("Remove operation for unsupported object",
                        zap.String("object", req.Object),
                        zap.String("username", username),
                )
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidObject,
                        "Unsupported object type: "+req.Object,
                        "",
                ))</span>
        }
}

// handleRead handles read operations
func (h *Handler) handleRead(c *gin.Context, req *models.Request) <span class="cov4" title="15">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Route to specific handler based on object type
        <span class="cov4" title="14">switch req.Object </span>{
        case "project":<span class="cov3" title="5">
                h.handleReadProject(c, req)</span>
        case "ticket":<span class="cov2" title="4">
                h.handleReadTicket(c, req)</span>
        case "comment":<span class="cov3" title="5">
                h.handleReadComment(c, req)</span>
        default:<span class="cov0" title="0">
                logger.Info("Read operation for unsupported object",
                        zap.String("object", req.Object),
                        zap.String("username", username),
                )
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidObject,
                        "Unsupported object type: "+req.Object,
                        "",
                ))</span>
        }
}

// handleList handles list operations
func (h *Handler) handleList(c *gin.Context, req *models.Request) <span class="cov4" title="15">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Route to specific handler based on object type
        <span class="cov4" title="14">switch req.Object </span>{
        case "project":<span class="cov3" title="5">
                h.handleListProjects(c, req)</span>
        case "ticket":<span class="cov2" title="4">
                h.handleListTickets(c, req)</span>
        case "comment":<span class="cov3" title="5">
                h.handleListComments(c, req)</span>
        default:<span class="cov0" title="0">
                logger.Info("List operation for unsupported object",
                        zap.String("object", req.Object),
                        zap.String("username", username),
                )
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidObject,
                        "Unsupported object type: "+req.Object,
                        "",
                ))</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleLabelCreate creates a new label
func (h *Handler) handleLabelCreate(c *gin.Context, req *models.Request) <span class="cov10" title="9">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="9">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="9">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse label data from request
        <span class="cov10" title="9">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">label := &amp;models.Label{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Color:       getStringFromData(req.Data, "color"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO label (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                label.ID,
                label.Title,
                label.Description,
                label.Created,
                label.Modified,
                label.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create label", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create label",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">logger.Info("Label created",
                zap.String("label_id", label.ID),
                zap.String("title", label.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "label": label,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleLabelRead reads a single label by ID
func (h *Handler) handleLabelRead(c *gin.Context, req *models.Request) <span class="cov7" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get label ID from request
        <span class="cov7" title="5">labelID, ok := req.Data["id"].(string)
        if !ok || labelID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        // Query label from database
        <span class="cov7" title="5">query := `
                SELECT id, title, description, created, modified, deleted
                FROM label
                WHERE id = ? AND deleted = 0
        `

        var label models.Label
        err := h.db.QueryRow(c.Request.Context(), query, labelID).Scan(
                &amp;label.ID,
                &amp;label.Title,
                &amp;label.Description,
                &amp;label.Created,
                &amp;label.Modified,
                &amp;label.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label not found",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read label", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read label",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Label read",
                zap.String("label_id", label.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "label": label,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelList lists all labels
func (h *Handler) handleLabelList(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted labels ordered by title
        <span class="cov6" title="4">query := `
                SELECT id, title, description, created, modified, deleted
                FROM label
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list labels", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list labels",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="4">defer rows.Close()

        labels := make([]models.Label, 0)
        for rows.Next() </span><span class="cov8" title="7">{
                var label models.Label
                err := rows.Scan(
                        &amp;label.ID,
                        &amp;label.Title,
                        &amp;label.Description,
                        &amp;label.Created,
                        &amp;label.Modified,
                        &amp;label.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan label", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="7">labels = append(labels, label)</span>
        }

        <span class="cov6" title="4">logger.Info("Labels listed",
                zap.Int("count", len(labels)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "labels": labels,
                "count":  len(labels),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelModify updates an existing label
func (h *Handler) handleLabelModify(c *gin.Context, req *models.Request) <span class="cov7" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get label ID
        <span class="cov7" title="5">labelID, ok := req.Data["id"].(string)
        if !ok || labelID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        // Check if label exists
        <span class="cov7" title="5">checkQuery := `SELECT COUNT(*) FROM label WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, labelID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov6" title="4">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov5" title="3">{
                updates["title"] = title
        }</span>
        <span class="cov6" title="4">if description, ok := req.Data["description"].(string); ok </span><span class="cov3" title="2">{
                updates["description"] = description
        }</span>
        <span class="cov6" title="4">if color, ok := req.Data["color"].(string); ok </span><span class="cov1" title="1">{
                updates["color"] = color
        }</span>

        <span class="cov6" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov5" title="3">query := "UPDATE label SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov10" title="9">{
                if !first </span><span class="cov8" title="6">{
                        query += ", "
                }</span>
                <span class="cov10" title="9">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov5" title="3">query += " WHERE id = ?"
        args = append(args, labelID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update label", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update label",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Label updated",
                zap.String("label_id", labelID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      labelID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelRemove soft-deletes a label
func (h *Handler) handleLabelRemove(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get label ID
        <span class="cov5" title="3">labelID, ok := req.Data["id"].(string)
        if !ok || labelID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the label
        <span class="cov5" title="3">query := `UPDATE label SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), labelID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete label", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete label",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Label deleted",
                zap.String("label_id", labelID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      labelID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelCategoryCreate creates a new label category
func (h *Handler) handleLabelCategoryCreate(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse category data from request
        <span class="cov5" title="3">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">category := &amp;models.LabelCategory{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO label_category (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                category.ID,
                category.Title,
                category.Description,
                category.Created,
                category.Modified,
                category.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create label category", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create label category",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Label category created",
                zap.String("category_id", category.ID),
                zap.String("title", category.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "category": category,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleLabelCategoryRead reads a single label category by ID
func (h *Handler) handleLabelCategoryRead(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get category ID from request
        <span class="cov1" title="1">categoryID, ok := req.Data["id"].(string)
        if !ok || categoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing category ID",
                        "",
                ))
                return
        }</span>

        // Query category from database
        <span class="cov1" title="1">query := `
                SELECT id, title, description, created, modified, deleted
                FROM label_category
                WHERE id = ? AND deleted = 0
        `

        var category models.LabelCategory
        err := h.db.QueryRow(c.Request.Context(), query, categoryID).Scan(
                &amp;category.ID,
                &amp;category.Title,
                &amp;category.Description,
                &amp;category.Created,
                &amp;category.Modified,
                &amp;category.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label category not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read label category", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read label category",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Label category read",
                zap.String("category_id", category.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "category": category,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelCategoryList lists all label categories
func (h *Handler) handleLabelCategoryList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted categories ordered by title
        <span class="cov1" title="1">query := `
                SELECT id, title, description, created, modified, deleted
                FROM label_category
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list label categories", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list label categories",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        categories := make([]models.LabelCategory, 0)
        for rows.Next() </span><span class="cov5" title="3">{
                var category models.LabelCategory
                err := rows.Scan(
                        &amp;category.ID,
                        &amp;category.Title,
                        &amp;category.Description,
                        &amp;category.Created,
                        &amp;category.Modified,
                        &amp;category.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan label category", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="3">categories = append(categories, category)</span>
        }

        <span class="cov1" title="1">logger.Info("Label categories listed",
                zap.Int("count", len(categories)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "categories": categories,
                "count":      len(categories),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelCategoryModify updates an existing label category
func (h *Handler) handleLabelCategoryModify(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get category ID
        <span class="cov1" title="1">categoryID, ok := req.Data["id"].(string)
        if !ok || categoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing category ID",
                        "",
                ))
                return
        }</span>

        // Check if category exists
        <span class="cov1" title="1">checkQuery := `SELECT COUNT(*) FROM label_category WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, categoryID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label category not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov1" title="1">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov1" title="1">{
                updates["title"] = title
        }</span>
        <span class="cov1" title="1">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>

        <span class="cov1" title="1">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov1" title="1">query := "UPDATE label_category SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov5" title="3">{
                if !first </span><span class="cov3" title="2">{
                        query += ", "
                }</span>
                <span class="cov5" title="3">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov1" title="1">query += " WHERE id = ?"
        args = append(args, categoryID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update label category", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update label category",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Label category updated",
                zap.String("category_id", categoryID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      categoryID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelCategoryRemove soft-deletes a label category
func (h *Handler) handleLabelCategoryRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get category ID
        <span class="cov1" title="1">categoryID, ok := req.Data["id"].(string)
        if !ok || categoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing category ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the category
        <span class="cov1" title="1">query := `UPDATE label_category SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), categoryID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete label category", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete label category",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label category not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Label category deleted",
                zap.String("category_id", categoryID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      categoryID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelAddTicket adds a label to a ticket
func (h *Handler) handleLabelAddTicket(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get label ID and ticket ID
        <span class="cov5" title="3">labelID, ok := req.Data["labelId"].(string)
        if !ok || labelID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov3" title="2">mappingID := uuid.New().String()
        query := `
                INSERT INTO label_ticket_mapping (id, label_id, ticket_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        now := time.Now().Unix()
        _, err = h.db.Exec(c.Request.Context(), query, mappingID, labelID, ticketID, now, now, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add label to ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add label to ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Label added to ticket",
                zap.String("label_id", labelID),
                zap.String("ticket_id", ticketID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "added":    true,
                "labelId":  labelID,
                "ticketId": ticketID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelRemoveTicket removes a label from a ticket
func (h *Handler) handleLabelRemoveTicket(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get label ID and ticket ID
        <span class="cov3" title="2">labelID, ok := req.Data["labelId"].(string)
        if !ok || labelID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Remove mapping (soft delete)
        <span class="cov3" title="2">query := `UPDATE label_ticket_mapping SET deleted = 1, modified = ? WHERE label_id = ? AND ticket_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), labelID, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove label from ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove label from ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label-ticket mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Label removed from ticket",
                zap.String("label_id", labelID),
                zap.String("ticket_id", ticketID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed":  true,
                "labelId":  labelID,
                "ticketId": ticketID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelListTickets lists all tickets for a label
func (h *Handler) handleLabelListTickets(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get label ID
        <span class="cov3" title="2">labelID, ok := req.Data["labelId"].(string)
        if !ok || labelID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        // Query tickets
        <span class="cov3" title="2">query := `
                SELECT ticket_id
                FROM label_ticket_mapping
                WHERE label_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, labelID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list tickets for label", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list tickets",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        ticketIDs := make([]string, 0)
        for rows.Next() </span><span class="cov5" title="3">{
                var ticketID string
                if err := rows.Scan(&amp;ticketID); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket ID", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="3">ticketIDs = append(ticketIDs, ticketID)</span>
        }

        <span class="cov3" title="2">logger.Info("Tickets listed for label",
                zap.String("label_id", labelID),
                zap.Int("count", len(ticketIDs)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketIds": ticketIDs,
                "count":     len(ticketIDs),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelAssignCategory assigns a label to a category
func (h *Handler) handleLabelAssignCategory(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get label ID and category ID
        <span class="cov5" title="3">labelID, ok := req.Data["labelId"].(string)
        if !ok || labelID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">categoryID, ok := req.Data["categoryId"].(string)
        if !ok || categoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing category ID",
                        "",
                ))
                return
        }</span>

        // Create mapping
        <span class="cov3" title="2">mappingID := uuid.New().String()
        query := `
                INSERT INTO label_label_category_mapping (id, label_id, label_category_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        now := time.Now().Unix()
        _, err = h.db.Exec(c.Request.Context(), query, mappingID, labelID, categoryID, now, now, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to assign label to category", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to assign label to category",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Label assigned to category",
                zap.String("label_id", labelID),
                zap.String("category_id", categoryID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "assigned":   true,
                "labelId":    labelID,
                "categoryId": categoryID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelUnassignCategory unassigns a label from a category
func (h *Handler) handleLabelUnassignCategory(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "label", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get label ID and category ID
        <span class="cov3" title="2">labelID, ok := req.Data["labelId"].(string)
        if !ok || labelID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">categoryID, ok := req.Data["categoryId"].(string)
        if !ok || categoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing category ID",
                        "",
                ))
                return
        }</span>

        // Remove mapping (soft delete)
        <span class="cov3" title="2">query := `UPDATE label_label_category_mapping SET deleted = 1, modified = ? WHERE label_id = ? AND label_category_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), labelID, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unassign label from category", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to unassign label from category",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Label-category mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Label unassigned from category",
                zap.String("label_id", labelID),
                zap.String("category_id", categoryID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "unassigned": true,
                "labelId":    labelID,
                "categoryId": categoryID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleLabelListCategories lists all categories for a label
func (h *Handler) handleLabelListCategories(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get label ID
        <span class="cov3" title="2">labelID, ok := req.Data["labelId"].(string)
        if !ok || labelID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing label ID",
                        "",
                ))
                return
        }</span>

        // Query categories
        <span class="cov3" title="2">query := `
                SELECT label_category_id
                FROM label_label_category_mapping
                WHERE label_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, labelID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list categories for label", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list categories",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        categoryIDs := make([]string, 0)
        for rows.Next() </span><span class="cov5" title="3">{
                var categoryID string
                if err := rows.Scan(&amp;categoryID); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan category ID", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="3">categoryIDs = append(categoryIDs, categoryID)</span>
        }

        <span class="cov3" title="2">logger.Info("Categories listed for label",
                zap.String("label_id", labelID),
                zap.Int("count", len(categoryIDs)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "categoryIds": categoryIDs,
                "count":       len(categoryIDs),
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
        "go.uber.org/zap"
)

// OrganizationCreate handles creating a new organization
func (h *Handler) OrganizationCreate(c *gin.Context, req *models.Request) <span class="cov10" title="4">{
        // Parse the organization data from request
        var organization models.Organization
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal organization data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid organization data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="4">if err := json.Unmarshal(dataBytes, &amp;organization); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal organization data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid organization data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="4">if organization.Title == "" </span><span class="cov5" title="2">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Organization title is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov5" title="2">organization.ID = uuid.New().String()
        organization.Created = time.Now().Unix()
        organization.Modified = organization.Created
        organization.Deleted = false

        // TODO: Store organization in database
        // This will be implemented when database layer is updated
        logger.Info("Organization created", zap.String("id", organization.ID), zap.String("title", organization.Title))

        response := models.NewSuccessResponse(map[string]interface{}{"organization": organization})
        c.JSON(http.StatusOK, response)</span>
}

// OrganizationRead handles reading a single organization by ID
func (h *Handler) OrganizationRead(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        // Get organization ID from request data
        organizationID, ok := req.Data["id"].(string)
        if !ok || organizationID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Organization ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve organization from database
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Organization read requested", zap.String("id", organizationID))

        // For now, return a placeholder response
        response := models.NewErrorResponse(models.ErrorCodeInternalError, "Organization read not yet implemented", "")
        c.JSON(http.StatusNotImplemented, response)</span>
}

// OrganizationList handles listing all organizations
func (h *Handler) OrganizationList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // TODO: Retrieve organizations from database with pagination
        // This will be implemented when database layer is updated
        logger.Info("Organization list requested")

        // For now, return empty list
        organizations := []models.Organization{}
        response := models.NewSuccessResponse(map[string]interface{}{"organizations": organizations, "count": len(organizations)})
        c.JSON(http.StatusOK, response)
}</span>

// OrganizationModify handles updating an existing organization
func (h *Handler) OrganizationModify(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        // Parse the organization data from request
        var organization models.Organization
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal organization data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid organization data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov5" title="2">if err := json.Unmarshal(dataBytes, &amp;organization); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal organization data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid organization data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov5" title="2">if organization.ID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Organization ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Update timestamp
        <span class="cov1" title="1">organization.Modified = time.Now().Unix()

        // TODO: Update organization in database
        // This will be implemented when database layer is updated
        logger.Info("Organization modified", zap.String("id", organization.ID))

        response := models.NewSuccessResponse(map[string]interface{}{"organization": organization})
        c.JSON(http.StatusOK, response)</span>
}

// OrganizationRemove handles soft-deleting an organization
func (h *Handler) OrganizationRemove(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        // Get organization ID from request data
        organizationID, ok := req.Data["id"].(string)
        if !ok || organizationID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Organization ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Soft-delete organization in database (set deleted=true)
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Organization removed", zap.String("id", organizationID))

        response := models.NewSuccessResponse(map[string]interface{}{
                "id":      organizationID,
                "deleted": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// OrganizationAssignAccount handles assigning an organization to an account
func (h *Handler) OrganizationAssignAccount(c *gin.Context, req *models.Request) <span class="cov10" title="4">{
        // Parse the mapping data from request
        var mapping models.OrganizationAccountMapping
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="4">if err := json.Unmarshal(dataBytes, &amp;mapping); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="4">if mapping.OrganizationID == "" || mapping.AccountID == "" </span><span class="cov8" title="3">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Organization ID and Account ID are required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov1" title="1">mapping.ID = uuid.New().String()
        mapping.Created = time.Now().Unix()
        mapping.Modified = mapping.Created
        mapping.Deleted = false

        // TODO: Store mapping in database
        // This will be implemented when database layer is updated
        logger.Info("Organization assigned to account",
                zap.String("organizationId", mapping.OrganizationID),
                zap.String("accountId", mapping.AccountID))

        response := models.NewSuccessResponse(map[string]interface{}{"mapping": mapping})
        c.JSON(http.StatusOK, response)</span>
}

// OrganizationListAccounts handles listing all accounts for an organization
func (h *Handler) OrganizationListAccounts(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        // Get organization ID from request data
        organizationID, ok := req.Data["organizationId"].(string)
        if !ok || organizationID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Organization ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve accounts from database for this organization
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Organization accounts list requested", zap.String("organizationId", organizationID))

        // For now, return empty list
        accounts := []models.Account{}
        response := models.NewSuccessResponse(map[string]interface{}{"accounts": accounts, "count": len(accounts)})
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handlePermissionCreate creates a new permission
func (h *Handler) handlePermissionCreate(c *gin.Context, req *models.Request) <span class="cov10" title="8">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="8">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="8">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse permission data from request
        <span class="cov10" title="8">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="7">value, ok := req.Data["value"].(float64)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing value",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="7">permission := &amp;models.PermissionEntity{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Value:       int(value),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Validate permission value
        if !permission.IsValidPermissionValue() </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid permission value (must be 1=READ, 2=CREATE, 3=UPDATE, or 5=DELETE)",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov8" title="6">query := `
                INSERT INTO permission (id, title, description, value, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                permission.ID,
                permission.Title,
                permission.Description,
                permission.Value,
                permission.Created,
                permission.Modified,
                permission.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create permission", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create permission",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="6">logger.Info("Permission created",
                zap.String("permission_id", permission.ID),
                zap.String("title", permission.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "permission": permission,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handlePermissionRead reads a single permission by ID
func (h *Handler) handlePermissionRead(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get permission ID from request
        <span class="cov5" title="3">permissionID, ok := req.Data["id"].(string)
        if !ok || permissionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permission ID",
                        "",
                ))
                return
        }</span>

        // Query permission from database
        <span class="cov5" title="3">query := `
                SELECT id, title, description, value, created, modified, deleted
                FROM permission
                WHERE id = ? AND deleted = 0
        `

        var permission models.PermissionEntity
        err := h.db.QueryRow(c.Request.Context(), query, permissionID).Scan(
                &amp;permission.ID,
                &amp;permission.Title,
                &amp;permission.Description,
                &amp;permission.Value,
                &amp;permission.Created,
                &amp;permission.Modified,
                &amp;permission.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read permission", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read permission",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Permission read",
                zap.String("permission_id", permission.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "permission": permission,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionList lists all permissions
func (h *Handler) handlePermissionList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted permissions
        <span class="cov1" title="1">query := `
                SELECT id, title, description, value, created, modified, deleted
                FROM permission
                WHERE deleted = 0
                ORDER BY value ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list permissions", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list permissions",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        permissions := make([]models.PermissionEntity, 0)
        for rows.Next() </span><span class="cov4" title="2">{
                var permission models.PermissionEntity
                err := rows.Scan(
                        &amp;permission.ID,
                        &amp;permission.Title,
                        &amp;permission.Description,
                        &amp;permission.Value,
                        &amp;permission.Created,
                        &amp;permission.Modified,
                        &amp;permission.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan permission", zap.Error(err))
                        continue</span>
                }
                <span class="cov4" title="2">permissions = append(permissions, permission)</span>
        }

        <span class="cov1" title="1">logger.Info("Permissions listed",
                zap.Int("count", len(permissions)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "permissions": permissions,
                "count":       len(permissions),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionModify updates an existing permission
func (h *Handler) handlePermissionModify(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get permission ID
        <span class="cov5" title="3">permissionID, ok := req.Data["id"].(string)
        if !ok || permissionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permission ID",
                        "",
                ))
                return
        }</span>

        // Check if permission exists
        <span class="cov5" title="3">checkQuery := `SELECT COUNT(*) FROM permission WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, permissionID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov4" title="2">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov4" title="2">{
                updates["title"] = title
        }</span>
        <span class="cov4" title="2">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>
        <span class="cov4" title="2">if value, ok := req.Data["value"].(float64); ok </span><span class="cov0" title="0">{
                valueInt := int(value)
                // Validate permission value
                if models.PermissionLevel(valueInt) != models.PermissionRead &amp;&amp; models.PermissionLevel(valueInt) != models.PermissionCreate &amp;&amp;
                        models.PermissionLevel(valueInt) != models.PermissionUpdate &amp;&amp; models.PermissionLevel(valueInt) != models.PermissionDelete </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid permission value",
                                "",
                        ))
                        return
                }</span>
                <span class="cov0" title="0">updates["value"] = valueInt</span>
        }

        <span class="cov4" title="2">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov4" title="2">query := "UPDATE permission SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov7" title="5">{
                if !first </span><span class="cov5" title="3">{
                        query += ", "
                }</span>
                <span class="cov7" title="5">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov4" title="2">query += " WHERE id = ?"
        args = append(args, permissionID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update permission", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update permission",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Permission updated",
                zap.String("permission_id", permissionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      permissionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionRemove soft-deletes a permission
func (h *Handler) handlePermissionRemove(c *gin.Context, req *models.Request) <span class="cov4" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov4" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get permission ID
        <span class="cov4" title="2">permissionID, ok := req.Data["id"].(string)
        if !ok || permissionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permission ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the permission
        <span class="cov4" title="2">query := `UPDATE permission SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), permissionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete permission", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete permission",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Permission deleted",
                zap.String("permission_id", permissionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      permissionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionContextCreate creates a new permission context
func (h *Handler) handlePermissionContextCreate(c *gin.Context, req *models.Request) <span class="cov9" title="7">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov9" title="7">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="7">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse context data from request
        <span class="cov9" title="7">context, ok := req.Data["context"].(string)
        if !ok || context == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing context",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="7">permContext := &amp;models.PermissionContextEntity{
                ID:       uuid.New().String(),
                Context:  context,
                Created:  time.Now().Unix(),
                Modified: time.Now().Unix(),
                Deleted:  false,
        }

        // Validate context
        if !permContext.IsValidContext() </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid context (must be: node, account, organization, team, or project)",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov8" title="6">query := `
                INSERT INTO permission_context (id, context, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                permContext.ID,
                permContext.Context,
                permContext.Created,
                permContext.Modified,
                permContext.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create permission context", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create permission context",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="6">logger.Info("Permission context created",
                zap.String("context_id", permContext.ID),
                zap.String("context", permContext.Context),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "permissionContext": permContext,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handlePermissionContextRead reads a single permission context by ID
func (h *Handler) handlePermissionContextRead(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get context ID from request
        <span class="cov1" title="1">contextID, ok := req.Data["id"].(string)
        if !ok || contextID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing context ID",
                        "",
                ))
                return
        }</span>

        // Query context from database
        <span class="cov1" title="1">query := `
                SELECT id, context, created, modified, deleted
                FROM permission_context
                WHERE id = ? AND deleted = 0
        `

        var permContext models.PermissionContextEntity
        err := h.db.QueryRow(c.Request.Context(), query, contextID).Scan(
                &amp;permContext.ID,
                &amp;permContext.Context,
                &amp;permContext.Created,
                &amp;permContext.Modified,
                &amp;permContext.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission context not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read permission context", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read permission context",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission context read",
                zap.String("context_id", permContext.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "permissionContext": permContext,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionContextList lists all permission contexts
func (h *Handler) handlePermissionContextList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted contexts
        <span class="cov1" title="1">query := `
                SELECT id, context, created, modified, deleted
                FROM permission_context
                WHERE deleted = 0
                ORDER BY context ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list permission contexts", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list permission contexts",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        contexts := make([]models.PermissionContextEntity, 0)
        for rows.Next() </span><span class="cov4" title="2">{
                var permContext models.PermissionContextEntity
                err := rows.Scan(
                        &amp;permContext.ID,
                        &amp;permContext.Context,
                        &amp;permContext.Created,
                        &amp;permContext.Modified,
                        &amp;permContext.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan permission context", zap.Error(err))
                        continue</span>
                }
                <span class="cov4" title="2">contexts = append(contexts, permContext)</span>
        }

        <span class="cov1" title="1">logger.Info("Permission contexts listed",
                zap.Int("count", len(contexts)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "permissionContexts": contexts,
                "count":              len(contexts),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionContextModify updates an existing permission context
func (h *Handler) handlePermissionContextModify(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get context ID
        <span class="cov1" title="1">contextID, ok := req.Data["id"].(string)
        if !ok || contextID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing context ID",
                        "",
                ))
                return
        }</span>

        // Get new context value
        <span class="cov1" title="1">context, ok := req.Data["context"].(string)
        if !ok || context == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing context value",
                        "",
                ))
                return
        }</span>

        // Validate context
        <span class="cov1" title="1">validContexts := []string{"node", "account", "organization", "team", "project"}
        valid := false
        for _, ctx := range validContexts </span><span class="cov7" title="4">{
                if context == ctx </span><span class="cov1" title="1">{
                        valid = true
                        break</span>
                }
        }

        <span class="cov1" title="1">if !valid </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid context value",
                        "",
                ))
                return
        }</span>

        // Update context
        <span class="cov1" title="1">query := `UPDATE permission_context SET context = ?, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, context, time.Now().Unix(), contextID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update permission context", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update permission context",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission context not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission context updated",
                zap.String("context_id", contextID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      contextID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionContextRemove soft-deletes a permission context
func (h *Handler) handlePermissionContextRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get context ID
        <span class="cov1" title="1">contextID, ok := req.Data["id"].(string)
        if !ok || contextID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing context ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the context
        <span class="cov1" title="1">query := `UPDATE permission_context SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), contextID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete permission context", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete permission context",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission context not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission context deleted",
                zap.String("context_id", contextID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      contextID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionAssignUser assigns a permission to a user within a context
func (h *Handler) handlePermissionAssignUser(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse mapping data
        <span class="cov1" title="1">permissionID, ok := req.Data["permissionId"].(string)
        if !ok || permissionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permissionId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">userID, ok := req.Data["userId"].(string)
        if !ok || userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing userId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">contextID, ok := req.Data["permissionContextId"].(string)
        if !ok || contextID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permissionContextId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">mapping := &amp;models.PermissionUserMapping{
                ID:                  uuid.New().String(),
                PermissionID:        permissionID,
                UserID:              userID,
                PermissionContextID: contextID,
                Created:             time.Now().Unix(),
                Deleted:             false,
        }

        // Insert into database
        query := `
                INSERT INTO permission_user_mapping (id, permission_id, user_id, permission_context_id, created, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.PermissionID,
                mapping.UserID,
                mapping.PermissionContextID,
                mapping.Created,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to assign permission to user", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to assign permission to user",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission assigned to user",
                zap.String("mapping_id", mapping.ID),
                zap.String("permission_id", permissionID),
                zap.String("user_id", userID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handlePermissionUnassignUser removes a permission from a user
func (h *Handler) handlePermissionUnassignUser(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get mapping ID
        <span class="cov1" title="1">mappingID, ok := req.Data["id"].(string)
        if !ok || mappingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing mapping ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov1" title="1">query := `UPDATE permission_user_mapping SET deleted = 1 WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, mappingID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unassign permission from user", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to unassign permission from user",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission unassigned from user",
                zap.String("mapping_id", mappingID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      mappingID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionAssignTeam assigns a permission to a team within a context
func (h *Handler) handlePermissionAssignTeam(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse mapping data
        <span class="cov1" title="1">permissionID, ok := req.Data["permissionId"].(string)
        if !ok || permissionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permissionId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">teamID, ok := req.Data["teamId"].(string)
        if !ok || teamID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing teamId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">contextID, ok := req.Data["permissionContextId"].(string)
        if !ok || contextID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permissionContextId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">mapping := &amp;models.PermissionTeamMapping{
                ID:                  uuid.New().String(),
                PermissionID:        permissionID,
                TeamID:              teamID,
                PermissionContextID: contextID,
                Created:             time.Now().Unix(),
                Deleted:             false,
        }

        // Insert into database
        query := `
                INSERT INTO permission_team_mapping (id, permission_id, team_id, permission_context_id, created, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.PermissionID,
                mapping.TeamID,
                mapping.PermissionContextID,
                mapping.Created,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to assign permission to team", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to assign permission to team",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission assigned to team",
                zap.String("mapping_id", mapping.ID),
                zap.String("permission_id", permissionID),
                zap.String("team_id", teamID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handlePermissionUnassignTeam removes a permission from a team
func (h *Handler) handlePermissionUnassignTeam(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "permission", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get mapping ID
        <span class="cov1" title="1">mappingID, ok := req.Data["id"].(string)
        if !ok || mappingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing mapping ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov1" title="1">query := `UPDATE permission_team_mapping SET deleted = 1 WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, mappingID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unassign permission from team", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to unassign permission from team",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Permission mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission unassigned from team",
                zap.String("mapping_id", mappingID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      mappingID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePermissionCheck checks if a user has a specific permission
func (h *Handler) handlePermissionCheck(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get parameters
        <span class="cov7" title="4">targetUser, ok := req.Data["userId"].(string)
        if !ok || targetUser == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing userId",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">resource, ok := req.Data["resource"].(string)
        if !ok || resource == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing resource",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">permValue, ok := req.Data["permission"].(float64)
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing permission value",
                        "",
                ))
                return
        }</span>

        // Use permission service to check
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), targetUser, resource, models.PermissionLevel(permValue))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Permission checked",
                zap.String("target_user", targetUser),
                zap.String("resource", resource),
                zap.Int("permission", int(permValue)),
                zap.Bool("allowed", allowed),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "allowed": allowed,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handlePriorityCreate creates a new priority
func (h *Handler) handlePriorityCreate(c *gin.Context, req *models.Request) <span class="cov5" title="16">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="16">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "priority", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="16">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse priority data from request
        <span class="cov5" title="16">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="14">level, ok := req.Data["level"].(float64) // JSON numbers are float64
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing level",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="13">priority := &amp;models.Priority{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Level:       int(level),
                Icon:        getStringFromData(req.Data, "icon"),
                Color:       getStringFromData(req.Data, "color"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Validate priority level
        if !priority.IsValidLevel() </span><span class="cov3" title="4">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid priority level (must be 1-5)",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov4" title="9">query := `
                INSERT INTO priority (id, title, description, level, icon, color, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                priority.ID,
                priority.Title,
                priority.Description,
                priority.Level,
                priority.Icon,
                priority.Color,
                priority.Created,
                priority.Modified,
                priority.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create priority", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create priority",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="9">logger.Info("Priority created",
                zap.String("priority_id", priority.ID),
                zap.String("title", priority.Title),
                zap.String("username", username),
        )

        // Publish priority created event
        h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "priority",
                priority.ID,
                username,
                map[string]interface{}{
                        "id":          priority.ID,
                        "title":       priority.Title,
                        "description": priority.Description,
                        "level":       priority.Level,
                        "icon":        priority.Icon,
                        "color":       priority.Color,
                },
                websocket.NewProjectContext("", []string{"READ"}), // System-wide entity
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "priority": priority,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handlePriorityRead reads a single priority by ID
func (h *Handler) handlePriorityRead(c *gin.Context, req *models.Request) <span class="cov3" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get priority ID from request
        <span class="cov3" title="4">priorityID, ok := req.Data["id"].(string)
        if !ok || priorityID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing priority ID",
                        "",
                ))
                return
        }</span>

        // Query priority from database
        <span class="cov3" title="4">query := `
                SELECT id, title, description, level, icon, color, created, modified, deleted
                FROM priority
                WHERE id = ? AND deleted = 0
        `

        var priority models.Priority
        err := h.db.QueryRow(c.Request.Context(), query, priorityID).Scan(
                &amp;priority.ID,
                &amp;priority.Title,
                &amp;priority.Description,
                &amp;priority.Level,
                &amp;priority.Icon,
                &amp;priority.Color,
                &amp;priority.Created,
                &amp;priority.Modified,
                &amp;priority.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov2" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Priority not found",
                        "",
                ))
                return
        }</span>

        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read priority", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read priority",
                        "",
                ))
                return
        }</span>

        <span class="cov2" title="2">logger.Info("Priority read",
                zap.String("priority_id", priority.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "priority": priority,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePriorityList lists all priorities
func (h *Handler) handlePriorityList(c *gin.Context, req *models.Request) <span class="cov2" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted priorities ordered by level
        <span class="cov2" title="3">query := `
                SELECT id, title, description, level, icon, color, created, modified, deleted
                FROM priority
                WHERE deleted = 0
                ORDER BY level ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list priorities", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list priorities",
                        "",
                ))
                return
        }</span>
        <span class="cov2" title="3">defer rows.Close()

        priorities := make([]models.Priority, 0)
        for rows.Next() </span><span class="cov4" title="6">{
                var priority models.Priority
                err := rows.Scan(
                        &amp;priority.ID,
                        &amp;priority.Title,
                        &amp;priority.Description,
                        &amp;priority.Level,
                        &amp;priority.Icon,
                        &amp;priority.Color,
                        &amp;priority.Created,
                        &amp;priority.Modified,
                        &amp;priority.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan priority", zap.Error(err))
                        continue</span>
                }
                <span class="cov4" title="6">priorities = append(priorities, priority)</span>
        }

        <span class="cov2" title="3">logger.Info("Priorities listed",
                zap.Int("count", len(priorities)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "priorities": priorities,
                "count":      len(priorities),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePriorityModify updates an existing priority
func (h *Handler) handlePriorityModify(c *gin.Context, req *models.Request) <span class="cov4" title="7">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov4" title="7">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "priority", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="7">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get priority ID
        <span class="cov4" title="7">priorityID, ok := req.Data["id"].(string)
        if !ok || priorityID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing priority ID",
                        "",
                ))
                return
        }</span>

        // Check if priority exists
        <span class="cov4" title="7">checkQuery := `SELECT COUNT(*) FROM priority WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, priorityID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov2" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Priority not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov3" title="5">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov2" title="2">{
                updates["title"] = title
        }</span>
        <span class="cov3" title="5">if description, ok := req.Data["description"].(string); ok </span><span class="cov2" title="2">{
                updates["description"] = description
        }</span>
        <span class="cov3" title="5">if level, ok := req.Data["level"].(float64); ok </span><span class="cov3" title="5">{
                levelInt := int(level)
                if levelInt &lt; 1 || levelInt &gt; 5 </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid priority level (must be 1-5)",
                                "",
                        ))
                        return
                }</span>
                <span class="cov3" title="4">updates["level"] = levelInt</span>
        }
        <span class="cov3" title="4">if icon, ok := req.Data["icon"].(string); ok </span><span class="cov1" title="1">{
                updates["icon"] = icon
        }</span>
        <span class="cov3" title="4">if color, ok := req.Data["color"].(string); ok </span><span class="cov1" title="1">{
                updates["color"] = color
        }</span>

        <span class="cov3" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov3" title="4">query := "UPDATE priority SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov5" title="14">{
                if !first </span><span class="cov4" title="10">{
                        query += ", "
                }</span>
                <span class="cov5" title="14">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov3" title="4">query += " WHERE id = ?"
        args = append(args, priorityID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update priority", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update priority",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="4">logger.Info("Priority updated",
                zap.String("priority_id", priorityID),
                zap.String("username", username),
        )

        // Publish priority updated event
        h.publisher.PublishEntityEvent(
                models.ActionModify,
                "priority",
                priorityID,
                username,
                updates,
                websocket.NewProjectContext("", []string{"READ"}), // System-wide entity
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      priorityID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handlePriorityRemove soft-deletes a priority
func (h *Handler) handlePriorityRemove(c *gin.Context, req *models.Request) <span class="cov3" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "priority", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get priority ID
        <span class="cov3" title="5">priorityID, ok := req.Data["id"].(string)
        if !ok || priorityID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing priority ID",
                        "",
                ))
                return
        }</span>

        // Read priority data before deleting (for event publishing)
        <span class="cov3" title="5">readQuery := `SELECT id, title, description, level, icon, color FROM priority WHERE id = ? AND deleted = 0`
        var priority models.Priority
        err = h.db.QueryRow(c.Request.Context(), readQuery, priorityID).Scan(
                &amp;priority.ID,
                &amp;priority.Title,
                &amp;priority.Description,
                &amp;priority.Level,
                &amp;priority.Icon,
                &amp;priority.Color,
        )
        if err == sql.ErrNoRows </span><span class="cov2" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Priority not found",
                        "",
                ))
                return
        }</span>
        <span class="cov2" title="3">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read priority before deletion", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read priority",
                        "",
                ))
                return
        }</span>

        // Soft delete the priority
        <span class="cov2" title="3">query := `UPDATE priority SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), priorityID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete priority", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete priority",
                        "",
                ))
                return
        }</span>

        <span class="cov2" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Priority not found",
                        "",
                ))
                return
        }</span>

        <span class="cov2" title="3">logger.Info("Priority deleted",
                zap.String("priority_id", priorityID),
                zap.String("username", username),
        )

        // Publish priority deleted event with full data
        h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "priority",
                priorityID,
                username,
                map[string]interface{}{
                        "id":          priority.ID,
                        "title":       priority.Title,
                        "description": priority.Description,
                        "level":       priority.Level,
                        "icon":        priority.Icon,
                        "color":       priority.Color,
                },
                websocket.NewProjectContext("", []string{"READ"}), // System-wide entity
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      priorityID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// Helper function to safely get string from map
func getStringFromData(data map[string]interface{}, key string) string <span class="cov10" title="210">{
        if val, ok := data[key].(string); ok </span><span class="cov9" title="116">{
                return val
        }</span>
        <span class="cov8" title="94">return ""</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleCreateProject creates a new project
func (h *Handler) handleCreateProject(c *gin.Context, req *models.Request) <span class="cov9" title="20">{
        // Extract project data from request
        projectData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov9" title="20">{
                // Try direct data fields
                projectData = req.Data
        }</span>

        <span class="cov9" title="20">name, _ := projectData["name"].(string)
        if name == "" </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project name",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="18">key, _ := projectData["key"].(string)
        if key == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project key",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="17">description, _ := projectData["description"].(string)
        projectType, _ := projectData["type"].(string)
        if projectType == "" </span><span class="cov8" title="15">{
                projectType = "software"
        }</span>

        // Get default workflow ID
        <span class="cov8" title="17">var workflowID string
        err := h.db.QueryRow(context.Background(), "SELECT id FROM workflow LIMIT 1").Scan(&amp;workflowID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to get default workflow", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create project",
                        "",
                ))
                return
        }</span>

        // Create project
        <span class="cov8" title="16">projectID := uuid.New().String()
        now := time.Now().Unix()

        query := `
                INSERT INTO project (id, identifier, title, description, workflow_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(
                context.Background(),
                query,
                projectID,
                key,
                name,
                description,
                workflowID,
                now,
                now,
                0,
        )

        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to create project", zap.Error(err))
                c.JSON(http.StatusConflict, models.NewErrorResponse(
                        models.ErrorCodeEntityAlreadyExists,
                        "Project with this identifier already exists",
                        "",
                ))
                return
        }</span>

        // Get username from context
        <span class="cov8" title="15">username, _ := middleware.GetUsername(c)

        // Publish project created event
        h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "project",
                projectID,
                username,
                map[string]interface{}{
                        "id":          projectID,
                        "identifier":  key,
                        "title":       name,
                        "description": description,
                        "type":        projectType,
                },
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "project": map[string]interface{}{
                        "id":          projectID,
                        "identifier":  key,
                        "title":       name,
                        "description": description,
                        "type":        projectType,
                        "created":     now,
                        "modified":    now,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleModifyProject updates an existing project
func (h *Handler) handleModifyProject(c *gin.Context, req *models.Request) <span class="cov6" title="7">{
        projectData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov6" title="7">{
                projectData = req.Data
        }</span>

        <span class="cov6" title="7">projectID, _ := projectData["id"].(string)
        if projectID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project ID",
                        "",
                ))
                return
        }</span>

        // Check if project exists
        <span class="cov6" title="6">var exists int
        err := h.db.QueryRow(context.Background(),
                "SELECT COUNT(*) FROM project WHERE id = ? AND deleted = 0",
                projectID).Scan(&amp;exists)

        if err != nil || exists == 0 </span><span class="cov4" title="3">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Project not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically
        <span class="cov4" title="3">updates := []string{}
        args := []interface{}{}

        if title, ok := projectData["title"].(string); ok &amp;&amp; title != "" </span><span class="cov4" title="3">{
                updates = append(updates, "title = ?")
                args = append(args, title)
        }</span>

        <span class="cov4" title="3">if desc, ok := projectData["description"].(string); ok </span><span class="cov2" title="2">{
                updates = append(updates, "description = ?")
                args = append(args, desc)
        }</span>

        <span class="cov4" title="3">if identifier, ok := projectData["identifier"].(string); ok &amp;&amp; identifier != "" </span><span class="cov0" title="0">{
                updates = append(updates, "identifier = ?")
                args = append(args, identifier)
        }</span>

        // Always update modified timestamp
        <span class="cov4" title="3">updates = append(updates, "modified = ?")
        args = append(args, time.Now().Unix())

        // Add project ID to args
        args = append(args, projectID)

        query := fmt.Sprintf("UPDATE project SET %s WHERE id = ?",
                joinWithComma(updates))

        _, err = h.db.Exec(context.Background(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update project",
                        "",
                ))
                return
        }</span>

        // Get username from context
        <span class="cov4" title="3">username, _ := middleware.GetUsername(c)

        // Publish project updated event
        h.publisher.PublishEntityEvent(
                models.ActionModify,
                "project",
                projectID,
                username,
                projectData,
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "project": map[string]interface{}{
                        "id":      projectID,
                        "updated": true,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleRemoveProject soft-deletes a project
func (h *Handler) handleRemoveProject(c *gin.Context, req *models.Request) <span class="cov6" title="7">{
        projectData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov6" title="7">{
                projectData = req.Data
        }</span>

        <span class="cov6" title="7">projectID, _ := projectData["id"].(string)
        if projectID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project ID",
                        "",
                ))
                return
        }</span>

        // Check if project exists before deletion
        <span class="cov6" title="6">var exists int
        err := h.db.QueryRow(context.Background(),
                "SELECT COUNT(*) FROM project WHERE id = ? AND deleted = 0",
                projectID).Scan(&amp;exists)

        if err != nil || exists == 0 </span><span class="cov2" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Project not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="4">query := "UPDATE project SET deleted = 1, modified = ? WHERE id = ?"
        _, err = h.db.Exec(context.Background(), query, time.Now().Unix(), projectID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete project",
                        "",
                ))
                return
        }</span>

        // Get username from context
        <span class="cov4" title="4">username, _ := middleware.GetUsername(c)

        // Publish project deleted event
        h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "project",
                projectID,
                username,
                map[string]interface{}{
                        "id": projectID,
                },
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "project": map[string]interface{}{
                        "id":      projectID,
                        "deleted": true,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleReadProject retrieves a single project
func (h *Handler) handleReadProject(c *gin.Context, req *models.Request) <span class="cov5" title="5">{
        projectData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov5" title="5">{
                projectData = req.Data
        }</span>

        <span class="cov5" title="5">projectID, _ := projectData["id"].(string)
        if projectID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project ID",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="4">query := `
                SELECT id, identifier, title, description, workflow_id, created, modified
                FROM project
                WHERE id = ? AND deleted = 0
        `

        var id, identifier, title, description, workflowID string
        var created, modified int64

        err := h.db.QueryRow(context.Background(), query, projectID).Scan(
                &amp;id, &amp;identifier, &amp;title, &amp;description, &amp;workflowID, &amp;created, &amp;modified)

        if err != nil </span><span class="cov4" title="3">{
                logger.Error("Project not found", zap.Error(err))
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Project not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">response := models.NewSuccessResponse(map[string]interface{}{
                "project": map[string]interface{}{
                        "id":          id,
                        "identifier":  identifier,
                        "title":       title,
                        "description": description,
                        "workflowId":  workflowID,
                        "created":     created,
                        "modified":    modified,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleListProjects retrieves all projects
func (h *Handler) handleListProjects(c *gin.Context, req *models.Request) <span class="cov5" title="5">{
        query := `
                SELECT id, identifier, title, description, workflow_id, created, modified
                FROM project
                WHERE deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(context.Background(), query)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to list projects", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list projects",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="4">defer rows.Close()

        projects := []map[string]interface{}{}

        for rows.Next() </span><span class="cov6" title="6">{
                var id, identifier, title, description, workflowID string
                var created, modified int64

                err := rows.Scan(&amp;id, &amp;identifier, &amp;title, &amp;description, &amp;workflowID, &amp;created, &amp;modified)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan project", zap.Error(err))
                        continue</span>
                }

                <span class="cov6" title="6">projects = append(projects, map[string]interface{}{
                        "id":          id,
                        "identifier":  identifier,
                        "title":       title,
                        "description": description,
                        "workflowId":  workflowID,
                        "created":     created,
                        "modified":    modified,
                })</span>
        }

        <span class="cov4" title="4">response := models.NewSuccessResponse(map[string]interface{}{
                "items": projects,
                "total": len(projects),
        })

        c.JSON(http.StatusOK, response)</span>
}

// Helper function to join strings with comma
func joinWithComma(strs []string) string <span class="cov7" title="11">{
        result := ""
        for i, s := range strs </span><span class="cov10" title="25">{
                if i &gt; 0 </span><span class="cov8" title="15">{
                        result += ", "
                }</span>
                <span class="cov10" title="25">result += s</span>
        }
        <span class="cov7" title="11">return result</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleReportCreate creates a new report
func (h *Handler) handleReportCreate(c *gin.Context, req *models.Request) <span class="cov6" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov6" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "report", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse report data from request
        <span class="cov6" title="2">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        // Query can be a complex object, convert to JSON string
        <span class="cov1" title="1">var queryStr string
        if query, ok := req.Data["query"]; ok </span><span class="cov1" title="1">{
                queryBytes, err := json.Marshal(query)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid query format",
                                "",
                        ))
                        return
                }</span>
                <span class="cov1" title="1">queryStr = string(queryBytes)</span>
        }

        <span class="cov1" title="1">report := &amp;models.Report{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Query:       queryStr,
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Validate report
        if !report.IsValid() </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid report data",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov1" title="1">query := `
                INSERT INTO report (id, title, description, query, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                report.ID,
                report.Title,
                report.Description,
                report.Query,
                report.Created,
                report.Modified,
                report.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create report", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create report",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Report created",
                zap.String("report_id", report.ID),
                zap.String("title", report.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "report": report,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleReportRead reads a single report by ID
func (h *Handler) handleReportRead(c *gin.Context, req *models.Request) <span class="cov6" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get report ID from request
        <span class="cov6" title="2">reportID, ok := req.Data["id"].(string)
        if !ok || reportID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing report ID",
                        "",
                ))
                return
        }</span>

        // Query report from database
        <span class="cov6" title="2">query := `
                SELECT id, title, description, query, created, modified, deleted
                FROM report
                WHERE id = ? AND deleted = 0
        `

        var report models.Report
        err := h.db.QueryRow(c.Request.Context(), query, reportID).Scan(
                &amp;report.ID,
                &amp;report.Title,
                &amp;report.Description,
                &amp;report.Query,
                &amp;report.Created,
                &amp;report.Modified,
                &amp;report.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Report not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read report", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read report",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Report read",
                zap.String("report_id", report.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "report": report,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleReportList lists all reports
func (h *Handler) handleReportList(c *gin.Context, req *models.Request) <span class="cov6" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted reports
        <span class="cov6" title="2">query := `
                SELECT id, title, description, query, created, modified, deleted
                FROM report
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list reports", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list reports",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="2">defer rows.Close()

        reports := make([]models.Report, 0)
        for rows.Next() </span><span class="cov10" title="3">{
                var report models.Report
                var description sql.NullString
                err := rows.Scan(
                        &amp;report.ID,
                        &amp;report.Title,
                        &amp;description,
                        &amp;report.Query,
                        &amp;report.Created,
                        &amp;report.Modified,
                        &amp;report.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan report", zap.Error(err))
                        continue</span>
                }
                <span class="cov10" title="3">if description.Valid </span><span class="cov0" title="0">{
                        report.Description = description.String
                }</span>
                <span class="cov10" title="3">reports = append(reports, report)</span>
        }

        <span class="cov6" title="2">logger.Info("Reports listed",
                zap.Int("count", len(reports)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "reports": reports,
                "count":   len(reports),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleReportModify updates an existing report
func (h *Handler) handleReportModify(c *gin.Context, req *models.Request) <span class="cov6" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov6" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "report", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get report ID
        <span class="cov6" title="2">reportID, ok := req.Data["id"].(string)
        if !ok || reportID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing report ID",
                        "",
                ))
                return
        }</span>

        // Check if report exists
        <span class="cov6" title="2">checkQuery := `SELECT COUNT(*) FROM report WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, reportID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Report not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov1" title="1">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov1" title="1">{
                updates["title"] = title
        }</span>
        <span class="cov1" title="1">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>
        <span class="cov1" title="1">if query, ok := req.Data["query"]; ok </span><span class="cov0" title="0">{
                queryBytes, err := json.Marshal(query)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid query format",
                                "",
                        ))
                        return
                }</span>
                <span class="cov0" title="0">updates["query"] = string(queryBytes)</span>
        }

        <span class="cov1" title="1">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov1" title="1">queryStr := "UPDATE report SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov10" title="3">{
                if !first </span><span class="cov6" title="2">{
                        queryStr += ", "
                }</span>
                <span class="cov10" title="3">queryStr += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov1" title="1">queryStr += " WHERE id = ?"
        args = append(args, reportID)

        _, err = h.db.Exec(c.Request.Context(), queryStr, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update report", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update report",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Report updated",
                zap.String("report_id", reportID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      reportID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleReportRemove soft-deletes a report
func (h *Handler) handleReportRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "report", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get report ID
        <span class="cov1" title="1">reportID, ok := req.Data["id"].(string)
        if !ok || reportID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing report ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the report
        <span class="cov1" title="1">query := `UPDATE report SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), reportID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete report", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete report",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Report not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Report deleted",
                zap.String("report_id", reportID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      reportID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleReportExecute executes a report and returns results
func (h *Handler) handleReportExecute(c *gin.Context, req *models.Request) <span class="cov6" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get report ID from request
        <span class="cov6" title="2">reportID, ok := req.Data["id"].(string)
        if !ok || reportID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing report ID",
                        "",
                ))
                return
        }</span>

        // Query report from database
        <span class="cov6" title="2">query := `
                SELECT id, title, description, query, created, modified, deleted
                FROM report
                WHERE id = ? AND deleted = 0
        `

        var report models.Report
        var description sql.NullString
        err := h.db.QueryRow(c.Request.Context(), query, reportID).Scan(
                &amp;report.ID,
                &amp;report.Title,
                &amp;description,
                &amp;report.Query,
                &amp;report.Created,
                &amp;report.Modified,
                &amp;report.Deleted,
        )
        if description.Valid </span><span class="cov0" title="0">{
                report.Description = description.String
        }</span>

        <span class="cov6" title="2">if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Report not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read report", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read report",
                        "",
                ))
                return
        }</span>

        // Parse query and execute it
        // For now, we return a placeholder response
        // In a real implementation, this would parse the JSON query and execute it against the database
        <span class="cov1" title="1">logger.Info("Report executed",
                zap.String("report_id", report.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "report": report,
                "results": map[string]interface{}{
                        "message": "Report execution not yet implemented - placeholder response",
                        "query":   report.Query,
                },
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleReportSetMetadata sets metadata for a report
func (h *Handler) handleReportSetMetadata(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Parse metadata from request
        <span class="cov1" title="1">reportID, ok := req.Data["reportId"].(string)
        if !ok || reportID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing reportId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Value can be any type, convert to JSON string
        <span class="cov1" title="1">var valueStr string
        if value, ok := req.Data["value"]; ok </span><span class="cov1" title="1">{
                valueBytes, err := json.Marshal(value)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidData,
                                "Invalid value format",
                                "",
                        ))
                        return
                }</span>
                <span class="cov1" title="1">valueStr = string(valueBytes)</span>
        }

        <span class="cov1" title="1">metadata := &amp;models.ReportMetaData{
                ID:       uuid.New().String(),
                ReportID: reportID,
                Property: property,
                Value:    valueStr,
                Created:  time.Now().Unix(),
                Modified: time.Now().Unix(),
                Deleted:  false,
        }

        // Insert into database
        query := `
                INSERT INTO report_metadata (id, report_id, property, value, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err := h.db.Exec(c.Request.Context(), query,
                metadata.ID,
                metadata.ReportID,
                metadata.Property,
                metadata.Value,
                metadata.Created,
                metadata.Modified,
                metadata.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to set report metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to set report metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Report metadata set",
                zap.String("metadata_id", metadata.ID),
                zap.String("report_id", reportID),
                zap.String("property", property),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleReportGetMetadata gets metadata for a report
func (h *Handler) handleReportGetMetadata(c *gin.Context, req *models.Request) <span class="cov6" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get report ID and property from request
        <span class="cov6" title="2">reportID, ok := req.Data["reportId"].(string)
        if !ok || reportID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing reportId",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="2">property, ok := req.Data["property"].(string)
        if !ok || property == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing property",
                        "",
                ))
                return
        }</span>

        // Query metadata from database
        <span class="cov6" title="2">query := `
                SELECT id, report_id, property, value, created, modified, deleted
                FROM report_metadata
                WHERE report_id = ? AND property = ? AND deleted = 0
        `

        var metadata models.ReportMetaData
        err := h.db.QueryRow(c.Request.Context(), query, reportID, property).Scan(
                &amp;metadata.ID,
                &amp;metadata.ReportID,
                &amp;metadata.Property,
                &amp;metadata.Value,
                &amp;metadata.Created,
                &amp;metadata.Modified,
                &amp;metadata.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Report metadata not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get report metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to get report metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Report metadata retrieved",
                zap.String("metadata_id", metadata.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "metadata": metadata,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleReportRemoveMetadata removes metadata from a report
func (h *Handler) handleReportRemoveMetadata(c *gin.Context, req *models.Request) <span class="cov6" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get metadata ID from request
        <span class="cov6" title="2">metadataID, ok := req.Data["id"].(string)
        if !ok || metadataID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing metadata ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the metadata
        <span class="cov6" title="2">query := `UPDATE report_metadata SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), metadataID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove report metadata", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove report metadata",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Report metadata not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Report metadata removed",
                zap.String("metadata_id", metadataID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      metadataID,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// ===== Repository CRUD Operations =====

// handleRepositoryCreate creates a new repository
func (h *Handler) handleRepositoryCreate(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse repository data
        <span class="cov7" title="4">repository, ok := req.Data["repository"].(string)
        if !ok || repository == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">repositoryTypeID, ok := req.Data["repository_type_id"].(string)
        if !ok || repositoryTypeID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository_type_id",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">repo := &amp;models.Repository{
                ID:               uuid.New().String(),
                Repository:       repository,
                Description:      getStringFromData(req.Data, "description"),
                RepositoryTypeID: repositoryTypeID,
                Created:          time.Now().Unix(),
                Modified:         time.Now().Unix(),
                Deleted:          false,
        }

        // Insert into database
        query := `
                INSERT INTO repository (id, repository, description, repository_type_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                repo.ID,
                repo.Repository,
                repo.Description,
                repo.RepositoryTypeID,
                repo.Created,
                repo.Modified,
                repo.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create repository", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create repository",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Repository created",
                zap.String("repository_id", repo.ID),
                zap.String("repository", repo.Repository),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "repository": repo,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleRepositoryRead reads a single repository by ID
func (h *Handler) handleRepositoryRead(c *gin.Context, req *models.Request) <span class="cov6" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">repositoryID, ok := req.Data["id"].(string)
        if !ok || repositoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository ID",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">query := `
                SELECT id, repository, description, repository_type_id, created, modified, deleted
                FROM repository
                WHERE id = ? AND deleted = 0
        `

        var repo models.Repository
        err := h.db.QueryRow(c.Request.Context(), query, repositoryID).Scan(
                &amp;repo.ID,
                &amp;repo.Repository,
                &amp;repo.Description,
                &amp;repo.RepositoryTypeID,
                &amp;repo.Created,
                &amp;repo.Modified,
                &amp;repo.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Repository not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read repository", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read repository",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Repository read",
                zap.String("repository_id", repo.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "repository": repo,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryList lists all repositories
func (h *Handler) handleRepositoryList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `
                SELECT id, repository, description, repository_type_id, created, modified, deleted
                FROM repository
                WHERE deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list repositories", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list repositories",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        repositories := make([]models.Repository, 0)
        for rows.Next() </span><span class="cov6" title="3">{
                var repo models.Repository
                err := rows.Scan(
                        &amp;repo.ID,
                        &amp;repo.Repository,
                        &amp;repo.Description,
                        &amp;repo.RepositoryTypeID,
                        &amp;repo.Created,
                        &amp;repo.Modified,
                        &amp;repo.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan repository", zap.Error(err))
                        continue</span>
                }
                <span class="cov6" title="3">repositories = append(repositories, repo)</span>
        }

        <span class="cov1" title="1">logger.Info("Repositories listed",
                zap.Int("count", len(repositories)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "repositories": repositories,
                "count":        len(repositories),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryModify updates an existing repository
func (h *Handler) handleRepositoryModify(c *gin.Context, req *models.Request) <span class="cov6" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">repositoryID, ok := req.Data["id"].(string)
        if !ok || repositoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository ID",
                        "",
                ))
                return
        }</span>

        // Check if repository exists
        <span class="cov6" title="3">checkQuery := `SELECT COUNT(*) FROM repository WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, repositoryID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Repository not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically
        <span class="cov4" title="2">updates := make(map[string]interface{})

        if repository, ok := req.Data["repository"].(string); ok &amp;&amp; repository != "" </span><span class="cov1" title="1">{
                updates["repository"] = repository
        }</span>
        <span class="cov4" title="2">if description, ok := req.Data["description"].(string); ok </span><span class="cov4" title="2">{
                updates["description"] = description
        }</span>
        <span class="cov4" title="2">if repositoryTypeID, ok := req.Data["repository_type_id"].(string); ok &amp;&amp; repositoryTypeID != "" </span><span class="cov0" title="0">{
                updates["repository_type_id"] = repositoryTypeID
        }</span>

        <span class="cov4" title="2">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">query := "UPDATE repository SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov9" title="5">{
                if !first </span><span class="cov6" title="3">{
                        query += ", "
                }</span>
                <span class="cov9" title="5">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov4" title="2">query += " WHERE id = ?"
        args = append(args, repositoryID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update repository", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update repository",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Repository updated",
                zap.String("repository_id", repositoryID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      repositoryID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryRemove soft-deletes a repository
func (h *Handler) handleRepositoryRemove(c *gin.Context, req *models.Request) <span class="cov4" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">repositoryID, ok := req.Data["id"].(string)
        if !ok || repositoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository ID",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">query := `UPDATE repository SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), repositoryID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete repository", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete repository",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Repository not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Repository deleted",
                zap.String("repository_id", repositoryID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      repositoryID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// ===== Repository Type CRUD Operations =====

// handleRepositoryTypeCreate creates a new repository type
func (h *Handler) handleRepositoryTypeCreate(c *gin.Context, req *models.Request) <span class="cov10" title="6">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="6">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository_type", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="6">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="6">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="6">repoType := &amp;models.RepositoryType{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        query := `
                INSERT INTO repository_type (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                repoType.ID,
                repoType.Title,
                repoType.Description,
                repoType.Created,
                repoType.Modified,
                repoType.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create repository type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create repository type",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="6">logger.Info("Repository type created",
                zap.String("repository_type_id", repoType.ID),
                zap.String("title", repoType.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "repository_type": repoType,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleRepositoryTypeRead reads a single repository type by ID
func (h *Handler) handleRepositoryTypeRead(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">repositoryTypeID, ok := req.Data["id"].(string)
        if !ok || repositoryTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository type ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `
                SELECT id, title, description, created, modified, deleted
                FROM repository_type
                WHERE id = ? AND deleted = 0
        `

        var repoType models.RepositoryType
        err := h.db.QueryRow(c.Request.Context(), query, repositoryTypeID).Scan(
                &amp;repoType.ID,
                &amp;repoType.Title,
                &amp;repoType.Description,
                &amp;repoType.Created,
                &amp;repoType.Modified,
                &amp;repoType.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Repository type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read repository type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read repository type",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Repository type read",
                zap.String("repository_type_id", repoType.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "repository_type": repoType,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryTypeList lists all repository types
func (h *Handler) handleRepositoryTypeList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `
                SELECT id, title, description, created, modified, deleted
                FROM repository_type
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list repository types", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list repository types",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        repoTypes := make([]models.RepositoryType, 0)
        for rows.Next() </span><span class="cov4" title="2">{
                var repoType models.RepositoryType
                err := rows.Scan(
                        &amp;repoType.ID,
                        &amp;repoType.Title,
                        &amp;repoType.Description,
                        &amp;repoType.Created,
                        &amp;repoType.Modified,
                        &amp;repoType.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan repository type", zap.Error(err))
                        continue</span>
                }
                <span class="cov4" title="2">repoTypes = append(repoTypes, repoType)</span>
        }

        <span class="cov1" title="1">logger.Info("Repository types listed",
                zap.Int("count", len(repoTypes)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "repository_types": repoTypes,
                "count":            len(repoTypes),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryTypeModify updates an existing repository type
func (h *Handler) handleRepositoryTypeModify(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository_type", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">repositoryTypeID, ok := req.Data["id"].(string)
        if !ok || repositoryTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository type ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">checkQuery := `SELECT COUNT(*) FROM repository_type WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, repositoryTypeID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Repository type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov1" title="1">{
                updates["title"] = title
        }</span>
        <span class="cov1" title="1">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>

        <span class="cov1" title="1">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := "UPDATE repository_type SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov6" title="3">{
                if !first </span><span class="cov4" title="2">{
                        query += ", "
                }</span>
                <span class="cov6" title="3">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov1" title="1">query += " WHERE id = ?"
        args = append(args, repositoryTypeID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update repository type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update repository type",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Repository type updated",
                zap.String("repository_type_id", repositoryTypeID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      repositoryTypeID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryTypeRemove soft-deletes a repository type
func (h *Handler) handleRepositoryTypeRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository_type", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">repositoryTypeID, ok := req.Data["id"].(string)
        if !ok || repositoryTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository type ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `UPDATE repository_type SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), repositoryTypeID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete repository type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete repository type",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Repository type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Repository type deleted",
                zap.String("repository_type_id", repositoryTypeID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      repositoryTypeID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// ===== Repository-Project Mapping Operations =====

// handleRepositoryAssignProject assigns a repository to a project
func (h *Handler) handleRepositoryAssignProject(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">repositoryID, ok := req.Data["repository_id"].(string)
        if !ok || repositoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">projectID, ok := req.Data["project_id"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">mapping := &amp;models.RepositoryProjectMapping{
                ID:           uuid.New().String(),
                RepositoryID: repositoryID,
                ProjectID:    projectID,
                Created:      time.Now().Unix(),
                Modified:     time.Now().Unix(),
                Deleted:      false,
        }

        query := `
                INSERT INTO repository_project_mapping (id, repository_id, project_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.RepositoryID,
                mapping.ProjectID,
                mapping.Created,
                mapping.Modified,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to assign repository to project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to assign repository to project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Repository assigned to project",
                zap.String("repository_id", repositoryID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleRepositoryUnassignProject unassigns a repository from a project
func (h *Handler) handleRepositoryUnassignProject(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">repositoryID, ok := req.Data["repository_id"].(string)
        if !ok || repositoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">projectID, ok := req.Data["project_id"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `
                UPDATE repository_project_mapping
                SET deleted = 1, modified = ?
                WHERE repository_id = ? AND project_id = ? AND deleted = 0
        `

        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), repositoryID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unassign repository from project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to unassign repository from project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Repository-project mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Repository unassigned from project",
                zap.String("repository_id", repositoryID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "unassigned": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryListProjects lists all projects for a repository
func (h *Handler) handleRepositoryListProjects(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">repositoryID, ok := req.Data["repository_id"].(string)
        if !ok || repositoryID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `
                SELECT rpm.id, rpm.repository_id, rpm.project_id, rpm.created, rpm.modified, rpm.deleted
                FROM repository_project_mapping rpm
                WHERE rpm.repository_id = ? AND rpm.deleted = 0
                ORDER BY rpm.created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, repositoryID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list projects for repository", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list projects for repository",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        mappings := make([]models.RepositoryProjectMapping, 0)
        for rows.Next() </span><span class="cov6" title="3">{
                var mapping models.RepositoryProjectMapping
                err := rows.Scan(
                        &amp;mapping.ID,
                        &amp;mapping.RepositoryID,
                        &amp;mapping.ProjectID,
                        &amp;mapping.Created,
                        &amp;mapping.Modified,
                        &amp;mapping.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan repository-project mapping", zap.Error(err))
                        continue</span>
                }
                <span class="cov6" title="3">mappings = append(mappings, mapping)</span>
        }

        <span class="cov1" title="1">logger.Info("Projects listed for repository",
                zap.String("repository_id", repositoryID),
                zap.Int("count", len(mappings)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mappings": mappings,
                "count":    len(mappings),
        })
        c.JSON(http.StatusOK, response)</span>
}

// ===== Repository Commit-Ticket Mapping Operations =====

// handleRepositoryAddCommit adds a commit to a ticket
func (h *Handler) handleRepositoryAddCommit(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">repositoryID, ok := req.Data["repository_id"].(string)
        if !ok || repositoryID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing repository_id",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="3">ticketID, ok := req.Data["ticket_id"].(string)
        if !ok || ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket_id",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">commitHash, ok := req.Data["commit_hash"].(string)
        if !ok || commitHash == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing commit_hash",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">mapping := &amp;models.RepositoryCommitTicketMapping{
                ID:           uuid.New().String(),
                RepositoryID: repositoryID,
                TicketID:     ticketID,
                CommitHash:   commitHash,
                Created:      time.Now().Unix(),
                Modified:     time.Now().Unix(),
                Deleted:      false,
        }

        query := `
                INSERT INTO repository_commit_ticket_mapping (id, repository_id, ticket_id, commit_hash, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.RepositoryID,
                mapping.TicketID,
                mapping.CommitHash,
                mapping.Created,
                mapping.Modified,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add commit to ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add commit to ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Commit added to ticket",
                zap.String("repository_id", repositoryID),
                zap.String("ticket_id", ticketID),
                zap.String("commit_hash", commitHash),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleRepositoryRemoveCommit removes a commit from a ticket
func (h *Handler) handleRepositoryRemoveCommit(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "repository", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">commitHash, ok := req.Data["commit_hash"].(string)
        if !ok || commitHash == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing commit_hash",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `
                UPDATE repository_commit_ticket_mapping
                SET deleted = 1, modified = ?
                WHERE commit_hash = ? AND deleted = 0
        `

        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), commitHash)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove commit from ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove commit from ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Commit mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Commit removed from ticket",
                zap.String("commit_hash", commitHash),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryListCommits lists all commits for a ticket
func (h *Handler) handleRepositoryListCommits(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">ticketID, ok := req.Data["ticket_id"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `
                SELECT id, repository_id, ticket_id, commit_hash, created, modified, deleted
                FROM repository_commit_ticket_mapping
                WHERE ticket_id = ? AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list commits for ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list commits for ticket",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        commits := make([]models.RepositoryCommitTicketMapping, 0)
        for rows.Next() </span><span class="cov7" title="4">{
                var commit models.RepositoryCommitTicketMapping
                err := rows.Scan(
                        &amp;commit.ID,
                        &amp;commit.RepositoryID,
                        &amp;commit.TicketID,
                        &amp;commit.CommitHash,
                        &amp;commit.Created,
                        &amp;commit.Modified,
                        &amp;commit.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan commit mapping", zap.Error(err))
                        continue</span>
                }
                <span class="cov7" title="4">commits = append(commits, commit)</span>
        }

        <span class="cov1" title="1">logger.Info("Commits listed for ticket",
                zap.String("ticket_id", ticketID),
                zap.Int("count", len(commits)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "commits": commits,
                "count":   len(commits),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleRepositoryGetCommit gets a specific commit by commit hash
func (h *Handler) handleRepositoryGetCommit(c *gin.Context, req *models.Request) <span class="cov4" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">commitHash, ok := req.Data["commit_hash"].(string)
        if !ok || commitHash == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing commit_hash",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">query := `
                SELECT id, repository_id, ticket_id, commit_hash, created, modified, deleted
                FROM repository_commit_ticket_mapping
                WHERE commit_hash = ? AND deleted = 0
        `

        var commit models.RepositoryCommitTicketMapping
        err := h.db.QueryRow(c.Request.Context(), query, commitHash).Scan(
                &amp;commit.ID,
                &amp;commit.RepositoryID,
                &amp;commit.TicketID,
                &amp;commit.CommitHash,
                &amp;commit.Created,
                &amp;commit.Modified,
                &amp;commit.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Commit not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get commit", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to get commit",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Commit retrieved",
                zap.String("commit_hash", commitHash),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "commit": commit,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleResolutionCreate creates a new resolution
func (h *Handler) handleResolutionCreate(c *gin.Context, req *models.Request) <span class="cov10" title="12">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="12">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "resolution", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="12">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse resolution data from request
        <span class="cov10" title="12">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov3" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="10">resolution := &amp;models.Resolution{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO resolution (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                resolution.ID,
                resolution.Title,
                resolution.Description,
                resolution.Created,
                resolution.Modified,
                resolution.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create resolution", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create resolution",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="10">logger.Info("Resolution created",
                zap.String("resolution_id", resolution.ID),
                zap.String("title", resolution.Title),
                zap.String("username", username),
        )

        // Publish resolution created event
        h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "resolution",
                resolution.ID,
                username,
                map[string]interface{}{
                        "id":          resolution.ID,
                        "title":       resolution.Title,
                        "description": resolution.Description,
                },
                websocket.NewProjectContext("", []string{"READ"}), // System-wide entity
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "resolution": resolution,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleResolutionRead reads a single resolution by ID
func (h *Handler) handleResolutionRead(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get resolution ID from request
        <span class="cov6" title="4">resolutionID, ok := req.Data["id"].(string)
        if !ok || resolutionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing resolution ID",
                        "",
                ))
                return
        }</span>

        // Query resolution from database
        <span class="cov6" title="4">query := `
                SELECT id, title, description, created, modified, deleted
                FROM resolution
                WHERE id = ? AND deleted = 0
        `

        var resolution models.Resolution
        err := h.db.QueryRow(c.Request.Context(), query, resolutionID).Scan(
                &amp;resolution.ID,
                &amp;resolution.Title,
                &amp;resolution.Description,
                &amp;resolution.Created,
                &amp;resolution.Modified,
                &amp;resolution.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Resolution not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read resolution", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read resolution",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Resolution read",
                zap.String("resolution_id", resolution.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "resolution": resolution,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleResolutionList lists all resolutions
func (h *Handler) handleResolutionList(c *gin.Context, req *models.Request) <span class="cov4" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted resolutions ordered by title
        <span class="cov4" title="3">query := `
                SELECT id, title, description, created, modified, deleted
                FROM resolution
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list resolutions", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list resolutions",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        resolutions := make([]models.Resolution, 0)
        for rows.Next() </span><span class="cov7" title="6">{
                var resolution models.Resolution
                err := rows.Scan(
                        &amp;resolution.ID,
                        &amp;resolution.Title,
                        &amp;resolution.Description,
                        &amp;resolution.Created,
                        &amp;resolution.Modified,
                        &amp;resolution.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan resolution", zap.Error(err))
                        continue</span>
                }
                <span class="cov7" title="6">resolutions = append(resolutions, resolution)</span>
        }

        <span class="cov4" title="3">logger.Info("Resolutions listed",
                zap.Int("count", len(resolutions)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "resolutions": resolutions,
                "count":       len(resolutions),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleResolutionModify updates an existing resolution
func (h *Handler) handleResolutionModify(c *gin.Context, req *models.Request) <span class="cov7" title="6">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="6">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "resolution", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="6">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get resolution ID
        <span class="cov7" title="6">resolutionID, ok := req.Data["id"].(string)
        if !ok || resolutionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing resolution ID",
                        "",
                ))
                return
        }</span>

        // Check if resolution exists
        <span class="cov7" title="6">checkQuery := `SELECT COUNT(*) FROM resolution WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, resolutionID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Resolution not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov6" title="4">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov6" title="4">{
                updates["title"] = title
        }</span>
        <span class="cov6" title="4">if description, ok := req.Data["description"].(string); ok </span><span class="cov3" title="2">{
                updates["description"] = description
        }</span>

        <span class="cov6" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov6" title="4">query := "UPDATE resolution SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov9" title="10">{
                if !first </span><span class="cov7" title="6">{
                        query += ", "
                }</span>
                <span class="cov9" title="10">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov6" title="4">query += " WHERE id = ?"
        args = append(args, resolutionID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update resolution", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update resolution",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="4">logger.Info("Resolution updated",
                zap.String("resolution_id", resolutionID),
                zap.String("username", username),
        )

        // Publish resolution updated event
        h.publisher.PublishEntityEvent(
                models.ActionModify,
                "resolution",
                resolutionID,
                username,
                updates,
                websocket.NewProjectContext("", []string{"READ"}), // System-wide entity
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      resolutionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleResolutionRemove soft-deletes a resolution
func (h *Handler) handleResolutionRemove(c *gin.Context, req *models.Request) <span class="cov6" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov6" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "resolution", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get resolution ID
        <span class="cov6" title="5">resolutionID, ok := req.Data["id"].(string)
        if !ok || resolutionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing resolution ID",
                        "",
                ))
                return
        }</span>

        // Read resolution data before deleting (for event publishing)
        <span class="cov6" title="5">readQuery := `SELECT id, title, description FROM resolution WHERE id = ? AND deleted = 0`
        var resolution models.Resolution
        err = h.db.QueryRow(c.Request.Context(), readQuery, resolutionID).Scan(
                &amp;resolution.ID,
                &amp;resolution.Title,
                &amp;resolution.Description,
        )
        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Resolution not found",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="3">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read resolution before deletion", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read resolution",
                        "",
                ))
                return
        }</span>

        // Soft delete the resolution
        <span class="cov4" title="3">query := `UPDATE resolution SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), resolutionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete resolution", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete resolution",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Resolution not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="3">logger.Info("Resolution deleted",
                zap.String("resolution_id", resolutionID),
                zap.String("username", username),
        )

        // Publish resolution deleted event
        h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "resolution",
                resolutionID,
                username,
                map[string]interface{}{
                        "id":          resolution.ID,
                        "title":       resolution.Title,
                        "description": resolution.Description,
                },
                websocket.NewProjectContext("", []string{"READ"}), // System-wide entity
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      resolutionID,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
)

// InitializeServiceDiscoveryTables creates the service discovery and health check tables
func InitializeServiceDiscoveryTables(db database.Database) error <span class="cov0" title="0">{
        ctx := context.Background()

        logger.Info("Initializing service discovery tables")

        // Create service_registry table
        serviceRegistrySchema := `
        CREATE TABLE IF NOT EXISTS service_registry (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                type TEXT NOT NULL,
                version TEXT NOT NULL,
                url TEXT NOT NULL,
                health_check_url TEXT NOT NULL,
                public_key TEXT NOT NULL,
                signature TEXT NOT NULL,
                certificate TEXT,
                status TEXT NOT NULL DEFAULT 'registering',
                role TEXT NOT NULL DEFAULT 'primary',
                failover_group TEXT,
                is_active INTEGER DEFAULT 1,
                priority INTEGER DEFAULT 0,
                metadata TEXT DEFAULT '{}',
                registered_by TEXT NOT NULL,
                registered_at INTEGER NOT NULL,
                last_health_check INTEGER DEFAULT 0,
                health_check_count INTEGER DEFAULT 0,
                failed_health_count INTEGER DEFAULT 0,
                last_failover_at INTEGER DEFAULT 0,
                deleted INTEGER DEFAULT 0,
                UNIQUE(name, type, url)
        );
        `

        if _, err := db.Exec(ctx, serviceRegistrySchema); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create service_registry table", zap.Error(err))
                return err
        }</span>

        // Create indexes for service_registry
        <span class="cov0" title="0">indexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_service_registry_type ON service_registry(type)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_status ON service_registry(status)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_deleted ON service_registry(deleted)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_type_status ON service_registry(type, status, deleted)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_priority ON service_registry(priority DESC)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_failover_group ON service_registry(failover_group)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_is_active ON service_registry(is_active)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_role ON service_registry(role)",
                "CREATE INDEX IF NOT EXISTS idx_service_registry_group_active ON service_registry(failover_group, is_active, deleted)",
        }

        for _, indexSQL := range indexes </span><span class="cov0" title="0">{
                if _, err := db.Exec(ctx, indexSQL); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to create index", zap.Error(err), zap.String("sql", indexSQL))
                        return err
                }</span>
        }

        // Create service_health_check table
        <span class="cov0" title="0">healthCheckSchema := `
        CREATE TABLE IF NOT EXISTS service_health_check (
                id TEXT PRIMARY KEY,
                service_id TEXT NOT NULL,
                timestamp INTEGER NOT NULL,
                status TEXT NOT NULL,
                response_time INTEGER NOT NULL,
                status_code INTEGER NOT NULL,
                error_message TEXT,
                checked_by TEXT NOT NULL,
                FOREIGN KEY(service_id) REFERENCES service_registry(id)
        );
        `

        if _, err := db.Exec(ctx, healthCheckSchema); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create service_health_check table", zap.Error(err))
                return err
        }</span>

        // Create indexes for service_health_check
        <span class="cov0" title="0">healthIndexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_health_check_service ON service_health_check(service_id)",
                "CREATE INDEX IF NOT EXISTS idx_health_check_timestamp ON service_health_check(timestamp DESC)",
                "CREATE INDEX IF NOT EXISTS idx_health_check_status ON service_health_check(status)",
        }

        for _, indexSQL := range healthIndexes </span><span class="cov0" title="0">{
                if _, err := db.Exec(ctx, indexSQL); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to create health check index", zap.Error(err), zap.String("sql", indexSQL))
                        return err
                }</span>
        }

        // Create service_rotation_audit table for tracking rotations
        <span class="cov0" title="0">rotationAuditSchema := `
        CREATE TABLE IF NOT EXISTS service_rotation_audit (
                id TEXT PRIMARY KEY,
                old_service_id TEXT NOT NULL,
                new_service_id TEXT NOT NULL,
                reason TEXT,
                requested_by TEXT NOT NULL,
                rotation_time INTEGER NOT NULL,
                verification_hash TEXT NOT NULL,
                success INTEGER NOT NULL,
                error_message TEXT,
                FOREIGN KEY(old_service_id) REFERENCES service_registry(id),
                FOREIGN KEY(new_service_id) REFERENCES service_registry(id)
        );
        `

        if _, err := db.Exec(ctx, rotationAuditSchema); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create service_rotation_audit table", zap.Error(err))
                return err
        }</span>

        // Create indexes for service_rotation_audit
        <span class="cov0" title="0">rotationIndexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_rotation_audit_old_service ON service_rotation_audit(old_service_id)",
                "CREATE INDEX IF NOT EXISTS idx_rotation_audit_new_service ON service_rotation_audit(new_service_id)",
                "CREATE INDEX IF NOT EXISTS idx_rotation_audit_time ON service_rotation_audit(rotation_time DESC)",
        }

        for _, indexSQL := range rotationIndexes </span><span class="cov0" title="0">{
                if _, err := db.Exec(ctx, indexSQL); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to create rotation audit index", zap.Error(err), zap.String("sql", indexSQL))
                        return err
                }</span>
        }

        // Create service_failover_events table for tracking automatic failovers
        <span class="cov0" title="0">failoverEventsSchema := `
        CREATE TABLE IF NOT EXISTS service_failover_events (
                id TEXT PRIMARY KEY,
                failover_group TEXT NOT NULL,
                service_type TEXT NOT NULL,
                old_service_id TEXT NOT NULL,
                new_service_id TEXT NOT NULL,
                failover_reason TEXT NOT NULL,
                failover_type TEXT NOT NULL,
                timestamp INTEGER NOT NULL,
                automatic INTEGER NOT NULL,
                FOREIGN KEY(old_service_id) REFERENCES service_registry(id),
                FOREIGN KEY(new_service_id) REFERENCES service_registry(id)
        );
        `

        if _, err := db.Exec(ctx, failoverEventsSchema); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create service_failover_events table", zap.Error(err))
                return err
        }</span>

        // Create indexes for service_failover_events
        <span class="cov0" title="0">failoverIndexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_failover_events_group ON service_failover_events(failover_group)",
                "CREATE INDEX IF NOT EXISTS idx_failover_events_type ON service_failover_events(service_type)",
                "CREATE INDEX IF NOT EXISTS idx_failover_events_timestamp ON service_failover_events(timestamp DESC)",
                "CREATE INDEX IF NOT EXISTS idx_failover_events_old_service ON service_failover_events(old_service_id)",
                "CREATE INDEX IF NOT EXISTS idx_failover_events_new_service ON service_failover_events(new_service_id)",
        }

        for _, indexSQL := range failoverIndexes </span><span class="cov0" title="0">{
                if _, err := db.Exec(ctx, indexSQL); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to create failover events index", zap.Error(err), zap.String("sql", indexSQL))
                        return err
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Service discovery tables created successfully")
        return nil</span>
}

// SeedDefaultServices seeds default services for development/testing
func SeedDefaultServices(db database.Database) error <span class="cov0" title="0">{
        ctx := context.Background()

        logger.Info("Seeding default services (development mode)")

        // Check if any services already exist
        var count int
        err := db.QueryRow(ctx, "SELECT COUNT(*) FROM service_registry WHERE deleted = 0").Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check existing services", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("Services already exist, skipping seed", zap.Int("count", count))
                return nil
        }</span>

        // Note: In production, services should be registered via the API with proper signatures
        // This is just for development/testing purposes

        <span class="cov0" title="0">logger.Info("No seed services configured - services must be registered via API")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "context"
        "database/sql"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/security"
        "helixtrack.ru/core/internal/services"
)

// ServiceDiscoveryHandler handles service discovery operations
type ServiceDiscoveryHandler struct {
        db            database.Database
        signer        *security.ServiceSigner
        healthChecker *services.HealthChecker
}

// NewServiceDiscoveryHandler creates a new service discovery handler
func NewServiceDiscoveryHandler(db database.Database) (*ServiceDiscoveryHandler, error) <span class="cov10" title="11">{
        signer, err := security.NewServiceSigner()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create service signer: %w", err)
        }</span>

        <span class="cov10" title="11">healthChecker := services.NewHealthChecker(db, 1*time.Minute, 10*time.Second)

        return &amp;ServiceDiscoveryHandler{
                db:            db,
                signer:        signer,
                healthChecker: healthChecker,
        }, nil</span>
}

// StartHealthChecker starts the health checker background process
func (h *ServiceDiscoveryHandler) StartHealthChecker() error <span class="cov0" title="0">{
        return h.healthChecker.Start()
}</span>

// StopHealthChecker stops the health checker background process
func (h *ServiceDiscoveryHandler) StopHealthChecker() <span class="cov0" title="0">{
        h.healthChecker.Stop()
}</span>

// RegisterService handles service registration
func (h *ServiceDiscoveryHandler) RegisterService(c *gin.Context) <span class="cov1" title="1">{
        var req models.ServiceRegistrationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid registration request",
                        "",
                ))
                return
        }</span>

        // Verify admin token
        <span class="cov1" title="1">if req.AdminToken == "" || len(req.AdminToken) &lt; 32 </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid admin token",
                        "",
                ))
                return
        }</span>

        // Get requesting user from context
        <span class="cov0" title="0">username, exists := c.Get("username")
        if !exists </span><span class="cov0" title="0">{
                username = "system"
        }</span>

        // Create service registration
        <span class="cov0" title="0">service := &amp;models.ServiceRegistration{
                ID:                uuid.New().String(),
                Name:              req.Name,
                Type:              req.Type,
                Version:           req.Version,
                URL:               req.URL,
                HealthCheckURL:    req.HealthCheckURL,
                PublicKey:         req.PublicKey,
                Certificate:       req.Certificate,
                Status:            models.ServiceStatusRegistering,
                Priority:          req.Priority,
                Metadata:          req.Metadata,
                RegisteredBy:      username.(string),
                RegisteredAt:      time.Now(),
                LastHealthCheck:   time.Time{},
                HealthCheckCount:  0,
                FailedHealthCount: 0,
                Deleted:           false,
        }

        // Sign the service registration
        if err := h.signer.SignServiceRegistration(service); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to sign service registration", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to sign service registration",
                        "",
                ))
                return
        }</span>

        // Insert into database
        <span class="cov0" title="0">query := `
                INSERT INTO service_registry (
                        id, name, type, version, url, health_check_url, public_key, signature, certificate,
                        status, priority, metadata, registered_by, registered_at, last_health_check,
                        health_check_count, failed_health_count, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := h.db.Exec(context.Background(), query,
                service.ID,
                service.Name,
                service.Type,
                service.Version,
                service.URL,
                service.HealthCheckURL,
                service.PublicKey,
                service.Signature,
                service.Certificate,
                service.Status,
                service.Priority,
                service.Metadata,
                service.RegisteredBy,
                service.RegisteredAt.Unix(),
                0, // last_health_check
                0, // health_check_count
                0, // failed_health_count
                0, // deleted
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to insert service registration", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to register service",
                        "",
                ))
                return
        }</span>

        // Perform immediate health check
        <span class="cov0" title="0">go h.healthChecker.CheckServiceNow(service.ID)

        logger.Info("Service registered successfully",
                zap.String("service_id", service.ID),
                zap.String("name", service.Name),
                zap.String("type", string(service.Type)),
                zap.String("url", service.URL),
        )

        c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "service": service,
        }))</span>
}

// DiscoverServices handles service discovery requests
func (h *ServiceDiscoveryHandler) DiscoverServices(c *gin.Context) <span class="cov3" title="2">{
        var req models.ServiceDiscoveryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid discovery request",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ctx := context.Background()

        // Build query based on request
        query := `
                SELECT id, name, type, version, url, health_check_url, public_key, signature, certificate,
                       status, priority, metadata, registered_by, registered_at, last_health_check,
                       health_check_count, failed_health_count
                FROM service_registry
                WHERE deleted = 0
        `

        args := []interface{}{}

        if req.Type != "" </span><span class="cov3" title="2">{
                query += " AND type = ?"
                args = append(args, req.Type)
        }</span>

        <span class="cov3" title="2">if req.OnlyHealthy </span><span class="cov0" title="0">{
                query += " AND status = ?"
                args = append(args, models.ServiceStatusHealthy)
        }</span>

        // Order by priority (higher first) and then by health check count (more reliable)
        <span class="cov3" title="2">query += " ORDER BY priority DESC, health_check_count DESC"

        rows, err := h.db.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to query services", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to discover services",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var services []models.ServiceRegistration

        for rows.Next() </span><span class="cov1" title="1">{
                var service models.ServiceRegistration
                var registeredAt int64
                var lastHealthCheck sql.NullInt64
                var healthCheckURL, publicKey, signature, certificate, metadata sql.NullString

                err := rows.Scan(
                        &amp;service.ID,
                        &amp;service.Name,
                        &amp;service.Type,
                        &amp;service.Version,
                        &amp;service.URL,
                        &amp;healthCheckURL,
                        &amp;publicKey,
                        &amp;signature,
                        &amp;certificate,
                        &amp;service.Status,
                        &amp;service.Priority,
                        &amp;metadata,
                        &amp;service.RegisteredBy,
                        &amp;registeredAt,
                        &amp;lastHealthCheck,
                        &amp;service.HealthCheckCount,
                        &amp;service.FailedHealthCount,
                )

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan service row", zap.Error(err))
                        continue</span>
                }

                // Convert nullable strings
                <span class="cov1" title="1">if healthCheckURL.Valid </span><span class="cov0" title="0">{
                        service.HealthCheckURL = healthCheckURL.String
                }</span>
                <span class="cov1" title="1">if publicKey.Valid </span><span class="cov0" title="0">{
                        service.PublicKey = publicKey.String
                }</span>
                <span class="cov1" title="1">if signature.Valid </span><span class="cov0" title="0">{
                        service.Signature = signature.String
                }</span>
                <span class="cov1" title="1">if certificate.Valid </span><span class="cov0" title="0">{
                        service.Certificate = certificate.String
                }</span>
                <span class="cov1" title="1">if metadata.Valid </span><span class="cov0" title="0">{
                        service.Metadata = metadata.String
                }</span>

                <span class="cov1" title="1">service.RegisteredAt = time.Unix(registeredAt, 0)
                if lastHealthCheck.Valid &amp;&amp; lastHealthCheck.Int64 &gt; 0 </span><span class="cov0" title="0">{
                        service.LastHealthCheck = time.Unix(lastHealthCheck.Int64, 0)
                }</span>

                // Filter by version if specified
                <span class="cov1" title="1">if req.MinVersion != "" &amp;&amp; service.Version &lt; req.MinVersion </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">services = append(services, service)</span>
        }

        <span class="cov3" title="2">response := models.ServiceDiscoveryResponse{
                Services:   services,
                TotalCount: len(services),
                Timestamp:  time.Now(),
        }

        c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "discovery": response,
        }))</span>
}

// RotateService handles secure service rotation
func (h *ServiceDiscoveryHandler) RotateService(c *gin.Context) <span class="cov0" title="0">{
        var req models.ServiceRotationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid rotation request",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Verify admin token
        if req.AdminToken == "" || len(req.AdminToken) &lt; 32 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid admin token",
                        "",
                ))
                return
        }</span>

        // Get old service
        <span class="cov0" title="0">var oldService models.ServiceRegistration
        err := h.getServiceByID(ctx, req.CurrentServiceID, &amp;oldService)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Current service not found",
                        "",
                ))
                return
        }</span>

        // Verify old service can be rotated
        <span class="cov0" title="0">if !oldService.CanRotate() </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidAction,
                        fmt.Sprintf("Service cannot be rotated in current status: %s", oldService.Status),
                        "",
                ))
                return
        }</span>

        // Verify service types match
        <span class="cov0" title="0">if oldService.Type != req.NewService.Type </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidAction,
                        "Service type mismatch",
                        "",
                ))
                return
        }</span>

        // Set new service metadata
        <span class="cov0" title="0">req.NewService.ID = uuid.New().String()
        req.NewService.Status = models.ServiceStatusRegistering
        req.NewService.RegisteredAt = time.Now()
        req.NewService.RegisteredBy = req.RequestedBy

        // Sign new service
        if err := h.signer.SignServiceRegistration(&amp;req.NewService); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to sign new service", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to sign new service",
                        "",
                ))
                return
        }</span>

        // Verify rotation is legitimate
        <span class="cov0" title="0">if err := h.signer.VerifyServiceRotation(&amp;oldService, &amp;req.NewService, req.AdminToken); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Service rotation verification failed",
                        zap.Error(err),
                        zap.String("old_service", oldService.ID),
                        zap.String("requested_by", req.RequestedBy),
                )
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Service rotation verification failed: "+err.Error(),
                        "",
                ))
                return
        }</span>

        // Start transaction
        // 1. Mark old service as decommissioned
        <span class="cov0" title="0">updateOldQuery := `
                UPDATE service_registry
                SET status = ?, deleted = 1
                WHERE id = ?
        `

        _, err = h.db.Exec(ctx, updateOldQuery, models.ServiceStatusDecommission, oldService.ID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to decommission old service", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to decommission old service",
                        "",
                ))
                return
        }</span>

        // 2. Register new service
        <span class="cov0" title="0">insertNewQuery := `
                INSERT INTO service_registry (
                        id, name, type, version, url, health_check_url, public_key, signature, certificate,
                        status, priority, metadata, registered_by, registered_at, last_health_check,
                        health_check_count, failed_health_count, deleted
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(ctx, insertNewQuery,
                req.NewService.ID,
                req.NewService.Name,
                req.NewService.Type,
                req.NewService.Version,
                req.NewService.URL,
                req.NewService.HealthCheckURL,
                req.NewService.PublicKey,
                req.NewService.Signature,
                req.NewService.Certificate,
                req.NewService.Status,
                req.NewService.Priority,
                req.NewService.Metadata,
                req.NewService.RegisteredBy,
                req.NewService.RegisteredAt.Unix(),
                0, 0, 0, 0,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to register new service", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to register new service",
                        "",
                ))
                return
        }</span>

        // 3. Record rotation in audit log
        <span class="cov0" title="0">rotationTime := time.Now()
        verificationHash := security.GenerateRotationCode(req.NewService.ID, req.AdminToken)

        auditQuery := `
                INSERT INTO service_rotation_audit (
                        id, old_service_id, new_service_id, reason, requested_by, rotation_time,
                        verification_hash, success, error_message
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(ctx, auditQuery,
                uuid.New().String(),
                oldService.ID,
                req.NewService.ID,
                req.Reason,
                req.RequestedBy,
                rotationTime.Unix(),
                verificationHash,
                1, // success
                "",
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to record rotation audit", zap.Error(err))
                // Don't fail the rotation for this
        }</span>

        // Perform immediate health check on new service
        <span class="cov0" title="0">go h.healthChecker.CheckServiceNow(req.NewService.ID)

        logger.Info("Service rotated successfully",
                zap.String("old_service_id", oldService.ID),
                zap.String("new_service_id", req.NewService.ID),
                zap.String("type", string(oldService.Type)),
                zap.String("requested_by", req.RequestedBy),
        )

        response := models.ServiceRotationResponse{
                Success:          true,
                OldServiceID:     oldService.ID,
                NewServiceID:     req.NewService.ID,
                RotationTime:     rotationTime,
                VerificationHash: verificationHash,
                Message:          "Service rotated successfully",
        }

        c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "rotation": response,
        }))</span>
}

// DecommissionService handles service decommissioning
func (h *ServiceDiscoveryHandler) DecommissionService(c *gin.Context) <span class="cov3" title="2">{
        var req models.ServiceDecommissionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid decommission request",
                        "",
                ))
                return
        }</span>

        // Verify admin token
        <span class="cov3" title="2">if req.AdminToken == "" || len(req.AdminToken) &lt; 32 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid admin token",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ctx := context.Background()

        // Update service status
        query := `
                UPDATE service_registry
                SET status = ?, deleted = 1
                WHERE id = ? AND deleted = 0
        `

        result, err := h.db.Exec(ctx, query, models.ServiceStatusDecommission, req.ServiceID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to decommission service", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to decommission service",
                        "",
                ))
                return
        }</span>

        // Check if service was found
        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Service not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Service decommissioned",
                zap.String("service_id", req.ServiceID),
                zap.String("reason", req.Reason),
        )

        c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "message":    "Service decommissioned successfully",
                "service_id": req.ServiceID,
        }))</span>
}

// GetServiceHealth returns health information for a service
func (h *ServiceDiscoveryHandler) GetServiceHealth(c *gin.Context) <span class="cov3" title="2">{
        serviceID := c.Param("id")
        if serviceID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Service ID is required",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ctx := context.Background()

        // Get service info
        var service models.ServiceRegistration
        err := h.getServiceByID(ctx, serviceID, &amp;service)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Service not found",
                        "",
                ))
                return
        }</span>

        // Get health history
        <span class="cov1" title="1">history, err := h.healthChecker.GetServiceHealthHistory(serviceID, 20)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to get health history", zap.Error(err))
                history = []models.ServiceHealthCheck{}
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "service": map[string]interface{}{
                        "id":                  service.ID,
                        "name":                service.Name,
                        "status":              service.Status,
                        "last_health_check":   service.LastHealthCheck,
                        "health_check_count":  service.HealthCheckCount,
                        "failed_health_count": service.FailedHealthCount,
                },
                "health_history": history,
        }))</span>
}

// ListServices returns all registered services
func (h *ServiceDiscoveryHandler) ListServices(c *gin.Context) <span class="cov3" title="2">{
        ctx := context.Background()

        query := `
                SELECT id, name, type, version, url, status, priority, registered_at, last_health_check,
                       health_check_count, failed_health_count
                FROM service_registry
                WHERE deleted = 0
                ORDER BY type, priority DESC, name
        `

        rows, err := h.db.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to query services", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list services",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var services []map[string]interface{}

        for rows.Next() </span><span class="cov5" title="3">{
                var id, name, svcType, version, url, status string
                var priority, healthCheckCount, failedHealthCount int
                var registeredAt, lastHealthCheck int64

                err := rows.Scan(&amp;id, &amp;name, &amp;svcType, &amp;version, &amp;url, &amp;status, &amp;priority,
                        &amp;registeredAt, &amp;lastHealthCheck, &amp;healthCheckCount, &amp;failedHealthCount)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan service row", zap.Error(err))
                        continue</span>
                }

                <span class="cov5" title="3">service := map[string]interface{}{
                        "id":                  id,
                        "name":                name,
                        "type":                svcType,
                        "version":             version,
                        "url":                 url,
                        "status":              status,
                        "priority":            priority,
                        "registered_at":       time.Unix(registeredAt, 0),
                        "health_check_count":  healthCheckCount,
                        "failed_health_count": failedHealthCount,
                }

                if lastHealthCheck &gt; 0 </span><span class="cov5" title="3">{
                        service["last_health_check"] = time.Unix(lastHealthCheck, 0)
                }</span>

                <span class="cov5" title="3">services = append(services, service)</span>
        }

        <span class="cov3" title="2">c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "services": services,
                "total":    len(services),
        }))</span>
}

// getServiceByID retrieves a service by ID
func (h *ServiceDiscoveryHandler) getServiceByID(ctx context.Context, serviceID string, service *models.ServiceRegistration) error <span class="cov3" title="2">{
        query := `
                SELECT id, name, type, version, url, health_check_url, public_key, signature, certificate,
                       status, priority, metadata, registered_by, registered_at, last_health_check,
                       health_check_count, failed_health_count
                FROM service_registry
                WHERE id = ? AND deleted = 0
        `

        var registeredAt int64
        var lastHealthCheck sql.NullInt64
        var healthCheckURL, publicKey, signature, certificate, metadata sql.NullString

        err := h.db.QueryRow(ctx, query, serviceID).Scan(
                &amp;service.ID,
                &amp;service.Name,
                &amp;service.Type,
                &amp;service.Version,
                &amp;service.URL,
                &amp;healthCheckURL,
                &amp;publicKey,
                &amp;signature,
                &amp;certificate,
                &amp;service.Status,
                &amp;service.Priority,
                &amp;metadata,
                &amp;service.RegisteredBy,
                &amp;registeredAt,
                &amp;lastHealthCheck,
                &amp;service.HealthCheckCount,
                &amp;service.FailedHealthCount,
        )

        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Convert nullable strings
        <span class="cov1" title="1">if healthCheckURL.Valid </span><span class="cov0" title="0">{
                service.HealthCheckURL = healthCheckURL.String
        }</span>
        <span class="cov1" title="1">if publicKey.Valid </span><span class="cov0" title="0">{
                service.PublicKey = publicKey.String
        }</span>
        <span class="cov1" title="1">if signature.Valid </span><span class="cov0" title="0">{
                service.Signature = signature.String
        }</span>
        <span class="cov1" title="1">if certificate.Valid </span><span class="cov0" title="0">{
                service.Certificate = certificate.String
        }</span>
        <span class="cov1" title="1">if metadata.Valid </span><span class="cov0" title="0">{
                service.Metadata = metadata.String
        }</span>

        <span class="cov1" title="1">service.RegisteredAt = time.Unix(registeredAt, 0)
        if lastHealthCheck.Valid &amp;&amp; lastHealthCheck.Int64 &gt; 0 </span><span class="cov0" title="0">{
                service.LastHealthCheck = time.Unix(lastHealthCheck.Int64, 0)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// UpdateService handles service metadata updates
func (h *ServiceDiscoveryHandler) UpdateService(c *gin.Context) <span class="cov3" title="2">{
        var req models.ServiceUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "Invalid update request",
                        "",
                ))
                return
        }</span>

        // Verify admin token
        <span class="cov3" title="2">if req.AdminToken == "" || len(req.AdminToken) &lt; 32 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Invalid admin token",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">ctx := context.Background()

        // Build update query dynamically
        updates := []string{}
        args := []interface{}{}

        if req.Version != "" </span><span class="cov1" title="1">{
                updates = append(updates, "version = ?")
                args = append(args, req.Version)
        }</span>
        <span class="cov3" title="2">if req.URL != "" </span><span class="cov0" title="0">{
                updates = append(updates, "url = ?")
                args = append(args, req.URL)
        }</span>
        <span class="cov3" title="2">if req.HealthCheckURL != "" </span><span class="cov0" title="0">{
                updates = append(updates, "health_check_url = ?")
                args = append(args, req.HealthCheckURL)
        }</span>
        <span class="cov3" title="2">if req.Priority != 0 </span><span class="cov0" title="0">{
                updates = append(updates, "priority = ?")
                args = append(args, req.Priority)
        }</span>
        <span class="cov3" title="2">if req.Metadata != "" </span><span class="cov0" title="0">{
                updates = append(updates, "metadata = ?")
                args = append(args, req.Metadata)
        }</span>

        <span class="cov3" title="2">if len(updates) == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidRequest,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">args = append(args, req.ServiceID)

        query := fmt.Sprintf("UPDATE service_registry SET %s WHERE id = ? AND deleted = 0",
                joinStrings(updates, ", "))

        result, err := h.db.Exec(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update service", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update service",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Service not found",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">logger.Info("Service updated",
                zap.String("service_id", req.ServiceID),
        )

        c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "message":    "Service updated successfully",
                "service_id": req.ServiceID,
        }))</span>
}

// joinStrings is a helper to join strings
func joinStrings(strs []string, sep string) string <span class="cov1" title="1">{
        result := ""
        for i, s := range strs </span><span class="cov1" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += sep
                }</span>
                <span class="cov1" title="1">result += s</span>
        }
        <span class="cov1" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"

        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
        "go.uber.org/zap"
)

// TeamCreate handles creating a new team
func (h *Handler) TeamCreate(c *gin.Context, req *models.Request) <span class="cov10" title="2">{
        // Parse the team data from request
        var team models.Team
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal team data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid team data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="2">if err := json.Unmarshal(dataBytes, &amp;team); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal team data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid team data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="2">if team.Title == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team title is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov1" title="1">team.ID = uuid.New().String()
        team.Created = time.Now().Unix()
        team.Modified = team.Created
        team.Deleted = false

        // TODO: Store team in database
        // This will be implemented when database layer is updated
        logger.Info("Team created", zap.String("id", team.ID), zap.String("title", team.Title))

        response := models.NewSuccessResponse(map[string]interface{}{"team": team})
        c.JSON(http.StatusOK, response)</span>
}

// TeamRead handles reading a single team by ID
func (h *Handler) TeamRead(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get team ID from request data
        teamID, ok := req.Data["id"].(string)
        if !ok || teamID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve team from database
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Team read requested", zap.String("id", teamID))

        // For now, return a placeholder response
        response := models.NewErrorResponse(models.ErrorCodeInternalError, "Team read not yet implemented", "")
        c.JSON(http.StatusNotImplemented, response)</span>
}

// TeamList handles listing all teams
func (h *Handler) TeamList(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // TODO: Retrieve teams from database with pagination
        // This will be implemented when database layer is updated
        logger.Info("Team list requested")

        // For now, return empty list
        teams := []models.Team{}
        response := models.NewSuccessResponse(map[string]interface{}{"teams": teams, "count": len(teams)})
        c.JSON(http.StatusOK, response)
}</span>

// TeamModify handles updating an existing team
func (h *Handler) TeamModify(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Parse the team data from request
        var team models.Team
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal team data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid team data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov1" title="1">if err := json.Unmarshal(dataBytes, &amp;team); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal team data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid team data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov1" title="1">if team.ID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Update timestamp
        <span class="cov1" title="1">team.Modified = time.Now().Unix()

        // TODO: Update team in database
        // This will be implemented when database layer is updated
        logger.Info("Team modified", zap.String("id", team.ID))

        response := models.NewSuccessResponse(map[string]interface{}{"team": team})
        c.JSON(http.StatusOK, response)</span>
}

// TeamRemove handles soft-deleting a team
func (h *Handler) TeamRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get team ID from request data
        teamID, ok := req.Data["id"].(string)
        if !ok || teamID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Soft-delete team in database (set deleted=true)
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Team removed", zap.String("id", teamID))

        response := models.NewSuccessResponse(map[string]interface{}{
                "id":      teamID,
                "deleted": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// TeamAssignOrganization handles assigning a team to an organization
func (h *Handler) TeamAssignOrganization(c *gin.Context, req *models.Request) <span class="cov10" title="2">{
        // Parse the mapping data from request
        var mapping models.TeamOrganizationMapping
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="2">if err := json.Unmarshal(dataBytes, &amp;mapping); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="2">if mapping.TeamID == "" || mapping.OrganizationID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID and Organization ID are required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov1" title="1">mapping.ID = uuid.New().String()
        mapping.Created = time.Now().Unix()
        mapping.Modified = mapping.Created
        mapping.Deleted = false

        // TODO: Store mapping in database
        // This will be implemented when database layer is updated
        logger.Info("Team assigned to organization",
                zap.String("teamId", mapping.TeamID),
                zap.String("organizationId", mapping.OrganizationID))

        response := models.NewSuccessResponse(map[string]interface{}{"mapping": mapping})
        c.JSON(http.StatusOK, response)</span>
}

// TeamUnassignOrganization handles unassigning a team from an organization
func (h *Handler) TeamUnassignOrganization(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get team ID and organization ID from request data
        teamID, ok1 := req.Data["teamId"].(string)
        organizationID, ok2 := req.Data["organizationId"].(string)

        if !ok1 || !ok2 || teamID == "" || organizationID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID and Organization ID are required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Remove mapping from database (soft delete)
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Team unassigned from organization",
                zap.String("teamId", teamID),
                zap.String("organizationId", organizationID))

        response := models.NewSuccessResponse(map[string]interface{}{
                "teamId":         teamID,
                "organizationId": organizationID,
                "unassigned":     true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// TeamListOrganizations handles listing all organizations for a team
func (h *Handler) TeamListOrganizations(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get team ID from request data
        teamID, ok := req.Data["teamId"].(string)
        if !ok || teamID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve organizations from database for this team
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Team organizations list requested", zap.String("teamId", teamID))

        // For now, return empty list
        organizations := []models.Organization{}
        response := models.NewSuccessResponse(map[string]interface{}{"organizations": organizations, "count": len(organizations)})
        c.JSON(http.StatusOK, response)</span>
}

// TeamAssignProject handles assigning a team to a project
func (h *Handler) TeamAssignProject(c *gin.Context, req *models.Request) <span class="cov10" title="2">{
        // Parse the mapping data from request
        var mapping models.TeamProjectMapping
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="2">if err := json.Unmarshal(dataBytes, &amp;mapping); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="2">if mapping.TeamID == "" || mapping.ProjectID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID and Project ID are required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov1" title="1">mapping.ID = uuid.New().String()
        mapping.Created = time.Now().Unix()
        mapping.Modified = mapping.Created
        mapping.Deleted = false

        // TODO: Store mapping in database
        // This will be implemented when database layer is updated
        logger.Info("Team assigned to project",
                zap.String("teamId", mapping.TeamID),
                zap.String("projectId", mapping.ProjectID))

        response := models.NewSuccessResponse(map[string]interface{}{"mapping": mapping})
        c.JSON(http.StatusOK, response)</span>
}

// TeamUnassignProject handles unassigning a team from a project
func (h *Handler) TeamUnassignProject(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get team ID and project ID from request data
        teamID, ok1 := req.Data["teamId"].(string)
        projectID, ok2 := req.Data["projectId"].(string)

        if !ok1 || !ok2 || teamID == "" || projectID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID and Project ID are required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Remove mapping from database (soft delete)
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Team unassigned from project",
                zap.String("teamId", teamID),
                zap.String("projectId", projectID))

        response := models.NewSuccessResponse(map[string]interface{}{
                "teamId":     teamID,
                "projectId":  projectID,
                "unassigned": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// TeamListProjects handles listing all projects for a team
func (h *Handler) TeamListProjects(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get team ID from request data
        teamID, ok := req.Data["teamId"].(string)
        if !ok || teamID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve projects from database for this team
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Team projects list requested", zap.String("teamId", teamID))

        // For now, return empty list
        projects := []interface{}{} // Will be replaced with proper Project model
        response := models.NewSuccessResponse(map[string]interface{}{"projects": projects, "count": len(projects)})
        c.JSON(http.StatusOK, response)</span>
}

// UserAssignOrganization handles assigning a user to an organization
func (h *Handler) UserAssignOrganization(c *gin.Context, req *models.Request) <span class="cov10" title="2">{
        // Parse the mapping data from request
        var mapping models.UserOrganizationMapping
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="2">if err := json.Unmarshal(dataBytes, &amp;mapping); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="2">if mapping.UserID == "" || mapping.OrganizationID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "User ID and Organization ID are required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov1" title="1">mapping.ID = uuid.New().String()
        mapping.Created = time.Now().Unix()
        mapping.Modified = mapping.Created
        mapping.Deleted = false

        // TODO: Store mapping in database
        // This will be implemented when database layer is updated
        logger.Info("User assigned to organization",
                zap.String("userId", mapping.UserID),
                zap.String("organizationId", mapping.OrganizationID))

        response := models.NewSuccessResponse(map[string]interface{}{"mapping": mapping})
        c.JSON(http.StatusOK, response)</span>
}

// UserListOrganizations handles listing all organizations for a user
func (h *Handler) UserListOrganizations(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get user ID from request data
        userID, ok := req.Data["userId"].(string)
        if !ok || userID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "User ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve organizations from database for this user
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("User organizations list requested", zap.String("userId", userID))

        // For now, return empty list
        organizations := []models.Organization{}
        response := models.NewSuccessResponse(map[string]interface{}{"organizations": organizations, "count": len(organizations)})
        c.JSON(http.StatusOK, response)</span>
}

// OrganizationListUsers handles listing all users in an organization
func (h *Handler) OrganizationListUsers(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get organization ID from request data
        organizationID, ok := req.Data["organizationId"].(string)
        if !ok || organizationID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Organization ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve users from database for this organization
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Organization users list requested", zap.String("organizationId", organizationID))

        // For now, return empty list
        users := []interface{}{} // Will be replaced with proper User model
        response := models.NewSuccessResponse(map[string]interface{}{"users": users, "count": len(users)})
        c.JSON(http.StatusOK, response)</span>
}

// UserAssignTeam handles assigning a user to a team
func (h *Handler) UserAssignTeam(c *gin.Context, req *models.Request) <span class="cov10" title="2">{
        // Parse the mapping data from request
        var mapping models.UserTeamMapping
        dataBytes, err := json.Marshal(req.Data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        <span class="cov10" title="2">if err := json.Unmarshal(dataBytes, &amp;mapping); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unmarshal mapping data", zap.Error(err))
                response := models.NewErrorResponse(models.ErrorCodeInvalidRequest, "Invalid mapping data format", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Validate required fields
        <span class="cov10" title="2">if mapping.UserID == "" || mapping.TeamID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "User ID and Team ID are required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // Generate ID and timestamps
        <span class="cov1" title="1">mapping.ID = uuid.New().String()
        mapping.Created = time.Now().Unix()
        mapping.Modified = mapping.Created
        mapping.Deleted = false

        // TODO: Store mapping in database
        // This will be implemented when database layer is updated
        logger.Info("User assigned to team",
                zap.String("userId", mapping.UserID),
                zap.String("teamId", mapping.TeamID))

        response := models.NewSuccessResponse(map[string]interface{}{"mapping": mapping})
        c.JSON(http.StatusOK, response)</span>
}

// UserListTeams handles listing all teams for a user
func (h *Handler) UserListTeams(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        // Get user ID from request data
        userID, ok := req.Data["userId"].(string)
        if !ok || userID == "" </span><span class="cov0" title="0">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "User ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve teams from database for this user
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("User teams list requested", zap.String("userId", userID))

        // For now, return empty list
        teams := []models.Team{}
        response := models.NewSuccessResponse(map[string]interface{}{"teams": teams, "count": len(teams)})
        c.JSON(http.StatusOK, response)</span>
}

// TeamListUsers handles listing all users in a team
func (h *Handler) TeamListUsers(c *gin.Context, req *models.Request) <span class="cov10" title="2">{
        // Get team ID from request data
        teamID, ok := req.Data["teamId"].(string)
        if !ok || teamID == "" </span><span class="cov1" title="1">{
                response := models.NewErrorResponse(models.ErrorCodeMissingData, "Team ID is required", "")
                c.JSON(http.StatusBadRequest, response)
                return
        }</span>

        // TODO: Retrieve users from database for this team
        // This will be implemented when database layer is updated
        <span class="cov1" title="1">logger.Info("Team users list requested", zap.String("teamId", teamID))

        // For now, return empty list
        users := []interface{}{} // Will be replaced with proper User model
        response := models.NewSuccessResponse(map[string]interface{}{"users": users, "count": len(users)})
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleCreateTicket creates a new ticket
func (h *Handler) handleCreateTicket(c *gin.Context, req *models.Request) <span class="cov10" title="47">{
        ticketData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov10" title="47">{
                ticketData = req.Data
        }</span>

        <span class="cov10" title="47">projectID, _ := ticketData["project_id"].(string)
        if projectID == "" </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing project_id",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="45">title, _ := ticketData["title"].(string)
        if title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="44">description, _ := ticketData["description"].(string)
        ticketTypeStr, _ := ticketData["type"].(string)
        if ticketTypeStr == "" </span><span class="cov9" title="36">{
                ticketTypeStr = "task"
        }</span>

        <span class="cov9" title="44">priority, _ := ticketData["priority"].(string)

        // Get ticket type ID
        var ticketTypeID string
        err := h.db.QueryRow(context.Background(),
                "SELECT id FROM ticket_type WHERE title = ? AND deleted = 0",
                ticketTypeStr).Scan(&amp;ticketTypeID)

        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Ticket type not found", zap.Error(err), zap.String("type", ticketTypeStr))
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "Invalid ticket type",
                        "",
                ))
                return
        }</span>

        // Get default status (open)
        <span class="cov9" title="43">var ticketStatusID string
        err = h.db.QueryRow(context.Background(),
                "SELECT id FROM ticket_status WHERE title = 'open' AND deleted = 0").Scan(&amp;ticketStatusID)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Default ticket status not found", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create ticket",
                        "",
                ))
                return
        }</span>

        // Get next ticket number for project
        <span class="cov9" title="43">var maxTicketNumber int
        err = h.db.QueryRow(context.Background(),
                "SELECT COALESCE(MAX(ticket_number), 0) FROM ticket WHERE project_id = ?",
                projectID).Scan(&amp;maxTicketNumber)
        if err != nil </span><span class="cov0" title="0">{
                maxTicketNumber = 0
        }</span>
        <span class="cov9" title="43">ticketNumber := maxTicketNumber + 1

        // Get username from context
        username, _ := middleware.GetUsername(c)

        // Create ticket
        ticketID := uuid.New().String()
        now := time.Now().Unix()

        query := `
                INSERT INTO ticket (id, ticket_number, position, title, description, created, modified, 
                                    ticket_type_id, ticket_status_id, project_id, user_id, 
                                    estimation, story_points, creator, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(
                context.Background(),
                query,
                ticketID,
                ticketNumber,
                0, // position
                title,
                description,
                now,
                now,
                ticketTypeID,
                ticketStatusID,
                projectID,
                nil, // user_id (not assigned yet)
                0.0, // estimation
                0,   // story_points
                username,
                0, // not deleted
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create ticket",
                        "",
                ))
                return
        }</span>

        // Publish ticket created event
        <span class="cov9" title="43">h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "ticket",
                ticketID,
                username,
                map[string]interface{}{
                        "id":            ticketID,
                        "ticket_number": ticketNumber,
                        "title":         title,
                        "description":   description,
                        "type":          ticketTypeStr,
                        "priority":      priority,
                        "status":        "open",
                        "project_id":    projectID,
                },
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticket": map[string]interface{}{
                        "id":            ticketID,
                        "ticket_number": ticketNumber,
                        "title":         title,
                        "description":   description,
                        "type":          ticketTypeStr,
                        "priority":      priority,
                        "status":        "open",
                        "project_id":    projectID,
                        "created":       now,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleModifyTicket updates an existing ticket
func (h *Handler) handleModifyTicket(c *gin.Context, req *models.Request) <span class="cov5" title="6">{
        ticketData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov5" title="6">{
                ticketData = req.Data
        }</span>

        <span class="cov5" title="6">ticketID, _ := ticketData["id"].(string)
        if ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Build update query
        <span class="cov4" title="5">updates := []string{}
        args := []interface{}{}

        if title, ok := ticketData["title"].(string); ok &amp;&amp; title != "" </span><span class="cov4" title="4">{
                updates = append(updates, "title = ?")
                args = append(args, title)
        }</span>

        <span class="cov4" title="5">if desc, ok := ticketData["description"].(string); ok </span><span class="cov2" title="2">{
                updates = append(updates, "description = ?")
                args = append(args, desc)
        }</span>

        <span class="cov4" title="5">if status, ok := ticketData["status"].(string); ok &amp;&amp; status != "" </span><span class="cov2" title="2">{
                // Get status ID
                var statusID string
                err := h.db.QueryRow(context.Background(),
                        "SELECT id FROM ticket_status WHERE title = ? AND deleted = 0", status).Scan(&amp;statusID)
                if err == nil </span><span class="cov2" title="2">{
                        updates = append(updates, "ticket_status_id = ?")
                        args = append(args, statusID)
                }</span>
        }

        <span class="cov4" title="5">if len(updates) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeInvalidData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Always update modified timestamp
        <span class="cov4" title="5">updates = append(updates, "modified = ?")
        args = append(args, time.Now().Unix())
        args = append(args, ticketID)

        // Check if ticket exists first
        var count int
        err := h.db.QueryRow(context.Background(),
                "SELECT COUNT(*) FROM ticket WHERE id = ? AND deleted = 0", ticketID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update ticket",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="4">query := fmt.Sprintf("UPDATE ticket SET %s WHERE id = ?", joinWithComma(updates))
        _, err = h.db.Exec(context.Background(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update ticket",
                        "",
                ))
                return
        }</span>

        // Get project_id for event context
        <span class="cov4" title="4">var projectID string
        err = h.db.QueryRow(context.Background(),
                "SELECT project_id FROM ticket WHERE id = ? AND deleted = 0", ticketID).Scan(&amp;projectID)

        // Get username from context
        username, _ := middleware.GetUsername(c)

        // Publish ticket updated event
        if err == nil </span><span class="cov4" title="4">{
                h.publisher.PublishEntityEvent(
                        models.ActionModify,
                        "ticket",
                        ticketID,
                        username,
                        ticketData,
                        websocket.NewProjectContext(projectID, []string{"READ"}),
                )
        }</span>

        <span class="cov4" title="4">response := models.NewSuccessResponse(map[string]interface{}{
                "ticket": map[string]interface{}{
                        "id":      ticketID,
                        "updated": true,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleRemoveTicket soft-deletes a ticket
func (h *Handler) handleRemoveTicket(c *gin.Context, req *models.Request) <span class="cov5" title="6">{
        ticketData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov5" title="6">{
                ticketData = req.Data
        }</span>

        <span class="cov5" title="6">ticketID, _ := ticketData["id"].(string)
        if ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Get project_id before deletion for event context
        <span class="cov4" title="5">var projectID string
        err := h.db.QueryRow(context.Background(),
                "SELECT project_id FROM ticket WHERE id = ? AND deleted = 0", ticketID).Scan(&amp;projectID)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Ticket not found", zap.Error(err))
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="4">query := "UPDATE ticket SET deleted = 1, modified = ? WHERE id = ?"
        _, err = h.db.Exec(context.Background(), query, time.Now().Unix(), ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete ticket", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete ticket",
                        "",
                ))
                return
        }</span>

        // Get username from context
        <span class="cov4" title="4">username, _ := middleware.GetUsername(c)

        // Publish ticket deleted event
        h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "ticket",
                ticketID,
                username,
                map[string]interface{}{
                        "id":         ticketID,
                        "project_id": projectID,
                },
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticket": map[string]interface{}{
                        "id":      ticketID,
                        "deleted": true,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleReadTicket retrieves a single ticket
func (h *Handler) handleReadTicket(c *gin.Context, req *models.Request) <span class="cov4" title="4">{
        ticketData, ok := req.Data["data"].(map[string]interface{})
        if !ok </span><span class="cov4" title="4">{
                ticketData = req.Data
        }</span>

        <span class="cov4" title="4">ticketID, _ := ticketData["id"].(string)
        if ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="3">query := `
                SELECT t.id, t.ticket_number, t.title, t.description, t.created, t.modified,
                       tt.title as type, ts.title as status, t.project_id
                FROM ticket t
                JOIN ticket_type tt ON t.ticket_type_id = tt.id
                JOIN ticket_status ts ON t.ticket_status_id = ts.id
                WHERE t.id = ? AND t.deleted = 0
        `

        var id, title, description, ticketType, status, projectID string
        var ticketNumber int
        var created, modified int64

        err := h.db.QueryRow(context.Background(), query, ticketID).Scan(
                &amp;id, &amp;ticketNumber, &amp;title, &amp;description, &amp;created, &amp;modified,
                &amp;ticketType, &amp;status, &amp;projectID)

        if err != nil </span><span class="cov2" title="2">{
                logger.Error("Ticket not found", zap.Error(err))
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">response := models.NewSuccessResponse(map[string]interface{}{
                "ticket": map[string]interface{}{
                        "id":            id,
                        "ticket_number": ticketNumber,
                        "title":         title,
                        "description":   description,
                        "type":          ticketType,
                        "status":        status,
                        "project_id":    projectID,
                        "created":       created,
                        "modified":      modified,
                },
        })

        c.JSON(http.StatusOK, response)</span>
}

// handleListTickets retrieves all tickets for a project
func (h *Handler) handleListTickets(c *gin.Context, req *models.Request) <span class="cov4" title="4">{
        // Get project_id from request data
        var projectID string
        if req.Data != nil </span><span class="cov4" title="4">{
                if data, ok := req.Data["data"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        projectID, _ = data["project_id"].(string)
                }</span> else<span class="cov4" title="4"> {
                        projectID, _ = req.Data["project_id"].(string)
                }</span>
        }

        <span class="cov4" title="4">query := `
                SELECT t.id, t.ticket_number, t.title, t.description, t.created, t.modified,
                       tt.title as type, ts.title as status, t.project_id
                FROM ticket t
                JOIN ticket_type tt ON t.ticket_type_id = tt.id
                JOIN ticket_status ts ON t.ticket_status_id = ts.id
                WHERE t.deleted = 0
        `

        var args []interface{}
        if projectID != "" </span><span class="cov1" title="1">{
                query += " AND t.project_id = ?"
                args = append(args, projectID)
        }</span>

        <span class="cov4" title="4">query += " ORDER BY t.created DESC"

        rows, err := h.db.Query(context.Background(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list tickets", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list tickets",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="4">defer rows.Close()

        tickets := []map[string]interface{}{}

        for rows.Next() </span><span class="cov5" title="6">{
                var id, title, description, ticketType, status, projID string
                var ticketNumber int
                var created, modified int64

                err := rows.Scan(&amp;id, &amp;ticketNumber, &amp;title, &amp;description, &amp;created, &amp;modified,
                        &amp;ticketType, &amp;status, &amp;projID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket", zap.Error(err))
                        continue</span>
                }

                <span class="cov5" title="6">tickets = append(tickets, map[string]interface{}{
                        "id":            id,
                        "ticket_number": ticketNumber,
                        "title":         title,
                        "description":   description,
                        "type":          ticketType,
                        "status":        status,
                        "project_id":    projID,
                        "created":       created,
                        "modified":      modified,
                })</span>
        }

        <span class="cov4" title="4">response := models.NewSuccessResponse(map[string]interface{}{
                "items": tickets,
                "total": len(tickets),
        })

        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// ===== Ticket Relationship Type CRUD Operations =====

// handleTicketRelationshipTypeCreate creates a new ticket relationship type
func (h *Handler) handleTicketRelationshipTypeCreate(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_relationship_type", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">relType := &amp;models.TicketRelationshipType{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        query := `
                INSERT INTO ticket_relationship_type (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                relType.ID,
                relType.Title,
                relType.Description,
                relType.Created,
                relType.Modified,
                relType.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ticket relationship type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create ticket relationship type",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket relationship type created",
                zap.String("relationship_type_id", relType.ID),
                zap.String("title", relType.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "relationship_type": relType,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleTicketRelationshipTypeRead reads a single ticket relationship type by ID
func (h *Handler) handleTicketRelationshipTypeRead(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">relationshipTypeID, ok := req.Data["id"].(string)
        if !ok || relationshipTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing relationship type ID",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">query := `
                SELECT id, title, description, created, modified, deleted
                FROM ticket_relationship_type
                WHERE id = ? AND deleted = 0
        `

        var relType models.TicketRelationshipType
        var description sql.NullString
        err := h.db.QueryRow(c.Request.Context(), query, relationshipTypeID).Scan(
                &amp;relType.ID,
                &amp;relType.Title,
                &amp;description,
                &amp;relType.Created,
                &amp;relType.Modified,
                &amp;relType.Deleted,
        )
        if description.Valid </span><span class="cov1" title="1">{
                relType.Description = description.String
        }</span>

        <span class="cov5" title="2">if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket relationship type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read ticket relationship type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read ticket relationship type",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket relationship type read",
                zap.String("relationship_type_id", relType.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "relationship_type": relType,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketRelationshipTypeList lists all ticket relationship types
func (h *Handler) handleTicketRelationshipTypeList(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">query := `
                SELECT id, title, description, created, modified, deleted
                FROM ticket_relationship_type
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list ticket relationship types", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list ticket relationship types",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="2">defer rows.Close()

        relTypes := make([]models.TicketRelationshipType, 0)
        for rows.Next() </span><span class="cov8" title="3">{
                var relType models.TicketRelationshipType
                var description sql.NullString
                err := rows.Scan(
                        &amp;relType.ID,
                        &amp;relType.Title,
                        &amp;description,
                        &amp;relType.Created,
                        &amp;relType.Modified,
                        &amp;relType.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket relationship type", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="3">if description.Valid </span><span class="cov0" title="0">{
                        relType.Description = description.String
                }</span>
                <span class="cov8" title="3">relTypes = append(relTypes, relType)</span>
        }

        <span class="cov5" title="2">logger.Info("Ticket relationship types listed",
                zap.Int("count", len(relTypes)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "relationship_types": relTypes,
                "count":              len(relTypes),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketRelationshipTypeModify updates an existing ticket relationship type
func (h *Handler) handleTicketRelationshipTypeModify(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_relationship_type", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">relationshipTypeID, ok := req.Data["id"].(string)
        if !ok || relationshipTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing relationship type ID",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">checkQuery := `SELECT COUNT(*) FROM ticket_relationship_type WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, relationshipTypeID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket relationship type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov1" title="1">{
                updates["title"] = title
        }</span>
        <span class="cov1" title="1">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>

        <span class="cov1" title="1">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := "UPDATE ticket_relationship_type SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov8" title="3">{
                if !first </span><span class="cov5" title="2">{
                        query += ", "
                }</span>
                <span class="cov8" title="3">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov1" title="1">query += " WHERE id = ?"
        args = append(args, relationshipTypeID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update ticket relationship type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update ticket relationship type",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket relationship type updated",
                zap.String("relationship_type_id", relationshipTypeID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      relationshipTypeID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketRelationshipTypeRemove soft-deletes a ticket relationship type
func (h *Handler) handleTicketRelationshipTypeRemove(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_relationship_type", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">relationshipTypeID, ok := req.Data["id"].(string)
        if !ok || relationshipTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing relationship type ID",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">query := `UPDATE ticket_relationship_type SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), relationshipTypeID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete ticket relationship type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete ticket relationship type",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket relationship type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket relationship type deleted",
                zap.String("relationship_type_id", relationshipTypeID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      relationshipTypeID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// ===== Ticket Relationship Operations =====

// handleTicketRelationshipCreate creates a new relationship between two tickets
func (h *Handler) handleTicketRelationshipCreate(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_relationship", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">ticketID, ok := req.Data["ticket_id"].(string)
        if !ok || ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">childTicketID, ok := req.Data["child_ticket_id"].(string)
        if !ok || childTicketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing child_ticket_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">relationshipTypeID, ok := req.Data["ticket_relationship_type_id"].(string)
        if !ok || relationshipTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket_relationship_type_id",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">relationship := &amp;models.TicketRelationship{
                ID:                       uuid.New().String(),
                TicketID:                 ticketID,
                ChildTicketID:            childTicketID,
                TicketRelationshipTypeID: relationshipTypeID,
                Created:                  time.Now().Unix(),
                Modified:                 time.Now().Unix(),
                Deleted:                  false,
        }

        query := `
                INSERT INTO ticket_relationship (id, ticket_id, child_ticket_id, ticket_relationship_type_id, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                relationship.ID,
                relationship.TicketID,
                relationship.ChildTicketID,
                relationship.TicketRelationshipTypeID,
                relationship.Created,
                relationship.Modified,
                relationship.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ticket relationship", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create ticket relationship",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket relationship created",
                zap.String("relationship_id", relationship.ID),
                zap.String("ticket_id", ticketID),
                zap.String("child_ticket_id", childTicketID),
                zap.String("relationship_type_id", relationshipTypeID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "relationship": relationship,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleTicketRelationshipRemove removes a relationship between two tickets
func (h *Handler) handleTicketRelationshipRemove(c *gin.Context, req *models.Request) <span class="cov5" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_relationship", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">relationshipID, ok := req.Data["id"].(string)
        if !ok || relationshipID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing relationship ID",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">query := `UPDATE ticket_relationship SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), relationshipID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove ticket relationship", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove ticket relationship",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket relationship not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket relationship removed",
                zap.String("relationship_id", relationshipID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      relationshipID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketRelationshipList lists all relationships for a ticket
func (h *Handler) handleTicketRelationshipList(c *gin.Context, req *models.Request) <span class="cov8" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="3">ticketID, ok := req.Data["ticket_id"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket_id",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="3">query := `
                SELECT id, ticket_id, child_ticket_id, ticket_relationship_type_id, created, modified, deleted
                FROM ticket_relationship
                WHERE (ticket_id = ? OR child_ticket_id = ?) AND deleted = 0
                ORDER BY created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, ticketID, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list ticket relationships", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list ticket relationships",
                        "",
                ))
                return
        }</span>
        <span class="cov8" title="3">defer rows.Close()

        relationships := make([]models.TicketRelationship, 0)
        for rows.Next() </span><span class="cov10" title="4">{
                var relationship models.TicketRelationship
                err := rows.Scan(
                        &amp;relationship.ID,
                        &amp;relationship.TicketID,
                        &amp;relationship.ChildTicketID,
                        &amp;relationship.TicketRelationshipTypeID,
                        &amp;relationship.Created,
                        &amp;relationship.Modified,
                        &amp;relationship.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket relationship", zap.Error(err))
                        continue</span>
                }
                <span class="cov10" title="4">relationships = append(relationships, relationship)</span>
        }

        <span class="cov8" title="3">logger.Info("Ticket relationships listed",
                zap.String("ticket_id", ticketID),
                zap.Int("count", len(relationships)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "relationships": relationships,
                "count":         len(relationships),
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleTicketStatusCreate creates a new ticket status
func (h *Handler) handleTicketStatusCreate(c *gin.Context, req *models.Request) <span class="cov10" title="10">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="10">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_status", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="10">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse ticket status data from request
        <span class="cov10" title="10">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="9">ticketStatus := &amp;models.TicketStatus{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO ticket_status (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                ticketStatus.ID,
                ticketStatus.Title,
                ticketStatus.Description,
                ticketStatus.Created,
                ticketStatus.Modified,
                ticketStatus.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ticket status", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create ticket status",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="9">logger.Info("Ticket status created",
                zap.String("ticket_status_id", ticketStatus.ID),
                zap.String("title", ticketStatus.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketStatus": ticketStatus,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleTicketStatusRead reads a single ticket status by ID
func (h *Handler) handleTicketStatusRead(c *gin.Context, req *models.Request) <span class="cov7" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket status ID from request
        <span class="cov7" title="5">ticketStatusID, ok := req.Data["id"].(string)
        if !ok || ticketStatusID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket status ID",
                        "",
                ))
                return
        }</span>

        // Query ticket status from database
        <span class="cov6" title="4">query := `
                SELECT id, title, description, created, modified, deleted
                FROM ticket_status
                WHERE id = ? AND deleted = 0
        `

        var ticketStatus models.TicketStatus
        err := h.db.QueryRow(c.Request.Context(), query, ticketStatusID).Scan(
                &amp;ticketStatus.ID,
                &amp;ticketStatus.Title,
                &amp;ticketStatus.Description,
                &amp;ticketStatus.Created,
                &amp;ticketStatus.Modified,
                &amp;ticketStatus.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket status not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read ticket status", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read ticket status",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Ticket status read",
                zap.String("ticket_status_id", ticketStatus.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketStatus": ticketStatus,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketStatusList lists all ticket statuses
func (h *Handler) handleTicketStatusList(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted ticket statuses ordered by title
        <span class="cov6" title="4">query := `
                SELECT id, title, description, created, modified, deleted
                FROM ticket_status
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list ticket statuses", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list ticket statuses",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="4">defer rows.Close()

        ticketStatuses := make([]models.TicketStatus, 0)
        for rows.Next() </span><span class="cov8" title="7">{
                var ticketStatus models.TicketStatus
                err := rows.Scan(
                        &amp;ticketStatus.ID,
                        &amp;ticketStatus.Title,
                        &amp;ticketStatus.Description,
                        &amp;ticketStatus.Created,
                        &amp;ticketStatus.Modified,
                        &amp;ticketStatus.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket status", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="7">ticketStatuses = append(ticketStatuses, ticketStatus)</span>
        }

        <span class="cov6" title="4">logger.Info("Ticket statuses listed",
                zap.Int("count", len(ticketStatuses)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketStatuses": ticketStatuses,
                "count":          len(ticketStatuses),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketStatusModify updates an existing ticket status
func (h *Handler) handleTicketStatusModify(c *gin.Context, req *models.Request) <span class="cov7" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_status", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get ticket status ID
        <span class="cov7" title="5">ticketStatusID, ok := req.Data["id"].(string)
        if !ok || ticketStatusID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket status ID",
                        "",
                ))
                return
        }</span>

        // Check if ticket status exists
        <span class="cov7" title="5">checkQuery := `SELECT COUNT(*) FROM ticket_status WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, ticketStatusID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket status not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov6" title="4">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov5" title="3">{
                updates["title"] = title
        }</span>
        <span class="cov6" title="4">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>

        <span class="cov6" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov5" title="3">query := "UPDATE ticket_status SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov8" title="7">{
                if !first </span><span class="cov6" title="4">{
                        query += ", "
                }</span>
                <span class="cov8" title="7">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov5" title="3">query += " WHERE id = ?"
        args = append(args, ticketStatusID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update ticket status", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update ticket status",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Ticket status updated",
                zap.String("ticket_status_id", ticketStatusID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      ticketStatusID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketStatusRemove soft-deletes a ticket status
func (h *Handler) handleTicketStatusRemove(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_status", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get ticket status ID
        <span class="cov5" title="3">ticketStatusID, ok := req.Data["id"].(string)
        if !ok || ticketStatusID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket status ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the ticket status
        <span class="cov5" title="3">query := `UPDATE ticket_status SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), ticketStatusID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete ticket status", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete ticket status",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket status not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Ticket status deleted",
                zap.String("ticket_status_id", ticketStatusID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      ticketStatusID,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleTicketTypeCreate creates a new ticket type
func (h *Handler) handleTicketTypeCreate(c *gin.Context, req *models.Request) <span class="cov9" title="9">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov9" title="9">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_type", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="9">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse ticket type data from request
        <span class="cov9" title="9">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">ticketType := &amp;models.TicketType{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Icon:        getStringFromData(req.Data, "icon"),
                Color:       getStringFromData(req.Data, "color"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO ticket_type (id, title, description, icon, color, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                ticketType.ID,
                ticketType.Title,
                ticketType.Description,
                ticketType.Icon,
                ticketType.Color,
                ticketType.Created,
                ticketType.Modified,
                ticketType.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ticket type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create ticket type",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">logger.Info("Ticket type created",
                zap.String("ticket_type_id", ticketType.ID),
                zap.String("title", ticketType.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketType": ticketType,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleTicketTypeRead reads a single ticket type by ID
func (h *Handler) handleTicketTypeRead(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket type ID from request
        <span class="cov6" title="4">ticketTypeID, ok := req.Data["id"].(string)
        if !ok || ticketTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket type ID",
                        "",
                ))
                return
        }</span>

        // Query ticket type from database
        <span class="cov6" title="4">query := `
                SELECT id, title, description, icon, color, created, modified, deleted
                FROM ticket_type
                WHERE id = ? AND deleted = 0
        `

        var ticketType models.TicketType
        err := h.db.QueryRow(c.Request.Context(), query, ticketTypeID).Scan(
                &amp;ticketType.ID,
                &amp;ticketType.Title,
                &amp;ticketType.Description,
                &amp;ticketType.Icon,
                &amp;ticketType.Color,
                &amp;ticketType.Created,
                &amp;ticketType.Modified,
                &amp;ticketType.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read ticket type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read ticket type",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Ticket type read",
                zap.String("ticket_type_id", ticketType.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketType": ticketType,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketTypeList lists all ticket types
func (h *Handler) handleTicketTypeList(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted ticket types ordered by title
        <span class="cov5" title="3">query := `
                SELECT id, title, description, icon, color, created, modified, deleted
                FROM ticket_type
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list ticket types", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list ticket types",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="3">defer rows.Close()

        ticketTypes := make([]models.TicketType, 0)
        for rows.Next() </span><span class="cov8" title="6">{
                var ticketType models.TicketType
                err := rows.Scan(
                        &amp;ticketType.ID,
                        &amp;ticketType.Title,
                        &amp;ticketType.Description,
                        &amp;ticketType.Icon,
                        &amp;ticketType.Color,
                        &amp;ticketType.Created,
                        &amp;ticketType.Modified,
                        &amp;ticketType.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket type", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="6">ticketTypes = append(ticketTypes, ticketType)</span>
        }

        <span class="cov5" title="3">logger.Info("Ticket types listed",
                zap.Int("count", len(ticketTypes)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketTypes": ticketTypes,
                "count":       len(ticketTypes),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketTypeModify updates an existing ticket type
func (h *Handler) handleTicketTypeModify(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov6" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_type", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get ticket type ID
        <span class="cov6" title="4">ticketTypeID, ok := req.Data["id"].(string)
        if !ok || ticketTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket type ID",
                        "",
                ))
                return
        }</span>

        // Check if ticket type exists
        <span class="cov6" title="4">checkQuery := `SELECT COUNT(*) FROM ticket_type WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, ticketTypeID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket type not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov5" title="3">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov1" title="1">{
                updates["title"] = title
        }</span>
        <span class="cov5" title="3">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>
        <span class="cov5" title="3">if icon, ok := req.Data["icon"].(string); ok </span><span class="cov3" title="2">{
                updates["icon"] = icon
        }</span>
        <span class="cov5" title="3">if color, ok := req.Data["color"].(string); ok </span><span class="cov5" title="3">{
                updates["color"] = color
        }</span>

        <span class="cov5" title="3">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov5" title="3">query := "UPDATE ticket_type SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov10" title="10">{
                if !first </span><span class="cov8" title="7">{
                        query += ", "
                }</span>
                <span class="cov10" title="10">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov5" title="3">query += " WHERE id = ?"
        args = append(args, ticketTypeID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update ticket type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update ticket type",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Ticket type updated",
                zap.String("ticket_type_id", ticketTypeID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      ticketTypeID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketTypeRemove soft-deletes a ticket type
func (h *Handler) handleTicketTypeRemove(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_type", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get ticket type ID
        <span class="cov5" title="3">ticketTypeID, ok := req.Data["id"].(string)
        if !ok || ticketTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket type ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the ticket type
        <span class="cov5" title="3">query := `UPDATE ticket_type SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), ticketTypeID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete ticket type", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete ticket type",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket type not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Ticket type deleted",
                zap.String("ticket_type_id", ticketTypeID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      ticketTypeID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketTypeAssign assigns a ticket type to a project
func (h *Handler) handleTicketTypeAssign(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_type", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov3" title="2">ticketTypeID, ok := req.Data["ticketTypeId"].(string)
        if !ok || ticketTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketTypeId",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing projectId",
                        "",
                ))
                return
        }</span>

        // Check if mapping already exists
        <span class="cov3" title="2">checkQuery := `SELECT COUNT(*) FROM ticket_type_project_mapping WHERE ticket_type_id = ? AND project_id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, ticketTypeID, projectID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check existing mapping", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check existing mapping",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if count &gt; 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeEntityAlreadyExists,
                        "Ticket type already assigned to this project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">mapping := &amp;models.TicketTypeProjectMapping{
                ID:           uuid.New().String(),
                TicketTypeID: ticketTypeID,
                ProjectID:    projectID,
                Created:      time.Now().Unix(),
                Deleted:      false,
        }

        // Insert into database
        query := `
                INSERT INTO ticket_type_project_mapping (id, ticket_type_id, project_id, created, deleted)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.TicketTypeID,
                mapping.ProjectID,
                mapping.Created,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to assign ticket type to project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to assign ticket type to project",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket type assigned to project",
                zap.String("ticket_type_id", ticketTypeID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "assigned": true,
                "mapping":  mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleTicketTypeUnassign unassigns a ticket type from a project
func (h *Handler) handleTicketTypeUnassign(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov3" title="2">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "ticket_type", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse data from request
        <span class="cov3" title="2">ticketTypeID, ok := req.Data["ticketTypeId"].(string)
        if !ok || ticketTypeID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketTypeId",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing projectId",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov3" title="2">query := `UPDATE ticket_type_project_mapping SET deleted = 1 WHERE ticket_type_id = ? AND project_id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, ticketTypeID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unassign ticket type from project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to unassign ticket type from project",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Ticket type assignment not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Ticket type unassigned from project",
                zap.String("ticket_type_id", ticketTypeID),
                zap.String("project_id", projectID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "unassigned": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleTicketTypeListByProject lists ticket types assigned to a project
func (h *Handler) handleTicketTypeListByProject(c *gin.Context, req *models.Request) <span class="cov3" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get project ID from request
        <span class="cov3" title="2">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing projectId",
                        "",
                ))
                return
        }</span>

        // Query ticket types assigned to the project
        <span class="cov3" title="2">query := `
                SELECT tt.id, tt.title, tt.description, tt.icon, tt.color, tt.created, tt.modified, tt.deleted
                FROM ticket_type tt
                INNER JOIN ticket_type_project_mapping ttpm ON tt.id = ttpm.ticket_type_id
                WHERE ttpm.project_id = ? AND tt.deleted = 0 AND ttpm.deleted = 0
                ORDER BY tt.title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query, projectID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list ticket types by project", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list ticket types by project",
                        "",
                ))
                return
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        ticketTypes := make([]models.TicketType, 0)
        for rows.Next() </span><span class="cov5" title="3">{
                var ticketType models.TicketType
                err := rows.Scan(
                        &amp;ticketType.ID,
                        &amp;ticketType.Title,
                        &amp;ticketType.Description,
                        &amp;ticketType.Icon,
                        &amp;ticketType.Color,
                        &amp;ticketType.Created,
                        &amp;ticketType.Modified,
                        &amp;ticketType.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan ticket type", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="3">ticketTypes = append(ticketTypes, ticketType)</span>
        }

        <span class="cov3" title="2">logger.Info("Ticket types by project listed",
                zap.String("project_id", projectID),
                zap.Int("count", len(ticketTypes)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "ticketTypes": ticketTypes,
                "count":       len(ticketTypes),
                "projectId":   projectID,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleVersionCreate creates a new version
func (h *Handler) handleVersionCreate(c *gin.Context, req *models.Request) <span class="cov8" title="6">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov8" title="6">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="6">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse version data from request
        <span class="cov8" title="6">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov4" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">projectID, ok := req.Data["projectId"].(string)
        if !ok || projectID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing projectId",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">version := &amp;models.Version{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                ProjectID:   projectID,
                Released:    false,
                Archived:    false,
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Handle optional start_date
        if startDate, ok := req.Data["startDate"].(float64); ok </span><span class="cov4" title="2">{
                timestamp := int64(startDate)
                version.StartDate = &amp;timestamp
        }</span>

        // Handle optional release_date
        <span class="cov5" title="3">if releaseDate, ok := req.Data["releaseDate"].(float64); ok </span><span class="cov4" title="2">{
                timestamp := int64(releaseDate)
                version.ReleaseDate = &amp;timestamp
        }</span>

        // Insert into database
        <span class="cov5" title="3">query := `
                INSERT INTO version (id, title, description, project_id, start_date, release_date, released, archived, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                version.ID,
                version.Title,
                version.Description,
                version.ProjectID,
                version.StartDate,
                version.ReleaseDate,
                version.Released,
                version.Archived,
                version.Created,
                version.Modified,
                version.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create version",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Version created",
                zap.String("version_id", version.ID),
                zap.String("title", version.Title),
                zap.String("project_id", version.ProjectID),
                zap.String("username", username),
        )

        // Publish version created event
        eventData := map[string]interface{}{
                "id":          version.ID,
                "title":       version.Title,
                "description": version.Description,
                "project_id":  version.ProjectID,
                "released":    version.Released,
                "archived":    version.Archived,
        }

        // Add nullable fields only if they have values (convert to float64 for JSON compatibility)
        if version.StartDate != nil </span><span class="cov4" title="2">{
                eventData["start_date"] = float64(*version.StartDate)
        }</span>
        <span class="cov5" title="3">if version.ReleaseDate != nil </span><span class="cov4" title="2">{
                eventData["release_date"] = float64(*version.ReleaseDate)
        }</span>

        <span class="cov5" title="3">h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "version",
                version.ID,
                username,
                eventData,
                websocket.NewProjectContext(version.ProjectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "version": version,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleVersionRead reads a single version by ID
func (h *Handler) handleVersionRead(c *gin.Context, req *models.Request) <span class="cov4" title="2">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get version ID from request
        <span class="cov4" title="2">versionID, ok := req.Data["id"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing version ID",
                        "",
                ))
                return
        }</span>

        // Query version from database
        <span class="cov4" title="2">query := `
                SELECT id, title, description, project_id, start_date, release_date, released, archived, created, modified, deleted
                FROM version
                WHERE id = ? AND deleted = 0
        `

        var version models.Version
        err := h.db.QueryRow(c.Request.Context(), query, versionID).Scan(
                &amp;version.ID,
                &amp;version.Title,
                &amp;version.Description,
                &amp;version.ProjectID,
                &amp;version.StartDate,
                &amp;version.ReleaseDate,
                &amp;version.Released,
                &amp;version.Archived,
                &amp;version.Created,
                &amp;version.Modified,
                &amp;version.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Version not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read version",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Version read",
                zap.String("version_id", version.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "version": version,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionList lists all versions, optionally filtered by project_id
func (h *Handler) handleVersionList(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check if filtering by project_id
        <span class="cov5" title="3">projectID, hasProjectFilter := req.Data["projectId"].(string)

        var query string
        var args []interface{}

        if hasProjectFilter &amp;&amp; projectID != "" </span><span class="cov1" title="1">{
                // Filter by project_id
                query = `
                        SELECT id, title, description, project_id, start_date, release_date, released, archived, created, modified, deleted
                        FROM version
                        WHERE project_id = ? AND deleted = 0
                        ORDER BY created DESC
                `
                args = append(args, projectID)
        }</span> else<span class="cov4" title="2"> {
                // List all versions
                query = `
                        SELECT id, title, description, project_id, start_date, release_date, released, archived, created, modified, deleted
                        FROM version
                        WHERE deleted = 0
                        ORDER BY created DESC
                `
        }</span>

        <span class="cov5" title="3">rows, err := h.db.Query(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list versions", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list versions",
                        "",
                ))
                return
        }</span>
        <span class="cov5" title="3">defer rows.Close()

        versions := make([]models.Version, 0)
        for rows.Next() </span><span class="cov7" title="4">{
                var version models.Version
                err := rows.Scan(
                        &amp;version.ID,
                        &amp;version.Title,
                        &amp;version.Description,
                        &amp;version.ProjectID,
                        &amp;version.StartDate,
                        &amp;version.ReleaseDate,
                        &amp;version.Released,
                        &amp;version.Archived,
                        &amp;version.Created,
                        &amp;version.Modified,
                        &amp;version.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan version", zap.Error(err))
                        continue</span>
                }
                <span class="cov7" title="4">versions = append(versions, version)</span>
        }

        <span class="cov5" title="3">logger.Info("Versions listed",
                zap.Int("count", len(versions)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "versions": versions,
                "count":    len(versions),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionModify updates an existing version
func (h *Handler) handleVersionModify(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get version ID
        <span class="cov7" title="4">versionID, ok := req.Data["id"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing version ID",
                        "",
                ))
                return
        }</span>

        // Check if version exists
        <span class="cov7" title="4">checkQuery := `SELECT COUNT(*) FROM version WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, versionID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov4" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Version not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov4" title="2">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov4" title="2">{
                updates["title"] = title
        }</span>
        <span class="cov4" title="2">if description, ok := req.Data["description"].(string); ok </span><span class="cov4" title="2">{
                updates["description"] = description
        }</span>
        <span class="cov4" title="2">if startDate, ok := req.Data["startDate"].(float64); ok </span><span class="cov0" title="0">{
                timestamp := int64(startDate)
                updates["start_date"] = &amp;timestamp
        }</span>
        <span class="cov4" title="2">if releaseDate, ok := req.Data["releaseDate"].(float64); ok </span><span class="cov4" title="2">{
                timestamp := int64(releaseDate)
                updates["release_date"] = &amp;timestamp
        }</span>

        <span class="cov4" title="2">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov4" title="2">query := "UPDATE version SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov10" title="8">{
                if !first </span><span class="cov8" title="6">{
                        query += ", "
                }</span>
                <span class="cov10" title="8">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov4" title="2">query += " WHERE id = ?"
        args = append(args, versionID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update version",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Version updated",
                zap.String("version_id", versionID),
                zap.String("username", username),
        )

        // Get project context for event publishing
        var projectID string
        contextQuery := `SELECT project_id FROM version WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), contextQuery, versionID).Scan(&amp;projectID)
        if err == nil </span><span class="cov4" title="2">{
                // Add project_id to event data
                eventData := make(map[string]interface{})
                for k, v := range updates </span><span class="cov10" title="8">{
                        eventData[k] = v
                }</span>
                <span class="cov4" title="2">eventData["id"] = versionID
                eventData["project_id"] = projectID

                // Publish version updated event
                h.publisher.PublishEntityEvent(
                        models.ActionModify,
                        "version",
                        versionID,
                        username,
                        eventData,
                        websocket.NewProjectContext(projectID, []string{"READ"}),
                )</span>
        }

        <span class="cov4" title="2">response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      versionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionRemove soft-deletes a version
func (h *Handler) handleVersionRemove(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get version ID
        <span class="cov7" title="4">versionID, ok := req.Data["id"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing version ID",
                        "",
                ))
                return
        }</span>

        // Read version data before deleting (for event publishing)
        <span class="cov7" title="4">readQuery := `SELECT id, title, description, project_id, start_date, release_date, released, archived
                      FROM version WHERE id = ? AND deleted = 0`
        var version models.Version
        var startDate, releaseDate sql.NullInt64
        err = h.db.QueryRow(c.Request.Context(), readQuery, versionID).Scan(
                &amp;version.ID,
                &amp;version.Title,
                &amp;version.Description,
                &amp;version.ProjectID,
                &amp;startDate,
                &amp;releaseDate,
                &amp;version.Released,
                &amp;version.Archived,
        )
        if err == sql.ErrNoRows </span><span class="cov4" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Version not found",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read version before deletion", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read version",
                        "",
                ))
                return
        }</span>

        // Convert nullable fields
        <span class="cov4" title="2">if startDate.Valid </span><span class="cov0" title="0">{
                val := startDate.Int64
                version.StartDate = &amp;val
        }</span>
        <span class="cov4" title="2">if releaseDate.Valid </span><span class="cov0" title="0">{
                val := releaseDate.Int64
                version.ReleaseDate = &amp;val
        }</span>

        // Soft delete the version
        <span class="cov4" title="2">query := `UPDATE version SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), versionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete version",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Version not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Version deleted",
                zap.String("version_id", versionID),
                zap.String("username", username),
        )

        // Publish version deleted event with full data
        eventData := map[string]interface{}{
                "id":          version.ID,
                "title":       version.Title,
                "description": version.Description,
                "project_id":  version.ProjectID,
                "released":    version.Released,
                "archived":    version.Archived,
        }
        if version.StartDate != nil </span><span class="cov0" title="0">{
                eventData["start_date"] = float64(*version.StartDate)
        }</span>
        <span class="cov4" title="2">if version.ReleaseDate != nil </span><span class="cov0" title="0">{
                eventData["release_date"] = float64(*version.ReleaseDate)
        }</span>

        <span class="cov4" title="2">h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "version",
                versionID,
                username,
                eventData,
                websocket.NewProjectContext(version.ProjectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      versionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionRelease marks a version as released
func (h *Handler) handleVersionRelease(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get version ID
        <span class="cov7" title="4">versionID, ok := req.Data["id"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing version ID",
                        "",
                ))
                return
        }</span>

        // Mark version as released and set release_date to now if not already set
        <span class="cov7" title="4">now := time.Now().Unix()
        query := `
                UPDATE version
                SET released = 1,
                    release_date = COALESCE(release_date, ?),
                    modified = ?
                WHERE id = ? AND deleted = 0
        `

        result, err := h.db.Exec(c.Request.Context(), query, now, now, versionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to release version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to release version",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov4" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Version not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Version released",
                zap.String("version_id", versionID),
                zap.String("username", username),
        )

        // Get version data for event publishing
        var title, projectID string
        var releaseDate *int64
        eventQuery := `SELECT title, project_id, release_date FROM version WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), eventQuery, versionID).Scan(&amp;title, &amp;projectID, &amp;releaseDate)
        if err == nil </span><span class="cov4" title="2">{
                // Publish version released event
                h.publisher.PublishEntityEvent(
                        models.ActionVersionRelease,
                        "version",
                        versionID,
                        username,
                        map[string]interface{}{
                                "id":           versionID,
                                "title":        title,
                                "project_id":   projectID,
                                "released":     true,
                                "release_date": releaseDate,
                        },
                        websocket.NewProjectContext(projectID, []string{"READ"}),
                )
        }</span>

        <span class="cov4" title="2">response := models.NewSuccessResponse(map[string]interface{}{
                "released": true,
                "id":       versionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionArchive archives a version
func (h *Handler) handleVersionArchive(c *gin.Context, req *models.Request) <span class="cov7" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="4">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get version ID
        <span class="cov7" title="4">versionID, ok := req.Data["id"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing version ID",
                        "",
                ))
                return
        }</span>

        // Mark version as archived
        <span class="cov7" title="4">query := `UPDATE version SET archived = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), versionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to archive version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to archive version",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="4">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov4" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Version not found",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="2">logger.Info("Version archived",
                zap.String("version_id", versionID),
                zap.String("username", username),
        )

        // Get version data for event publishing
        var title, projectID string
        eventQuery := `SELECT title, project_id FROM version WHERE id = ? AND deleted = 0`
        err = h.db.QueryRow(c.Request.Context(), eventQuery, versionID).Scan(&amp;title, &amp;projectID)
        if err == nil </span><span class="cov4" title="2">{
                // Publish version archived event
                h.publisher.PublishEntityEvent(
                        models.ActionVersionArchive,
                        "version",
                        versionID,
                        username,
                        map[string]interface{}{
                                "id":         versionID,
                                "title":      title,
                                "project_id": projectID,
                                "archived":   true,
                        },
                        websocket.NewProjectContext(projectID, []string{"READ"}),
                )
        }</span>

        <span class="cov4" title="2">response := models.NewSuccessResponse(map[string]interface{}{
                "archived": true,
                "id":       versionID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionAddAffected adds an affected version mapping to a ticket
func (h *Handler) handleVersionAddAffected(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse ticket and version IDs from request
        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">versionID, ok := req.Data["versionId"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing versionId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">mapping := &amp;models.TicketVersionMapping{
                ID:        uuid.New().String(),
                TicketID:  ticketID,
                VersionID: versionID,
                Created:   time.Now().Unix(),
                Deleted:   false,
        }

        // Insert into database
        query := `
                INSERT INTO ticket_affected_version_mapping (id, ticket_id, version_id, created, deleted)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.TicketID,
                mapping.VersionID,
                mapping.Created,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add affected version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add affected version",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Affected version added",
                zap.String("mapping_id", mapping.ID),
                zap.String("ticket_id", mapping.TicketID),
                zap.String("version_id", mapping.VersionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleVersionRemoveAffected removes an affected version mapping from a ticket
func (h *Handler) handleVersionRemoveAffected(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse ticket and version IDs from request
        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">versionID, ok := req.Data["versionId"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing versionId",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov1" title="1">query := `
                UPDATE ticket_affected_version_mapping
                SET deleted = 1
                WHERE ticket_id = ? AND version_id = ? AND deleted = 0
        `

        result, err := h.db.Exec(c.Request.Context(), query, ticketID, versionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove affected version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove affected version",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Affected version mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Affected version removed",
                zap.String("ticket_id", ticketID),
                zap.String("version_id", versionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionListAffected lists all affected versions for a ticket
func (h *Handler) handleVersionListAffected(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket ID from request
        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        // Query all affected versions for the ticket
        <span class="cov1" title="1">query := `
                SELECT v.id, v.title, v.description, v.project_id, v.start_date, v.release_date, v.released, v.archived, v.created, v.modified, v.deleted
                FROM version v
                INNER JOIN ticket_affected_version_mapping m ON v.id = m.version_id
                WHERE m.ticket_id = ? AND m.deleted = 0 AND v.deleted = 0
                ORDER BY v.created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list affected versions", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list affected versions",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        versions := make([]models.Version, 0)
        for rows.Next() </span><span class="cov1" title="1">{
                var version models.Version
                err := rows.Scan(
                        &amp;version.ID,
                        &amp;version.Title,
                        &amp;version.Description,
                        &amp;version.ProjectID,
                        &amp;version.StartDate,
                        &amp;version.ReleaseDate,
                        &amp;version.Released,
                        &amp;version.Archived,
                        &amp;version.Created,
                        &amp;version.Modified,
                        &amp;version.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan affected version", zap.Error(err))
                        continue</span>
                }
                <span class="cov1" title="1">versions = append(versions, version)</span>
        }

        <span class="cov1" title="1">logger.Info("Affected versions listed",
                zap.String("ticket_id", ticketID),
                zap.Int("count", len(versions)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "versions": versions,
                "count":    len(versions),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionAddFix adds a fix version mapping to a ticket
func (h *Handler) handleVersionAddFix(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse ticket and version IDs from request
        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">versionID, ok := req.Data["versionId"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing versionId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">mapping := &amp;models.TicketVersionMapping{
                ID:        uuid.New().String(),
                TicketID:  ticketID,
                VersionID: versionID,
                Created:   time.Now().Unix(),
                Deleted:   false,
        }

        // Insert into database
        query := `
                INSERT INTO ticket_fix_version_mapping (id, ticket_id, version_id, created, deleted)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                mapping.ID,
                mapping.TicketID,
                mapping.VersionID,
                mapping.Created,
                mapping.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add fix version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add fix version",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Fix version added",
                zap.String("mapping_id", mapping.ID),
                zap.String("ticket_id", mapping.TicketID),
                zap.String("version_id", mapping.VersionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "mapping": mapping,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleVersionRemoveFix removes a fix version mapping from a ticket
func (h *Handler) handleVersionRemoveFix(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov1" title="1">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "version", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse ticket and version IDs from request
        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">versionID, ok := req.Data["versionId"].(string)
        if !ok || versionID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing versionId",
                        "",
                ))
                return
        }</span>

        // Soft delete the mapping
        <span class="cov1" title="1">query := `
                UPDATE ticket_fix_version_mapping
                SET deleted = 1
                WHERE ticket_id = ? AND version_id = ? AND deleted = 0
        `

        result, err := h.db.Exec(c.Request.Context(), query, ticketID, versionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove fix version", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove fix version",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Fix version mapping not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Fix version removed",
                zap.String("ticket_id", ticketID),
                zap.String("version_id", versionID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed": true,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleVersionListFix lists all fix versions for a ticket
func (h *Handler) handleVersionListFix(c *gin.Context, req *models.Request) <span class="cov1" title="1">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket ID from request
        <span class="cov1" title="1">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticketId",
                        "",
                ))
                return
        }</span>

        // Query all fix versions for the ticket
        <span class="cov1" title="1">query := `
                SELECT v.id, v.title, v.description, v.project_id, v.start_date, v.release_date, v.released, v.archived, v.created, v.modified, v.deleted
                FROM version v
                INNER JOIN ticket_fix_version_mapping m ON v.id = m.version_id
                WHERE m.ticket_id = ? AND m.deleted = 0 AND v.deleted = 0
                ORDER BY v.created DESC
        `

        rows, err := h.db.Query(c.Request.Context(), query, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list fix versions", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list fix versions",
                        "",
                ))
                return
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        versions := make([]models.Version, 0)
        for rows.Next() </span><span class="cov1" title="1">{
                var version models.Version
                err := rows.Scan(
                        &amp;version.ID,
                        &amp;version.Title,
                        &amp;version.Description,
                        &amp;version.ProjectID,
                        &amp;version.StartDate,
                        &amp;version.ReleaseDate,
                        &amp;version.Released,
                        &amp;version.Archived,
                        &amp;version.Created,
                        &amp;version.Modified,
                        &amp;version.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan fix version", zap.Error(err))
                        continue</span>
                }
                <span class="cov1" title="1">versions = append(versions, version)</span>
        }

        <span class="cov1" title="1">logger.Info("Fix versions listed",
                zap.String("ticket_id", ticketID),
                zap.Int("count", len(versions)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "versions": versions,
                "count":    len(versions),
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/websocket"
)

// handleWatcherAdd adds a user as a watcher to a ticket
func (h *Handler) handleWatcherAdd(c *gin.Context, req *models.Request) <span class="cov10" title="15">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket ID from request
        <span class="cov10" title="15">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Get user ID from request (defaults to current user if not specified)
        <span class="cov9" title="14">userID, ok := req.Data["userId"].(string)
        if !ok || userID == "" </span><span class="cov1" title="1">{
                // Use current username as user ID (in production, you'd look up the user ID)
                userID = username
        }</span>

        // Check if already watching
        <span class="cov9" title="14">checkQuery := `
                SELECT COUNT(*) FROM ticket_watcher_mapping
                WHERE ticket_id = ? AND user_id = ? AND deleted = 0
        `
        var count int
        err := h.db.QueryRow(c.Request.Context(), checkQuery, ticketID, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check watcher status", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to check watcher status",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="14">if count &gt; 0 </span><span class="cov4" title="3">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeEntityAlreadyExists,
                        "Already watching this ticket",
                        "",
                ))
                return
        }</span>

        // Create watcher mapping
        <span class="cov8" title="11">watcher := &amp;models.TicketWatcherMapping{
                ID:       uuid.New().String(),
                TicketID: ticketID,
                UserID:   userID,
                Created:  time.Now().Unix(),
                Deleted:  false,
        }

        query := `
                INSERT INTO ticket_watcher_mapping (id, ticket_id, user_id, created, deleted)
                VALUES (?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                watcher.ID,
                watcher.TicketID,
                watcher.UserID,
                watcher.Created,
                watcher.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to add watcher", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to add watcher",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="11">logger.Info("Watcher added",
                zap.String("ticket_id", ticketID),
                zap.String("user_id", userID),
                zap.String("username", username),
        )

        // Get project context from ticket for event publishing
        var projectID string
        contextQuery := `SELECT project_id FROM ticket WHERE id = ? AND deleted = 0`
        _ = h.db.QueryRow(c.Request.Context(), contextQuery, ticketID).Scan(&amp;projectID)

        // Publish watcher added event
        h.publisher.PublishEntityEvent(
                models.ActionCreate,
                "watcher",
                watcher.ID,
                username,
                map[string]interface{}{
                        "id":        watcher.ID,
                        "ticket_id": ticketID,
                        "user_id":   userID,
                },
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "watcher": watcher,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleWatcherRemove removes a user as a watcher from a ticket
func (h *Handler) handleWatcherRemove(c *gin.Context, req *models.Request) <span class="cov7" title="7">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket ID from request
        <span class="cov7" title="7">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Get user ID from request (defaults to current user if not specified)
        <span class="cov6" title="6">userID, ok := req.Data["userId"].(string)
        if !ok || userID == "" </span><span class="cov1" title="1">{
                userID = username
        }</span>

        // Soft delete the watcher mapping
        <span class="cov6" title="6">query := `
                UPDATE ticket_watcher_mapping
                SET deleted = 1
                WHERE ticket_id = ? AND user_id = ? AND deleted = 0
        `

        result, err := h.db.Exec(c.Request.Context(), query, ticketID, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to remove watcher", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to remove watcher",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="6">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Watcher not found",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="4">logger.Info("Watcher removed",
                zap.String("ticket_id", ticketID),
                zap.String("user_id", userID),
                zap.String("username", username),
        )

        // Get project context from ticket for event publishing
        var projectID string
        contextQuery := `SELECT project_id FROM ticket WHERE id = ? AND deleted = 0`
        _ = h.db.QueryRow(c.Request.Context(), contextQuery, ticketID).Scan(&amp;projectID)

        // Publish watcher removed event
        h.publisher.PublishEntityEvent(
                models.ActionRemove,
                "watcher",
                ticketID+":"+userID, // Composite ID for watcher mapping
                username,
                map[string]interface{}{
                        "ticket_id": ticketID,
                        "user_id":   userID,
                },
                websocket.NewProjectContext(projectID, []string{"READ"}),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "removed": true,
                "ticketId": ticketID,
                "userId":   userID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleWatcherList lists all watchers for a ticket
func (h *Handler) handleWatcherList(c *gin.Context, req *models.Request) <span class="cov7" title="8">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get ticket ID from request
        <span class="cov7" title="8">ticketID, ok := req.Data["ticketId"].(string)
        if !ok || ticketID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing ticket ID",
                        "",
                ))
                return
        }</span>

        // Query all watchers for the ticket
        <span class="cov7" title="7">query := `
                SELECT id, ticket_id, user_id, created, deleted
                FROM ticket_watcher_mapping
                WHERE ticket_id = ? AND deleted = 0
                ORDER BY created ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query, ticketID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list watchers", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list watchers",
                        "",
                ))
                return
        }</span>
        <span class="cov7" title="7">defer rows.Close()

        watchers := make([]models.TicketWatcherMapping, 0)
        for rows.Next() </span><span class="cov8" title="9">{
                var watcher models.TicketWatcherMapping
                err := rows.Scan(
                        &amp;watcher.ID,
                        &amp;watcher.TicketID,
                        &amp;watcher.UserID,
                        &amp;watcher.Created,
                        &amp;watcher.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan watcher", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="9">watchers = append(watchers, watcher)</span>
        }

        <span class="cov7" title="7">logger.Info("Watchers listed",
                zap.String("ticket_id", ticketID),
                zap.Int("count", len(watchers)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "watchers": watchers,
                "count":    len(watchers),
                "ticketId": ticketID,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleWorkflowCreate creates a new workflow
func (h *Handler) handleWorkflowCreate(c *gin.Context, req *models.Request) <span class="cov10" title="15">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov9" title="14">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "workflow", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="14">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse workflow data from request
        <span class="cov9" title="14">title, ok := req.Data["title"].(string)
        if !ok || title == "" </span><span class="cov3" title="2">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing title",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="12">workflow := &amp;models.Workflow{
                ID:          uuid.New().String(),
                Title:       title,
                Description: getStringFromData(req.Data, "description"),
                Created:     time.Now().Unix(),
                Modified:    time.Now().Unix(),
                Deleted:     false,
        }

        // Insert into database
        query := `
                INSERT INTO workflow (id, title, description, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                workflow.ID,
                workflow.Title,
                workflow.Description,
                workflow.Created,
                workflow.Modified,
                workflow.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create workflow", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create workflow",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="12">logger.Info("Workflow created",
                zap.String("workflow_id", workflow.ID),
                zap.String("title", workflow.Title),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "workflow": workflow,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleWorkflowRead reads a single workflow by ID
func (h *Handler) handleWorkflowRead(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get workflow ID from request
        <span class="cov4" title="3">workflowID, ok := req.Data["id"].(string)
        if !ok || workflowID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing workflow ID",
                        "",
                ))
                return
        }</span>

        // Query workflow from database
        <span class="cov3" title="2">query := `
                SELECT id, title, description, created, modified, deleted
                FROM workflow
                WHERE id = ? AND deleted = 0
        `

        var workflow models.Workflow
        err := h.db.QueryRow(c.Request.Context(), query, workflowID).Scan(
                &amp;workflow.ID,
                &amp;workflow.Title,
                &amp;workflow.Description,
                &amp;workflow.Created,
                &amp;workflow.Modified,
                &amp;workflow.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Workflow not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read workflow", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read workflow",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Workflow read",
                zap.String("workflow_id", workflow.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "workflow": workflow,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleWorkflowList lists all workflows
func (h *Handler) handleWorkflowList(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Query all non-deleted workflows ordered by title
        <span class="cov4" title="3">query := `
                SELECT id, title, description, created, modified, deleted
                FROM workflow
                WHERE deleted = 0
                ORDER BY title ASC
        `

        rows, err := h.db.Query(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list workflows", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list workflows",
                        "",
                ))
                return
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        workflows := make([]models.Workflow, 0)
        for rows.Next() </span><span class="cov5" title="4">{
                var workflow models.Workflow
                err := rows.Scan(
                        &amp;workflow.ID,
                        &amp;workflow.Title,
                        &amp;workflow.Description,
                        &amp;workflow.Created,
                        &amp;workflow.Modified,
                        &amp;workflow.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan workflow", zap.Error(err))
                        continue</span>
                }
                <span class="cov5" title="4">workflows = append(workflows, workflow)</span>
        }

        <span class="cov4" title="3">logger.Info("Workflows listed",
                zap.Int("count", len(workflows)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "workflows": workflows,
                "count":     len(workflows),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleWorkflowModify updates an existing workflow
func (h *Handler) handleWorkflowModify(c *gin.Context, req *models.Request) <span class="cov6" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov6" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "workflow", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov6" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get workflow ID
        <span class="cov6" title="5">workflowID, ok := req.Data["id"].(string)
        if !ok || workflowID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing workflow ID",
                        "",
                ))
                return
        }</span>

        // Check if workflow exists
        <span class="cov5" title="4">checkQuery := `SELECT COUNT(*) FROM workflow WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, workflowID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Workflow not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov4" title="3">updates := make(map[string]interface{})

        if title, ok := req.Data["title"].(string); ok &amp;&amp; title != "" </span><span class="cov3" title="2">{
                updates["title"] = title
        }</span>
        <span class="cov4" title="3">if description, ok := req.Data["description"].(string); ok </span><span class="cov1" title="1">{
                updates["description"] = description
        }</span>

        <span class="cov4" title="3">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov3" title="2">query := "UPDATE workflow SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov6" title="5">{
                if !first </span><span class="cov4" title="3">{
                        query += ", "
                }</span>
                <span class="cov6" title="5">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov3" title="2">query += " WHERE id = ?"
        args = append(args, workflowID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update workflow", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update workflow",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Workflow updated",
                zap.String("workflow_id", workflowID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      workflowID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleWorkflowRemove soft-deletes a workflow
func (h *Handler) handleWorkflowRemove(c *gin.Context, req *models.Request) <span class="cov5" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov1" title="1">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov4" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "workflow", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov4" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get workflow ID
        <span class="cov4" title="3">workflowID, ok := req.Data["id"].(string)
        if !ok || workflowID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing workflow ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the workflow
        <span class="cov3" title="2">query := `UPDATE workflow SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), workflowID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete workflow", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete workflow",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Workflow not found",
                        "",
                ))
                return
        }</span>

        <span class="cov1" title="1">logger.Info("Workflow deleted",
                zap.String("workflow_id", workflowID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      workflowID,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
)

// handleWorkflowStepCreate creates a new workflow step
func (h *Handler) handleWorkflowStepCreate(c *gin.Context, req *models.Request) <span class="cov10" title="9">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov10" title="9">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "workflow_step", models.PermissionCreate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov10" title="9">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Parse workflow step data from request
        <span class="cov10" title="9">workflowID, ok := req.Data["workflowId"].(string)
        if !ok || workflowID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing workflowId",
                        "",
                ))
                return
        }</span>

        <span class="cov9" title="8">statusID, ok := req.Data["statusId"].(string)
        if !ok || statusID == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing statusId",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="7">position, ok := req.Data["position"].(float64) // JSON numbers are float64
        if !ok </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing position",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="6">workflowStep := &amp;models.WorkflowStep{
                ID:         uuid.New().String(),
                WorkflowID: workflowID,
                StatusID:   statusID,
                Position:   int(position),
                Created:    time.Now().Unix(),
                Modified:   time.Now().Unix(),
                Deleted:    false,
        }

        // Insert into database
        query := `
                INSERT INTO workflow_step (id, workflow_id, status_id, position, created, modified, deleted)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err = h.db.Exec(c.Request.Context(), query,
                workflowStep.ID,
                workflowStep.WorkflowID,
                workflowStep.StatusID,
                workflowStep.Position,
                workflowStep.Created,
                workflowStep.Modified,
                workflowStep.Deleted,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create workflow step", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to create workflow step",
                        "",
                ))
                return
        }</span>

        <span class="cov8" title="6">logger.Info("Workflow step created",
                zap.String("workflow_step_id", workflowStep.ID),
                zap.String("workflow_id", workflowStep.WorkflowID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "workflowStep": workflowStep,
        })
        c.JSON(http.StatusCreated, response)</span>
}

// handleWorkflowStepRead reads a single workflow step by ID
func (h *Handler) handleWorkflowStepRead(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get workflow step ID from request
        <span class="cov6" title="4">workflowStepID, ok := req.Data["id"].(string)
        if !ok || workflowStepID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing workflow step ID",
                        "",
                ))
                return
        }</span>

        // Query workflow step from database
        <span class="cov6" title="4">query := `
                SELECT id, workflow_id, status_id, position, created, modified, deleted
                FROM workflow_step
                WHERE id = ? AND deleted = 0
        `

        var workflowStep models.WorkflowStep
        err := h.db.QueryRow(c.Request.Context(), query, workflowStepID).Scan(
                &amp;workflowStep.ID,
                &amp;workflowStep.WorkflowID,
                &amp;workflowStep.StatusID,
                &amp;workflowStep.Position,
                &amp;workflowStep.Created,
                &amp;workflowStep.Modified,
                &amp;workflowStep.Deleted,
        )

        if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Workflow step not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read workflow step", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to read workflow step",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Workflow step read",
                zap.String("workflow_step_id", workflowStep.ID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "workflowStep": workflowStep,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleWorkflowStepList lists all workflow steps for a workflow
func (h *Handler) handleWorkflowStepList(c *gin.Context, req *models.Request) <span class="cov6" title="4">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Get optional workflow ID filter
        <span class="cov6" title="4">workflowID := getStringFromData(req.Data, "workflowId")

        // Query workflow steps
        var query string
        var args []interface{}

        if workflowID != "" </span><span class="cov3" title="2">{
                query = `
                        SELECT id, workflow_id, status_id, position, created, modified, deleted
                        FROM workflow_step
                        WHERE workflow_id = ? AND deleted = 0
                        ORDER BY position ASC
                `
                args = append(args, workflowID)
        }</span> else<span class="cov3" title="2"> {
                query = `
                        SELECT id, workflow_id, status_id, position, created, modified, deleted
                        FROM workflow_step
                        WHERE deleted = 0
                        ORDER BY workflow_id, position ASC
                `
        }</span>

        <span class="cov6" title="4">rows, err := h.db.Query(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list workflow steps", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to list workflow steps",
                        "",
                ))
                return
        }</span>
        <span class="cov6" title="4">defer rows.Close()

        workflowSteps := make([]models.WorkflowStep, 0)
        for rows.Next() </span><span class="cov8" title="7">{
                var workflowStep models.WorkflowStep
                err := rows.Scan(
                        &amp;workflowStep.ID,
                        &amp;workflowStep.WorkflowID,
                        &amp;workflowStep.StatusID,
                        &amp;workflowStep.Position,
                        &amp;workflowStep.Created,
                        &amp;workflowStep.Modified,
                        &amp;workflowStep.Deleted,
                )
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan workflow step", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="7">workflowSteps = append(workflowSteps, workflowStep)</span>
        }

        <span class="cov6" title="4">logger.Info("Workflow steps listed",
                zap.Int("count", len(workflowSteps)),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "workflowSteps": workflowSteps,
                "count":         len(workflowSteps),
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleWorkflowStepModify updates an existing workflow step
func (h *Handler) handleWorkflowStepModify(c *gin.Context, req *models.Request) <span class="cov7" title="5">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov7" title="5">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "workflow_step", models.PermissionUpdate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov7" title="5">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get workflow step ID
        <span class="cov7" title="5">workflowStepID, ok := req.Data["id"].(string)
        if !ok || workflowStepID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing workflow step ID",
                        "",
                ))
                return
        }</span>

        // Check if workflow step exists
        <span class="cov7" title="5">checkQuery := `SELECT COUNT(*) FROM workflow_step WHERE id = ? AND deleted = 0`
        var count int
        err = h.db.QueryRow(c.Request.Context(), checkQuery, workflowStepID).Scan(&amp;count)
        if err != nil || count == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Workflow step not found",
                        "",
                ))
                return
        }</span>

        // Build update query dynamically based on provided fields
        <span class="cov6" title="4">updates := make(map[string]interface{})

        if statusID, ok := req.Data["statusId"].(string); ok &amp;&amp; statusID != "" </span><span class="cov1" title="1">{
                updates["status_id"] = statusID
        }</span>
        <span class="cov6" title="4">if position, ok := req.Data["position"].(float64); ok </span><span class="cov5" title="3">{
                updates["position"] = int(position)
        }</span>

        <span class="cov6" title="4">updates["modified"] = time.Now().Unix()

        if len(updates) == 1 </span><span class="cov1" title="1">{ // Only modified was set
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "No fields to update",
                        "",
                ))
                return
        }</span>

        // Build and execute update query
        <span class="cov5" title="3">query := "UPDATE workflow_step SET "
        args := make([]interface{}, 0)
        first := true

        for key, value := range updates </span><span class="cov8" title="7">{
                if !first </span><span class="cov6" title="4">{
                        query += ", "
                }</span>
                <span class="cov8" title="7">query += key + " = ?"
                args = append(args, value)
                first = false</span>
        }

        <span class="cov5" title="3">query += " WHERE id = ?"
        args = append(args, workflowStepID)

        _, err = h.db.Exec(c.Request.Context(), query, args...)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update workflow step", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to update workflow step",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">logger.Info("Workflow step updated",
                zap.String("workflow_step_id", workflowStepID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "updated": true,
                "id":      workflowStepID,
        })
        c.JSON(http.StatusOK, response)</span>
}

// handleWorkflowStepRemove soft-deletes a workflow step
func (h *Handler) handleWorkflowStepRemove(c *gin.Context, req *models.Request) <span class="cov5" title="3">{
        username, exists := middleware.GetUsername(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeUnauthorized,
                        "Unauthorized",
                        "",
                ))
                return
        }</span>

        // Check permissions
        <span class="cov5" title="3">allowed, err := h.permService.CheckPermission(c.Request.Context(), username, "workflow_step", models.PermissionDelete)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Permission check failed", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodePermissionServiceError,
                        "Permission check failed",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">if !allowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, models.NewErrorResponse(
                        models.ErrorCodeForbidden,
                        "Insufficient permission",
                        "",
                ))
                return
        }</span>

        // Get workflow step ID
        <span class="cov5" title="3">workflowStepID, ok := req.Data["id"].(string)
        if !ok || workflowStepID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                        models.ErrorCodeMissingData,
                        "Missing workflow step ID",
                        "",
                ))
                return
        }</span>

        // Soft delete the workflow step
        <span class="cov5" title="3">query := `UPDATE workflow_step SET deleted = 1, modified = ? WHERE id = ? AND deleted = 0`
        result, err := h.db.Exec(c.Request.Context(), query, time.Now().Unix(), workflowStepID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete workflow step", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                        models.ErrorCodeInternalError,
                        "Failed to delete workflow step",
                        "",
                ))
                return
        }</span>

        <span class="cov5" title="3">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, models.NewErrorResponse(
                        models.ErrorCodeEntityNotFound,
                        "Workflow step not found",
                        "",
                ))
                return
        }</span>

        <span class="cov3" title="2">logger.Info("Workflow step deleted",
                zap.String("workflow_step_id", workflowStepID),
                zap.String("username", username),
        )

        response := models.NewSuccessResponse(map[string]interface{}{
                "deleted": true,
                "id":      workflowStepID,
        })
        c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package logger

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
        "helixtrack.ru/core/internal/config"
)

var (
        globalLogger *zap.Logger
        sugared      *zap.SugaredLogger
)

// Initialize initializes the global logger with the given configuration
func Initialize(cfg config.LogConfig) error <span class="cov8" title="9">{
        // Create log directory if it doesn't exist
        if err := os.MkdirAll(cfg.LogPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        // Determine log level
        <span class="cov8" title="9">level := zapcore.InfoLevel
        if cfg.Level != "" </span><span class="cov8" title="9">{
                if err := level.UnmarshalText([]byte(cfg.Level)); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid log level '%s': %w", cfg.Level, err)
                }</span>
        }

        // Configure encoder
        <span class="cov8" title="8">encoderConfig := zap.NewProductionEncoderConfig()
        encoderConfig.TimeKey = "timestamp"
        encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder

        // Determine log file path
        logFilePath := filepath.Join(cfg.LogPath, "htCore.log")
        if cfg.LogfileBaseName != "" </span><span class="cov7" title="7">{
                logFilePath = filepath.Join(cfg.LogPath, cfg.LogfileBaseName+".log")
        }</span>

        // Configure log rotation with lumberjack
        <span class="cov8" title="8">fileWriter := &amp;lumberjack.Logger{
                Filename:   logFilePath,
                MaxSize:    int(cfg.LogSizeLimit / 1024 / 1024), // Convert bytes to MB
                MaxBackups: 3,
                MaxAge:     28, // days
                Compress:   true,
        }

        // Create core that writes to both file and console
        fileCore := zapcore.NewCore(
                zapcore.NewJSONEncoder(encoderConfig),
                zapcore.AddSync(fileWriter),
                level,
        )

        consoleCore := zapcore.NewCore(
                zapcore.NewConsoleEncoder(encoderConfig),
                zapcore.AddSync(os.Stdout),
                level,
        )

        // Combine cores
        core := zapcore.NewTee(fileCore, consoleCore)

        // Create logger
        globalLogger = zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))
        sugared = globalLogger.Sugar()

        return nil</span>
}

// Get returns the global logger instance
func Get() *zap.Logger <span class="cov10" title="14">{
        if globalLogger == nil </span><span class="cov3" title="2">{
                // Fallback to a default logger if not initialized
                globalLogger, _ = zap.NewProduction()
                sugared = globalLogger.Sugar()
        }</span>
        <span class="cov10" title="14">return globalLogger</span>
}

// GetSugared returns the global sugared logger instance
func GetSugared() *zap.SugaredLogger <span class="cov7" title="6">{
        if sugared == nil </span><span class="cov1" title="1">{
                Get() // Initialize if not already done
        }</span>
        <span class="cov7" title="6">return sugared</span>
}

// Sync flushes any buffered log entries
func Sync() error <span class="cov8" title="9">{
        if globalLogger != nil </span><span class="cov8" title="8">{
                err := globalLogger.Sync()
                // Ignore "sync /dev/stdout: invalid argument" and "sync /dev/stderr: invalid argument" errors
                // These are expected on Linux and other Unix-like systems
                if err != nil &amp;&amp; (strings.Contains(err.Error(), "sync /dev/stdout") ||
                        strings.Contains(err.Error(), "sync /dev/stderr") ||
                        errors.Is(err, os.ErrInvalid)) </span><span class="cov8" title="8">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// Debug logs a debug message
func Debug(msg string, fields ...zap.Field) <span class="cov1" title="1">{
        Get().Debug(msg, fields...)
}</span>

// Info logs an info message
func Info(msg string, fields ...zap.Field) <span class="cov7" title="6">{
        Get().Info(msg, fields...)
}</span>

// Warn logs a warning message
func Warn(msg string, fields ...zap.Field) <span class="cov3" title="2">{
        Get().Warn(msg, fields...)
}</span>

// Error logs an error message
func Error(msg string, fields ...zap.Field) <span class="cov3" title="2">{
        Get().Error(msg, fields...)
}</span>

// Fatal logs a fatal message and exits
func Fatal(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Get().Fatal(msg, fields...)
}</span>

// Debugf logs a debug message with fmt.Sprintf-style formatting
func Debugf(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Debugf(template, args...)
}</span>

// Infof logs an info message with fmt.Sprintf-style formatting
func Infof(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Infof(template, args...)
}</span>

// Warnf logs a warning message with fmt.Sprintf-style formatting
func Warnf(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Warnf(template, args...)
}</span>

// Errorf logs an error message with fmt.Sprintf-style formatting
func Errorf(template string, args ...interface{}) <span class="cov1" title="1">{
        GetSugared().Errorf(template, args...)
}</span>

// Fatalf logs a fatal message with fmt.Sprintf-style formatting and exits
func Fatalf(template string, args ...interface{}) <span class="cov0" title="0">{
        GetSugared().Fatalf(template, args...)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package metrics

import (
        "sync"
        "sync/atomic"
        "time"

        "github.com/gin-gonic/gin"
)

// Metrics collects application performance metrics
type Metrics struct {
        // Request metrics
        totalRequests       int64
        successfulRequests  int64
        failedRequests      int64
        totalRequestTime    int64 // nanoseconds
        minRequestTime      int64 // nanoseconds
        maxRequestTime      int64 // nanoseconds

        // Status code counts
        status2xx           int64
        status3xx           int64
        status4xx           int64
        status5xx           int64

        // Endpoint metrics
        endpointMetrics     map[string]*EndpointMetrics
        endpointMu          sync.RWMutex

        // System metrics
        startTime           time.Time
        lastRequestTime     time.Time
        lastRequestMu       sync.RWMutex
}

// EndpointMetrics contains metrics for a specific endpoint
type EndpointMetrics struct {
        Path              string
        Method            string
        Count             int64
        TotalTime         int64 // nanoseconds
        MinTime           int64 // nanoseconds
        MaxTime           int64 // nanoseconds
        Status2xx         int64
        Status3xx         int64
        Status4xx         int64
        Status5xx         int64
}

// MetricsSummary contains summarized metrics
type MetricsSummary struct {
        TotalRequests      int64         `json:"total_requests"`
        SuccessfulRequests int64         `json:"successful_requests"`
        FailedRequests     int64         `json:"failed_requests"`
        AvgRequestTime     time.Duration `json:"avg_request_time"`
        MinRequestTime     time.Duration `json:"min_request_time"`
        MaxRequestTime     time.Duration `json:"max_request_time"`
        RequestsPerSecond  float64       `json:"requests_per_second"`
        Status2xx          int64         `json:"status_2xx"`
        Status3xx          int64         `json:"status_3xx"`
        Status4xx          int64         `json:"status_4xx"`
        Status5xx          int64         `json:"status_5xx"`
        Uptime             time.Duration `json:"uptime"`
        LastRequestTime    time.Time     `json:"last_request_time"`
        Endpoints          []*EndpointMetrics `json:"endpoints,omitempty"`
}

// NewMetrics creates a new metrics collector
func NewMetrics() *Metrics <span class="cov5" title="13">{
        return &amp;Metrics{
                endpointMetrics: make(map[string]*EndpointMetrics),
                startTime:       time.Now(),
                minRequestTime:  int64(^uint64(0) &gt;&gt; 1), // Max int64
        }
}</span>

// RecordRequest records a request
func (m *Metrics) RecordRequest(duration time.Duration, statusCode int, path, method string) <span class="cov10" title="225">{
        durationNs := duration.Nanoseconds()

        // Update total counts
        atomic.AddInt64(&amp;m.totalRequests, 1)

        if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 </span><span class="cov9" title="221">{
                atomic.AddInt64(&amp;m.successfulRequests, 1)
                atomic.AddInt64(&amp;m.status2xx, 1)
        }</span> else<span class="cov3" title="4"> if statusCode &gt;= 300 &amp;&amp; statusCode &lt; 400 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;m.status3xx, 1)
        }</span> else<span class="cov2" title="3"> if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 </span><span class="cov2" title="2">{
                atomic.AddInt64(&amp;m.failedRequests, 1)
                atomic.AddInt64(&amp;m.status4xx, 1)
        }</span> else<span class="cov1" title="1"> if statusCode &gt;= 500 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;m.failedRequests, 1)
                atomic.AddInt64(&amp;m.status5xx, 1)
        }</span>

        // Update timing
        <span class="cov10" title="225">atomic.AddInt64(&amp;m.totalRequestTime, durationNs)

        // Update min time
        for </span><span class="cov10" title="225">{
                oldMin := atomic.LoadInt64(&amp;m.minRequestTime)
                if durationNs &gt;= oldMin </span><span class="cov9" title="211">{
                        break</span>
                }
                <span class="cov5" title="14">if atomic.CompareAndSwapInt64(&amp;m.minRequestTime, oldMin, durationNs) </span><span class="cov5" title="14">{
                        break</span>
                }
        }

        // Update max time
        <span class="cov10" title="225">for </span><span class="cov10" title="225">{
                oldMax := atomic.LoadInt64(&amp;m.maxRequestTime)
                if durationNs &lt;= oldMax </span><span class="cov9" title="212">{
                        break</span>
                }
                <span class="cov5" title="13">if atomic.CompareAndSwapInt64(&amp;m.maxRequestTime, oldMax, durationNs) </span><span class="cov5" title="13">{
                        break</span>
                }
        }

        // Update last request time
        <span class="cov10" title="225">m.lastRequestMu.Lock()
        m.lastRequestTime = time.Now()
        m.lastRequestMu.Unlock()

        // Update endpoint metrics
        m.recordEndpointMetrics(path, method, durationNs, statusCode)</span>
}

// recordEndpointMetrics records metrics for a specific endpoint
func (m *Metrics) recordEndpointMetrics(path, method string, durationNs int64, statusCode int) <span class="cov10" title="225">{
        key := method + ":" + path

        m.endpointMu.RLock()
        endpoint, exists := m.endpointMetrics[key]
        m.endpointMu.RUnlock()

        if !exists </span><span class="cov6" title="21">{
                m.endpointMu.Lock()
                // Double-check after acquiring write lock
                endpoint, exists = m.endpointMetrics[key]
                if !exists </span><span class="cov6" title="21">{
                        endpoint = &amp;EndpointMetrics{
                                Path:    path,
                                Method:  method,
                                MinTime: int64(^uint64(0) &gt;&gt; 1), // Max int64
                        }
                        m.endpointMetrics[key] = endpoint
                }</span>
                <span class="cov6" title="21">m.endpointMu.Unlock()</span>
        }

        // Update endpoint metrics
        <span class="cov10" title="225">atomic.AddInt64(&amp;endpoint.Count, 1)
        atomic.AddInt64(&amp;endpoint.TotalTime, durationNs)

        // Update endpoint min time
        for </span><span class="cov10" title="225">{
                oldMin := atomic.LoadInt64(&amp;endpoint.MinTime)
                if durationNs &gt;= oldMin </span><span class="cov9" title="201">{
                        break</span>
                }
                <span class="cov6" title="24">if atomic.CompareAndSwapInt64(&amp;endpoint.MinTime, oldMin, durationNs) </span><span class="cov6" title="24">{
                        break</span>
                }
        }

        // Update endpoint max time
        <span class="cov10" title="225">for </span><span class="cov10" title="225">{
                oldMax := atomic.LoadInt64(&amp;endpoint.MaxTime)
                if durationNs &lt;= oldMax </span><span class="cov9" title="202">{
                        break</span>
                }
                <span class="cov6" title="23">if atomic.CompareAndSwapInt64(&amp;endpoint.MaxTime, oldMax, durationNs) </span><span class="cov6" title="23">{
                        break</span>
                }
        }

        // Update endpoint status codes
        <span class="cov10" title="225">if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 </span><span class="cov9" title="221">{
                atomic.AddInt64(&amp;endpoint.Status2xx, 1)
        }</span> else<span class="cov3" title="4"> if statusCode &gt;= 300 &amp;&amp; statusCode &lt; 400 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;endpoint.Status3xx, 1)
        }</span> else<span class="cov2" title="3"> if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 </span><span class="cov2" title="2">{
                atomic.AddInt64(&amp;endpoint.Status4xx, 1)
        }</span> else<span class="cov1" title="1"> if statusCode &gt;= 500 </span><span class="cov1" title="1">{
                atomic.AddInt64(&amp;endpoint.Status5xx, 1)
        }</span>
}

// GetSummary returns a summary of metrics
func (m *Metrics) GetSummary(includeEndpoints bool) *MetricsSummary <span class="cov5" title="13">{
        totalRequests := atomic.LoadInt64(&amp;m.totalRequests)
        successfulRequests := atomic.LoadInt64(&amp;m.successfulRequests)
        failedRequests := atomic.LoadInt64(&amp;m.failedRequests)
        totalRequestTime := atomic.LoadInt64(&amp;m.totalRequestTime)
        minRequestTime := atomic.LoadInt64(&amp;m.minRequestTime)
        maxRequestTime := atomic.LoadInt64(&amp;m.maxRequestTime)
        status2xx := atomic.LoadInt64(&amp;m.status2xx)
        status3xx := atomic.LoadInt64(&amp;m.status3xx)
        status4xx := atomic.LoadInt64(&amp;m.status4xx)
        status5xx := atomic.LoadInt64(&amp;m.status5xx)

        var avgRequestTime time.Duration
        if totalRequests &gt; 0 </span><span class="cov4" title="11">{
                avgRequestTime = time.Duration(totalRequestTime / totalRequests)
        }</span>

        <span class="cov5" title="13">uptime := time.Since(m.startTime)
        var requestsPerSecond float64
        if uptime.Seconds() &gt; 0 </span><span class="cov5" title="13">{
                requestsPerSecond = float64(totalRequests) / uptime.Seconds()
        }</span>

        <span class="cov5" title="13">m.lastRequestMu.RLock()
        lastRequestTime := m.lastRequestTime
        m.lastRequestMu.RUnlock()

        summary := &amp;MetricsSummary{
                TotalRequests:      totalRequests,
                SuccessfulRequests: successfulRequests,
                FailedRequests:     failedRequests,
                AvgRequestTime:     avgRequestTime,
                MinRequestTime:     time.Duration(minRequestTime),
                MaxRequestTime:     time.Duration(maxRequestTime),
                RequestsPerSecond:  requestsPerSecond,
                Status2xx:          status2xx,
                Status3xx:          status3xx,
                Status4xx:          status4xx,
                Status5xx:          status5xx,
                Uptime:             uptime,
                LastRequestTime:    lastRequestTime,
        }

        if includeEndpoints </span><span class="cov2" title="3">{
                m.endpointMu.RLock()
                summary.Endpoints = make([]*EndpointMetrics, 0, len(m.endpointMetrics))
                for _, endpoint := range m.endpointMetrics </span><span class="cov3" title="6">{
                        // Create a copy
                        endpointCopy := &amp;EndpointMetrics{
                                Path:      endpoint.Path,
                                Method:    endpoint.Method,
                                Count:     atomic.LoadInt64(&amp;endpoint.Count),
                                TotalTime: atomic.LoadInt64(&amp;endpoint.TotalTime),
                                MinTime:   atomic.LoadInt64(&amp;endpoint.MinTime),
                                MaxTime:   atomic.LoadInt64(&amp;endpoint.MaxTime),
                                Status2xx: atomic.LoadInt64(&amp;endpoint.Status2xx),
                                Status3xx: atomic.LoadInt64(&amp;endpoint.Status3xx),
                                Status4xx: atomic.LoadInt64(&amp;endpoint.Status4xx),
                                Status5xx: atomic.LoadInt64(&amp;endpoint.Status5xx),
                        }
                        summary.Endpoints = append(summary.Endpoints, endpointCopy)
                }</span>
                <span class="cov2" title="3">m.endpointMu.RUnlock()</span>
        }

        <span class="cov5" title="13">return summary</span>
}

// Reset resets all metrics
func (m *Metrics) Reset() <span class="cov2" title="2">{
        atomic.StoreInt64(&amp;m.totalRequests, 0)
        atomic.StoreInt64(&amp;m.successfulRequests, 0)
        atomic.StoreInt64(&amp;m.failedRequests, 0)
        atomic.StoreInt64(&amp;m.totalRequestTime, 0)
        atomic.StoreInt64(&amp;m.minRequestTime, int64(^uint64(0)&gt;&gt;1))
        atomic.StoreInt64(&amp;m.maxRequestTime, 0)
        atomic.StoreInt64(&amp;m.status2xx, 0)
        atomic.StoreInt64(&amp;m.status3xx, 0)
        atomic.StoreInt64(&amp;m.status4xx, 0)
        atomic.StoreInt64(&amp;m.status5xx, 0)

        m.endpointMu.Lock()
        m.endpointMetrics = make(map[string]*EndpointMetrics)
        m.endpointMu.Unlock()

        m.startTime = time.Now()

        m.lastRequestMu.Lock()
        m.lastRequestTime = time.Time{}
        m.lastRequestMu.Unlock()
}</span>

// MetricsMiddleware creates middleware for metrics collection
func MetricsMiddleware(metrics *Metrics) gin.HandlerFunc <span class="cov2" title="2">{
        return func(c *gin.Context) </span><span class="cov4" title="9">{
                start := time.Now()

                // Process request
                c.Next()

                // Record metrics
                duration := time.Since(start)
                metrics.RecordRequest(duration, c.Writer.Status(), c.Request.URL.Path, c.Request.Method)
        }</span>
}

// Global metrics instance
var globalMetrics = NewMetrics()

// GetGlobalMetrics returns the global metrics instance
func GetGlobalMetrics() *Metrics <span class="cov2" title="2">{
        return globalMetrics
}</span>

// HealthStatus represents application health status
type HealthStatus struct {
        Status      string        `json:"status"`
        Uptime      time.Duration `json:"uptime"`
        Version     string        `json:"version"`
        Database    string        `json:"database"`
        Cache       string        `json:"cache,omitempty"`
        Metrics     *MetricsSummary `json:"metrics,omitempty"`
        Timestamp   time.Time     `json:"timestamp"`
}

// HealthCheck performs a health check
type HealthCheck struct {
        Version string
        DBPing  func() error
}

// Check performs health check
func (hc *HealthCheck) Check(includeMetrics bool) *HealthStatus <span class="cov2" title="3">{
        status := "healthy"
        dbStatus := "connected"

        // Check database
        if hc.DBPing != nil </span><span class="cov2" title="3">{
                if err := hc.DBPing(); err != nil </span><span class="cov1" title="1">{
                        status = "unhealthy"
                        dbStatus = "disconnected"
                }</span>
        }

        <span class="cov2" title="3">health := &amp;HealthStatus{
                Status:    status,
                Uptime:    time.Since(globalMetrics.startTime),
                Version:   hc.Version,
                Database:  dbStatus,
                Timestamp: time.Now(),
        }

        if includeMetrics </span><span class="cov1" title="1">{
                health.Metrics = globalMetrics.GetSummary(true)
        }</span>

        <span class="cov2" title="3">return health</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// JWTMiddleware creates a middleware for JWT validation
type JWTMiddleware struct {
        authService services.AuthService
        secretKey   string // For local JWT validation (optional)
}

// NewJWTMiddleware creates a new JWT middleware
func NewJWTMiddleware(authService services.AuthService, secretKey string) *JWTMiddleware <span class="cov10" title="8">{
        return &amp;JWTMiddleware{
                authService: authService,
                secretKey:   secretKey,
        }
}</span>

// Validate is a Gin middleware that validates JWT tokens
func (m *JWTMiddleware) Validate() gin.HandlerFunc <span class="cov9" title="7">{
        return func(c *gin.Context) </span><span class="cov9" title="7">{
                // Get token from Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeMissingJWT,
                                "Missing Authorization header",
                                "",
                        ))
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;" format
                <span class="cov8" title="6">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeInvalidJWT,
                                "Invalid Authorization header format",
                                "",
                        ))
                        return
                }</span>

                <span class="cov7" title="5">token := parts[1]

                // Validate token
                claims, err := m.validateToken(c.Request.Context(), token)
                if err != nil </span><span class="cov5" title="3">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeInvalidJWT,
                                err.Error(),
                                "",
                        ))
                        return
                }</span>

                // Store claims in context for handlers to use
                <span class="cov4" title="2">c.Set("claims", claims)
                c.Set("username", claims.Username)

                c.Next()</span>
        }
}

// ValidateToken is a public method to validate JWT tokens
func (m *JWTMiddleware) ValidateToken(ctx context.Context, tokenString string) (*models.JWTClaims, error) <span class="cov0" title="0">{
        return m.validateToken(ctx, tokenString)
}</span>

// validateToken validates the JWT token using either the auth service or local validation
func (m *JWTMiddleware) validateToken(ctx context.Context, tokenString string) (*models.JWTClaims, error) <span class="cov7" title="5">{
        // If auth service is enabled, use it for validation
        if m.authService != nil &amp;&amp; m.authService.IsEnabled() </span><span class="cov4" title="2">{
                return m.authService.ValidateToken(ctx, tokenString)
        }</span>

        // Otherwise, validate locally (always available with default or provided secret key)
        <span class="cov5" title="3">return m.validateTokenLocally(tokenString)</span>
}

// validateTokenLocally validates the JWT token locally using the secret key
func (m *JWTMiddleware) validateTokenLocally(tokenString string) (*models.JWTClaims, error) <span class="cov5" title="3">{
        // Use default secret key if not provided
        secretKey := m.secretKey
        if secretKey == "" </span><span class="cov0" title="0">{
                secretKey = "helix-track-default-secret-key-change-in-production"
        }</span>

        <span class="cov5" title="3">token, err := jwt.ParseWithClaims(tokenString, &amp;models.JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov5" title="3">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, jwt.ErrSignatureInvalid
                }</span>
                <span class="cov5" title="3">return []byte(secretKey), nil</span>
        })

        <span class="cov5" title="3">if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if claims, ok := token.Claims.(*models.JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov1" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, jwt.ErrTokenInvalidClaims</span>
}

// GetClaims retrieves JWT claims from the Gin context
func GetClaims(c *gin.Context) (*models.JWTClaims, bool) <span class="cov7" title="5">{
        claims, exists := c.Get("claims")
        if !exists </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        <span class="cov7" title="4">jwtClaims, ok := claims.(*models.JWTClaims)
        return jwtClaims, ok</span>
}

// GetUsername retrieves the username from the Gin context
func GetUsername(c *gin.Context) (string, bool) <span class="cov5" title="3">{
        username, exists := c.Get("username")
        if !exists </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov4" title="2">usernameStr, ok := username.(string)
        return usernameStr, ok</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package middleware

import (
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// CompressionMiddleware provides response compression
func CompressionMiddleware(level int) gin.HandlerFunc <span class="cov4" title="4">{
        if level &lt; gzip.DefaultCompression || level &gt; gzip.BestCompression </span><span class="cov0" title="0">{
                level = gzip.DefaultCompression
        }</span>

        // Pool of gzip writers for reuse
        <span class="cov4" title="4">gzipPool := sync.Pool{
                New: func() interface{} </span><span class="cov2" title="2">{
                        gz, _ := gzip.NewWriterLevel(io.Discard, level)
                        return gz
                }</span>,
        }

        <span class="cov4" title="4">return func(c *gin.Context) </span><span class="cov4" title="4">{
                // Check if client supports gzip
                if !strings.Contains(c.GetHeader("Accept-Encoding"), "gzip") </span><span class="cov2" title="2">{
                        c.Next()
                        return
                }</span>

                // Don't compress if content is already compressed
                <span class="cov2" title="2">if c.GetHeader("Content-Encoding") != "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Get gzip writer from pool
                <span class="cov2" title="2">gz := gzipPool.Get().(*gzip.Writer)
                defer gzipPool.Put(gz)

                gz.Reset(c.Writer)
                defer gz.Close()

                // Wrap response writer
                c.Writer = &amp;gzipResponseWriter{
                        ResponseWriter: c.Writer,
                        writer:         gz,
                }

                c.Header("Content-Encoding", "gzip")
                c.Header("Vary", "Accept-Encoding")

                c.Next()</span>
        }
}

// gzipResponseWriter wraps gin.ResponseWriter with gzip compression
type gzipResponseWriter struct {
        gin.ResponseWriter
        writer *gzip.Writer
}

func (g *gzipResponseWriter) Write(data []byte) (int, error) <span class="cov4" title="3">{
        return g.writer.Write(data)
}</span>

func (g *gzipResponseWriter) WriteString(s string) (int, error) <span class="cov1" title="1">{
        return g.writer.Write([]byte(s))
}</span>

// RateLimiterConfig contains rate limiting configuration
type RateLimiterConfig struct {
        RequestsPerSecond int           // Maximum requests per second
        BurstSize         int           // Maximum burst size
        CleanupInterval   time.Duration // Cleanup interval for old entries
}

// DefaultRateLimiterConfig returns optimized default settings
func DefaultRateLimiterConfig() RateLimiterConfig <span class="cov4" title="4">{
        return RateLimiterConfig{
                RequestsPerSecond: 1000,              // 1000 req/sec
                BurstSize:         2000,              // Allow bursts up to 2000
                CleanupInterval:   1 * time.Minute,   // Cleanup every minute
        }
}</span>

// tokenBucket represents a token bucket for rate limiting
type tokenBucket struct {
        tokens         float64
        lastRefill     time.Time
        maxTokens      float64
        refillRate     float64 // tokens per second
        mu             sync.Mutex
}

// rateLimiter implements rate limiting
type rateLimiter struct {
        buckets         map[string]*tokenBucket
        mu              sync.RWMutex
        config          RateLimiterConfig
        stopCleanup     chan struct{}
        cleanupDone     sync.WaitGroup
}

// newRateLimiter creates a new rate limiter
func newRateLimiter(cfg RateLimiterConfig) *rateLimiter <span class="cov4" title="3">{
        rl := &amp;rateLimiter{
                buckets:     make(map[string]*tokenBucket),
                config:      cfg,
                stopCleanup: make(chan struct{}),
        }

        // Start background cleanup
        rl.cleanupDone.Add(1)
        go rl.cleanupLoop()

        return rl
}</span>

// allow checks if a request is allowed
func (rl *rateLimiter) allow(key string) bool <span class="cov9" title="18">{
        rl.mu.RLock()
        bucket, exists := rl.buckets[key]
        rl.mu.RUnlock()

        if !exists </span><span class="cov4" title="3">{
                rl.mu.Lock()
                // Double-check after acquiring write lock
                bucket, exists = rl.buckets[key]
                if !exists </span><span class="cov4" title="3">{
                        bucket = &amp;tokenBucket{
                                tokens:     float64(rl.config.BurstSize),
                                lastRefill: time.Now(),
                                maxTokens:  float64(rl.config.BurstSize),
                                refillRate: float64(rl.config.RequestsPerSecond),
                        }
                        rl.buckets[key] = bucket
                }</span>
                <span class="cov4" title="3">rl.mu.Unlock()</span>
        }

        <span class="cov9" title="18">return bucket.take()</span>
}

// take attempts to take a token from the bucket
func (tb *tokenBucket) take() bool <span class="cov10" title="25">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        now := time.Now()
        elapsed := now.Sub(tb.lastRefill).Seconds()

        // Refill tokens based on elapsed time
        tb.tokens += elapsed * tb.refillRate
        if tb.tokens &gt; tb.maxTokens </span><span class="cov4" title="4">{
                tb.tokens = tb.maxTokens
        }</span>
        <span class="cov10" title="25">tb.lastRefill = now

        // Check if we have tokens available
        if tb.tokens &gt;= 1.0 </span><span class="cov9" title="23">{
                tb.tokens -= 1.0
                return true
        }</span>

        <span class="cov2" title="2">return false</span>
}

// cleanupLoop removes old buckets
func (rl *rateLimiter) cleanupLoop() <span class="cov4" title="3">{
        defer rl.cleanupDone.Done()

        ticker := time.NewTicker(rl.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov5" title="5">{
                select </span>{
                case &lt;-ticker.C:<span class="cov2" title="2">
                        rl.cleanup()</span>
                case &lt;-rl.stopCleanup:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// cleanup removes inactive buckets
func (rl *rateLimiter) cleanup() <span class="cov2" title="2">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        for key, bucket := range rl.buckets </span><span class="cov2" title="2">{
                bucket.mu.Lock()
                inactive := now.Sub(bucket.lastRefill) &gt; 5*time.Minute
                bucket.mu.Unlock()

                if inactive </span><span class="cov0" title="0">{
                        delete(rl.buckets, key)
                }</span>
        }
}

// close stops the rate limiter
func (rl *rateLimiter) close() <span class="cov1" title="1">{
        close(rl.stopCleanup)
        rl.cleanupDone.Wait()
}</span>

// RateLimitMiddleware creates rate limiting middleware
func RateLimitMiddleware(cfg RateLimiterConfig) gin.HandlerFunc <span class="cov2" title="2">{
        limiter := newRateLimiter(cfg)

        return func(c *gin.Context) </span><span class="cov8" title="17">{
                // Use client IP as key
                key := c.ClientIP()

                if !limiter.allow(key) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                                "retry_after": "1s",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="16">c.Next()</span>
        }
}

// CircuitBreakerConfig contains circuit breaker configuration
type CircuitBreakerConfig struct {
        MaxFailures     int           // Maximum failures before opening
        Timeout         time.Duration // Timeout before attempting to close
        HalfOpenMax     int           // Maximum requests in half-open state
        FailureRatio    float64       // Failure ratio threshold (0.0 - 1.0)
        MinRequests     int           // Minimum requests before evaluating ratio
}

// DefaultCircuitBreakerConfig returns optimized default settings
func DefaultCircuitBreakerConfig() CircuitBreakerConfig <span class="cov4" title="3">{
        return CircuitBreakerConfig{
                MaxFailures:  5,
                Timeout:      30 * time.Second,
                HalfOpenMax:  3,
                FailureRatio: 0.5,
                MinRequests:  10,
        }
}</span>

// circuitState represents circuit breaker state
type circuitState int

const (
        stateClosed circuitState = iota
        stateOpen
        stateHalfOpen
)

// circuitBreaker implements circuit breaker pattern
type circuitBreaker struct {
        config          CircuitBreakerConfig
        state           circuitState
        failures        int
        successes       int
        totalRequests   int
        halfOpenCount   int
        lastFailureTime time.Time
        mu              sync.RWMutex
}

// newCircuitBreaker creates a new circuit breaker
func newCircuitBreaker(cfg CircuitBreakerConfig) *circuitBreaker <span class="cov2" title="2">{
        return &amp;circuitBreaker{
                config: cfg,
                state:  stateClosed,
        }
}</span>

// allow checks if request is allowed through circuit breaker
func (cb *circuitBreaker) allow() bool <span class="cov5" title="5">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        switch cb.state </span>{
        case stateClosed:<span class="cov4" title="3">
                return true</span>

        case stateOpen:<span class="cov2" title="2">
                // Check if we should transition to half-open
                if time.Since(cb.lastFailureTime) &gt; cb.config.Timeout </span><span class="cov1" title="1">{
                        cb.state = stateHalfOpen
                        cb.halfOpenCount = 0
                        return true
                }</span>
                <span class="cov1" title="1">return false</span>

        case stateHalfOpen:<span class="cov0" title="0">
                // Allow limited requests in half-open state
                if cb.halfOpenCount &lt; cb.config.HalfOpenMax </span><span class="cov0" title="0">{
                        cb.halfOpenCount++
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>

        default:<span class="cov0" title="0">
                return false</span>
        }
}

// recordSuccess records a successful request
func (cb *circuitBreaker) recordSuccess() <span class="cov2" title="2">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.successes++
        cb.totalRequests++

        if cb.state == stateHalfOpen </span><span class="cov2" title="2">{
                // Transition to closed if enough successes
                if cb.successes &gt;= cb.config.HalfOpenMax </span><span class="cov1" title="1">{
                        cb.state = stateClosed
                        cb.failures = 0
                        cb.successes = 0
                        cb.totalRequests = 0
                }</span>
        }
}

// recordFailure records a failed request
func (cb *circuitBreaker) recordFailure() <span class="cov5" title="5">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.failures++
        cb.totalRequests++
        cb.lastFailureTime = time.Now()

        // Check if we should open the circuit
        if cb.state == stateClosed </span><span class="cov5" title="5">{
                // Check max failures
                if cb.failures &gt;= cb.config.MaxFailures </span><span class="cov2" title="2">{
                        cb.state = stateOpen
                        return
                }</span>

                // Check failure ratio
                <span class="cov4" title="3">if cb.totalRequests &gt;= cb.config.MinRequests </span><span class="cov0" title="0">{
                        ratio := float64(cb.failures) / float64(cb.totalRequests)
                        if ratio &gt;= cb.config.FailureRatio </span><span class="cov0" title="0">{
                                cb.state = stateOpen
                                return
                        }</span>
                }
        } else<span class="cov0" title="0"> if cb.state == stateHalfOpen </span><span class="cov0" title="0">{
                // Any failure in half-open state opens the circuit
                cb.state = stateOpen
        }</span>
}

// getState returns current circuit state
func (cb *circuitBreaker) getState() circuitState <span class="cov4" title="3">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()
        return cb.state
}</span>

// CircuitBreakerMiddleware creates circuit breaker middleware
func CircuitBreakerMiddleware(cfg CircuitBreakerConfig) gin.HandlerFunc <span class="cov1" title="1">{
        breaker := newCircuitBreaker(cfg)

        return func(c *gin.Context) </span><span class="cov4" title="4">{
                if !breaker.allow() </span><span class="cov1" title="1">{
                        c.JSON(http.StatusServiceUnavailable, gin.H{
                                "error": "Service temporarily unavailable",
                                "retry_after": cfg.Timeout.String(),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov4" title="3">c.Next()

                // Record result based on status code
                if c.Writer.Status() &gt;= 500 </span><span class="cov4" title="3">{
                        breaker.recordFailure()
                }</span> else<span class="cov0" title="0"> {
                        breaker.recordSuccess()
                }</span>
        }
}

// TimeoutMiddleware adds request timeout
func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                // Create context with timeout
                ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
                defer cancel()

                // Replace request context
                c.Request = c.Request.WithContext(ctx)

                // Channel to signal when request is done
                finished := make(chan struct{})

                go func() </span><span class="cov2" title="2">{
                        c.Next()
                        close(finished)
                }</span>()

                <span class="cov2" title="2">select </span>{
                case &lt;-finished:<span class="cov1" title="1">
                        // Request completed successfully
                        return</span>
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        // Timeout occurred
                        c.JSON(http.StatusRequestTimeout, gin.H{
                                "error": "Request timeout",
                        })
                        c.Abort()</span>
                }
        }
}

// CORSConfig contains CORS configuration
type CORSConfig struct {
        AllowOrigins     []string
        AllowMethods     []string
        AllowHeaders     []string
        ExposeHeaders    []string
        AllowCredentials bool
        MaxAge           time.Duration
}

// DefaultCORSConfig returns default CORS configuration
func DefaultCORSConfig() CORSConfig <span class="cov4" title="4">{
        return CORSConfig{
                AllowOrigins:     []string{"*"},
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: false,
                MaxAge:           12 * time.Hour,
        }
}</span>

// CORSMiddleware creates CORS middleware
func CORSMiddleware(cfg CORSConfig) gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov4" title="3">{
                origin := c.Request.Header.Get("Origin")

                // Set CORS headers
                if len(cfg.AllowOrigins) &gt; 0 </span><span class="cov4" title="3">{
                        if cfg.AllowOrigins[0] == "*" </span><span class="cov2" title="2">{
                                c.Header("Access-Control-Allow-Origin", "*")
                        }</span> else<span class="cov1" title="1"> {
                                for _, allowedOrigin := range cfg.AllowOrigins </span><span class="cov1" title="1">{
                                        if origin == allowedOrigin </span><span class="cov1" title="1">{
                                                c.Header("Access-Control-Allow-Origin", origin)
                                                break</span>
                                        }
                                }
                        }
                }

                <span class="cov4" title="3">if len(cfg.AllowMethods) &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Allow-Methods", strings.Join(cfg.AllowMethods, ", "))
                }</span>

                <span class="cov4" title="3">if len(cfg.AllowHeaders) &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Allow-Headers", strings.Join(cfg.AllowHeaders, ", "))
                }</span>

                <span class="cov4" title="3">if len(cfg.ExposeHeaders) &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Expose-Headers", strings.Join(cfg.ExposeHeaders, ", "))
                }</span>

                <span class="cov4" title="3">if cfg.AllowCredentials </span><span class="cov1" title="1">{
                        c.Header("Access-Control-Allow-Credentials", "true")
                }</span>

                <span class="cov4" title="3">if cfg.MaxAge &gt; 0 </span><span class="cov4" title="3">{
                        c.Header("Access-Control-Max-Age", fmt.Sprintf("%.0f", cfg.MaxAge.Seconds()))
                }</span>

                // Handle preflight requests
                <span class="cov4" title="3">if c.Request.Method == "OPTIONS" </span><span class="cov1" title="1">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov2" title="2">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// PermissionMiddleware creates a middleware for permission checking
func PermissionMiddleware(permService services.PermissionService) gin.HandlerFunc <span class="cov7" title="6">{
        return func(c *gin.Context) </span><span class="cov7" title="6">{
                // Skip permission check if service is not enabled
                if !permService.IsEnabled() </span><span class="cov1" title="1">{
                        c.Next()
                        return
                }</span>

                // Get JWT claims from context (set by JWT middleware)
                <span class="cov6" title="5">claims, exists := c.Get("claims")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "No authentication provided",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov6" title="4">jwtClaims, ok := claims.(*models.JWTClaims)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "Invalid authentication claims",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                // Store username in context for later use
                <span class="cov4" title="3">c.Set("username", jwtClaims.Username)
                c.Set("permissionService", permService)

                c.Next()</span>
        }
}

// RequirePermission creates a middleware that requires a specific permission level
func RequirePermission(permService services.PermissionService, context string, level models.PermissionLevel) gin.HandlerFunc <span class="cov10" title="12">{
        return func(c *gin.Context) </span><span class="cov10" title="12">{
                // Skip permission check if service is not enabled
                if !permService.IsEnabled() </span><span class="cov1" title="1">{
                        c.Next()
                        return
                }</span>

                <span class="cov9" title="11">username, exists := c.Get("username")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeUnauthorized,
                                "No username in context",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov9" title="10">usernameStr, ok := username.(string)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Invalid username type",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                // Check permission
                <span class="cov8" title="9">allowed, err := permService.CheckPermission(c.Request.Context(), usernameStr, context, level)
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusInternalServerError, models.NewErrorResponse(
                                models.ErrorCodeInternalError,
                                "Permission check failed: "+err.Error(),
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="8">if !allowed </span><span class="cov4" title="3">{
                        c.JSON(http.StatusForbidden, models.NewErrorResponse(
                                models.ErrorCodeForbidden,
                                "Permission denied",
                                "",
                        ))
                        c.Abort()
                        return
                }</span>

                <span class="cov6" title="5">c.Next()</span>
        }
}

// CheckPermissionForAction checks permission for a specific action and context
func CheckPermissionForAction(c *gin.Context, permService services.PermissionService, action, context string) bool <span class="cov9" title="10">{
        // Skip permission check if service is not enabled
        if !permService.IsEnabled() </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov8" title="9">username, exists := c.Get("username")
        if !exists </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="8">usernameStr, ok := username.(string)
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>

        // Determine required permission level from action
        <span class="cov8" title="7">requiredLevel := models.GetRequiredPermissionLevel(action)

        // Check permission
        allowed, err := permService.CheckPermission(c.Request.Context(), usernameStr, context, requiredLevel)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov7" title="6">return allowed</span>
}

// GetUserPermissions retrieves all permissions for the current user
func GetUserPermissions(c *gin.Context, permService services.PermissionService) ([]models.Permission, error) <span class="cov6" title="4">{
        username, exists := c.Get("username")
        if !exists </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov4" title="3">usernameStr, ok := username.(string)
        if !ok </span><span class="cov1" title="1">{
                return nil, nil
        }</span>

        <span class="cov3" title="2">return permService.GetUserPermissions(c.Request.Context(), usernameStr)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package models

// Asset represents a file attachment or asset (images, documents, files)
type Asset struct {
        ID          string `json:"id" db:"id"`
        URL         string `json:"url" db:"url" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// AssetTicketMapping represents the many-to-many relationship between assets and tickets
type AssetTicketMapping struct {
        ID       string `json:"id" db:"id"`
        AssetID  string `json:"assetId" db:"asset_id" binding:"required"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// AssetCommentMapping represents the many-to-many relationship between assets and comments
type AssetCommentMapping struct {
        ID        string `json:"id" db:"id"`
        AssetID   string `json:"assetId" db:"asset_id" binding:"required"`
        CommentID string `json:"commentId" db:"comment_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// AssetProjectMapping represents the many-to-many relationship between assets and projects
type AssetProjectMapping struct {
        ID        string `json:"id" db:"id"`
        AssetID   string `json:"assetId" db:"asset_id" binding:"required"`
        ProjectID string `json:"projectId" db:"project_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// AssetTeamMapping represents the many-to-many relationship between assets and teams
type AssetTeamMapping struct {
        ID       string `json:"id" db:"id"`
        AssetID  string `json:"assetId" db:"asset_id" binding:"required"`
        TeamID   string `json:"teamId" db:"team_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// GetDisplayName returns a user-friendly display name
func (a *Asset) GetDisplayName() string <span class="cov0" title="0">{
        if a.Description != "" </span><span class="cov0" title="0">{
                return a.Description
        }</span>
        <span class="cov0" title="0">if a.URL != "" </span><span class="cov0" title="0">{
                return a.URL
        }</span>
        <span class="cov0" title="0">return "Unknown Asset"</span>
}

// IsValid checks if the asset has required fields
func (a *Asset) IsValid() bool <span class="cov0" title="0">{
        return a.URL != ""
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package models

// Audit represents an audit log entry tracking actions in the system
type Audit struct {
        ID         string `json:"id" db:"id"`
        Action     string `json:"action" db:"action" binding:"required"`       // The action performed
        UserID     string `json:"userId" db:"user_id"`                         // User who performed the action
        EntityID   string `json:"entityId" db:"entity_id"`                     // ID of the entity affected
        EntityType string `json:"entityType" db:"entity_type"`                 // Type of entity (project, ticket, etc.)
        Details    string `json:"details,omitempty" db:"details"`              // JSON encoded details
        Created    int64  `json:"created" db:"created"`
        Modified   int64  `json:"modified" db:"modified"`
        Deleted    bool   `json:"deleted" db:"deleted"`
}

// AuditMetaData represents additional metadata for audit entries
type AuditMetaData struct {
        ID       string `json:"id" db:"id"`
        AuditID  string `json:"auditId" db:"audit_id" binding:"required"`
        Property string `json:"property" db:"property" binding:"required"`
        Value    string `json:"value" db:"value"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// Valid audit actions
var validAuditActions = map[string]bool{
        // Standard CRUD actions
        ActionCreate:        true,
        ActionRead:          true,
        ActionModify:        true,
        ActionRemove:        true,
        ActionList:          true,
        ActionAuthenticate:  true,

        // Entity-specific actions
        "login":            true,
        "logout":           true,
        "permission_change": true,
        "status_change":    true,
        "assignment_change": true,
        "comment_add":      true,
        "attachment_add":   true,
        "workflow_transition": true,
}

// IsValidAction validates if the action is a recognized audit action
func (a *Audit) IsValidAction() bool <span class="cov0" title="0">{
        return validAuditActions[a.Action]
}</span>

// HasEntity checks if the audit entry has entity information
func (a *Audit) HasEntity() bool <span class="cov0" title="0">{
        return a.EntityID != "" &amp;&amp; a.EntityType != ""
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package models

// Board represents a Kanban/Scrum board for organizing tickets
type Board struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// BoardMetaData represents additional metadata for boards (properties like board type, columns, etc.)
type BoardMetaData struct {
        ID       string `json:"id" db:"id"`
        BoardID  string `json:"boardId" db:"board_id" binding:"required"`
        Property string `json:"property" db:"property" binding:"required"`
        Value    string `json:"value" db:"value"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// TicketBoardMapping represents the relationship between tickets and boards
type TicketBoardMapping struct {
        ID       string `json:"id" db:"id"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        BoardID  string `json:"boardId" db:"board_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// Common board metadata property keys
const (
        BoardPropertyType        = "type"        // kanban, scrum, custom
        BoardPropertyColumns     = "columns"     // JSON array of column definitions
        BoardPropertyDefaultView = "defaultView" // list, board, calendar
        BoardPropertyOwner       = "owner"       // User ID of board owner
        BoardPropertyTeam        = "team"        // Team ID if board is team-specific
        BoardPropertyProject     = "project"     // Project ID if board is project-specific
)

// Board type constants
const (
        BoardTypeKanban = "kanban"
        BoardTypeScrum  = "scrum"
        BoardTypeCustom = "custom"
)

// GetDisplayName returns a user-friendly display name for the board
func (b *Board) GetDisplayName() string <span class="cov0" title="0">{
        if b.Title != "" </span><span class="cov0" title="0">{
                return b.Title
        }</span>
        <span class="cov0" title="0">return "Untitled Board"</span>
}

// IsValid checks if the board has required fields
func (b *Board) IsValid() bool <span class="cov0" title="0">{
        return b.ID != "" &amp;&amp; b.Title != ""
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package models

import "time"

// Comment represents a comment in the system
type Comment struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title"`
        Description string `json:"description" db:"description"`
        UserID      string `json:"userId" db:"user_id"`   // Comment author
        ParentID    string `json:"parentId" db:"parent_id"` // For nested comments
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// NewComment creates a new comment with current timestamps
func NewComment(id, title, description, userID, parentID string) *Comment <span class="cov0" title="0">{
        now := time.Now().Unix()
        return &amp;Comment{
                ID:          id,
                Title:       title,
                Description: description,
                UserID:      userID,
                ParentID:    parentID,
                Created:     now,
                Modified:    now,
                Deleted:     false,
        }
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package models

// Component represents a project component (module, subsystem, feature area)
type Component struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// ComponentMetaData represents additional metadata for a component
type ComponentMetaData struct {
        ID          string `json:"id" db:"id"`
        ComponentID string `json:"componentId" db:"component_id" binding:"required"`
        Property    string `json:"property" db:"property" binding:"required"`
        Value       string `json:"value" db:"value"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// ComponentTicketMapping represents the many-to-many relationship between components and tickets
type ComponentTicketMapping struct {
        ID          string `json:"id" db:"id"`
        ComponentID string `json:"componentId" db:"component_id" binding:"required"`
        TicketID    string `json:"ticketId" db:"ticket_id" binding:"required"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// GetDisplayName returns a user-friendly display name
func (c *Component) GetDisplayName() string <span class="cov0" title="0">{
        if c.Title != "" </span><span class="cov0" title="0">{
                return c.Title
        }</span>
        <span class="cov0" title="0">return "Unknown Component"</span>
}

// IsValid checks if the component has required fields
func (c *Component) IsValid() bool <span class="cov0" title="0">{
        return c.Title != ""
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package models

// CustomField represents a user-defined custom field for tickets
type CustomField struct {
        ID            string  `json:"id" db:"id"`
        FieldName     string  `json:"fieldName" db:"field_name" binding:"required"`
        FieldType     string  `json:"fieldType" db:"field_type" binding:"required"`
        Description   string  `json:"description,omitempty" db:"description"`
        ProjectID     *string `json:"projectId,omitempty" db:"project_id"` // NULL for global fields
        IsRequired    bool    `json:"isRequired" db:"is_required"`
        DefaultValue  *string `json:"defaultValue,omitempty" db:"default_value"`
        Configuration *string `json:"configuration,omitempty" db:"configuration"` // JSON configuration
        Created       int64   `json:"created" db:"created"`
        Modified      int64   `json:"modified" db:"modified"`
        Deleted       bool    `json:"deleted" db:"deleted"`
}

// CustomFieldType represents the type of custom field
type CustomFieldType string

const (
        CustomFieldTypeText        CustomFieldType = "text"
        CustomFieldTypeTextArea    CustomFieldType = "textarea"
        CustomFieldTypeNumber      CustomFieldType = "number"
        CustomFieldTypeDate        CustomFieldType = "date"
        CustomFieldTypeDateTime    CustomFieldType = "datetime"
        CustomFieldTypeSelect      CustomFieldType = "select"
        CustomFieldTypeMultiSelect CustomFieldType = "multi_select"
        CustomFieldTypeUser        CustomFieldType = "user"
        CustomFieldTypeURL         CustomFieldType = "url"
        CustomFieldTypeCheckbox    CustomFieldType = "checkbox"
        CustomFieldTypeRadio       CustomFieldType = "radio"
)

// CustomFieldOption represents an option for select/multi-select custom fields
type CustomFieldOption struct {
        ID            string `json:"id" db:"id"`
        CustomFieldID string `json:"customFieldId" db:"custom_field_id" binding:"required"`
        Value         string `json:"value" db:"value" binding:"required"`
        DisplayValue  string `json:"displayValue" db:"display_value" binding:"required"`
        Position      int    `json:"position" db:"position"`
        IsDefault     bool   `json:"isDefault" db:"is_default"`
        Created       int64  `json:"created" db:"created"`
        Modified      int64  `json:"modified" db:"modified"`
        Deleted       bool   `json:"deleted" db:"deleted"`
}

// TicketCustomFieldValue represents the value of a custom field for a specific ticket
type TicketCustomFieldValue struct {
        ID            string  `json:"id" db:"id"`
        TicketID      string  `json:"ticketId" db:"ticket_id" binding:"required"`
        CustomFieldID string  `json:"customFieldId" db:"custom_field_id" binding:"required"`
        Value         *string `json:"value,omitempty" db:"value"` // NULL for empty/unset fields
        Created       int64   `json:"created" db:"created"`
        Modified      int64   `json:"modified" db:"modified"`
        Deleted       bool    `json:"deleted" db:"deleted"`
}

// IsValidFieldType checks if the field type is valid
func (cf *CustomField) IsValidFieldType() bool <span class="cov6" title="14">{
        validTypes := []CustomFieldType{
                CustomFieldTypeText,
                CustomFieldTypeTextArea,
                CustomFieldTypeNumber,
                CustomFieldTypeDate,
                CustomFieldTypeDateTime,
                CustomFieldTypeSelect,
                CustomFieldTypeMultiSelect,
                CustomFieldTypeUser,
                CustomFieldTypeURL,
                CustomFieldTypeCheckbox,
                CustomFieldTypeRadio,
        }

        for _, validType := range validTypes </span><span class="cov10" title="91">{
                if CustomFieldType(cf.FieldType) == validType </span><span class="cov5" title="12">{
                        return true
                }</span>
        }

        <span class="cov2" title="2">return false</span>
}

// IsGlobal checks if the custom field is global (applies to all projects)
func (cf *CustomField) IsGlobal() bool <span class="cov3" title="3">{
        return cf.ProjectID == nil
}</span>

// IsSelectType checks if the field type is select or multi-select
func (cf *CustomField) IsSelectType() bool <span class="cov5" title="12">{
        return CustomFieldType(cf.FieldType) == CustomFieldTypeSelect ||
                CustomFieldType(cf.FieldType) == CustomFieldTypeMultiSelect
}</span>

// RequiresOptions checks if the field type requires options (select types)
func (cf *CustomField) RequiresOptions() bool <span class="cov4" title="7">{
        return cf.IsSelectType() || CustomFieldType(cf.FieldType) == CustomFieldTypeRadio
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package models

// Cycle represents a sprint/milestone/release (Agile iteration)
// Cycles form a hierarchy: Release (1000) &gt; Milestone (100) &gt; Sprint (10)
type Cycle struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title" binding:"required"`
        Description *string `json:"description,omitempty" db:"description"` // NULL allowed
        CycleID     *string `json:"cycleId,omitempty" db:"cycle_id"`         // Parent cycle ID (NULL for top-level cycles)
        Type        int     `json:"type" db:"type" binding:"required"`
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// Cycle type constants
const (
        CycleTypeRelease   = 1000 // Top-level release cycle
        CycleTypeMilestone = 100  // Mid-level milestone
        CycleTypeSprint    = 10   // Bottom-level sprint
)

// CycleProjectMapping represents the many-to-many relationship between cycles and projects
type CycleProjectMapping struct {
        ID        string `json:"id" db:"id"`
        CycleID   string `json:"cycleId" db:"cycle_id" binding:"required"`
        ProjectID string `json:"projectId" db:"project_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// TicketCycleMapping represents the many-to-many relationship between tickets and cycles
type TicketCycleMapping struct {
        ID       string `json:"id" db:"id"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        CycleID  string `json:"cycleId" db:"cycle_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// IsValidType checks if the cycle type is valid (10, 100, or 1000)
func (c *Cycle) IsValidType() bool <span class="cov0" title="0">{
        return c.Type == CycleTypeSprint || c.Type == CycleTypeMilestone || c.Type == CycleTypeRelease
}</span>

// GetTypeName returns a user-friendly type name
func (c *Cycle) GetTypeName() string <span class="cov0" title="0">{
        switch c.Type </span>{
        case CycleTypeRelease:<span class="cov0" title="0">
                return "Release"</span>
        case CycleTypeMilestone:<span class="cov0" title="0">
                return "Milestone"</span>
        case CycleTypeSprint:<span class="cov0" title="0">
                return "Sprint"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// IsValidParent checks if the parent cycle type is valid for this cycle
// Parent's type must be greater than current cycle's type (Release &gt; Milestone &gt; Sprint)
func (c *Cycle) IsValidParent(parentType int) bool <span class="cov0" title="0">{
        if c.CycleID == nil || *c.CycleID == "" </span><span class="cov0" title="0">{
                return true // No parent is valid
        }</span>
        <span class="cov0" title="0">return parentType &gt; c.Type</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package models

// Error code constants following the specification
const (
        // No error
        ErrorCodeNoError = -1

        // Request-related errors (100X)
        ErrorCodeInvalidRequest       = 1000
        ErrorCodeInvalidAction        = 1001
        ErrorCodeMissingJWT           = 1002
        ErrorCodeInvalidJWT           = 1003
        ErrorCodeMissingObject        = 1004
        ErrorCodeInvalidObject        = 1005
        ErrorCodeMissingData          = 1006
        ErrorCodeInvalidData          = 1007
        ErrorCodeUnauthorized         = 1008
        ErrorCodeForbidden            = 1009

        // System-related errors (200X)
        ErrorCodeInternalError        = 2000
        ErrorCodeDatabaseError        = 2001
        ErrorCodeServiceUnavailable   = 2002
        ErrorCodeConfigurationError   = 2003
        ErrorCodeAuthServiceError     = 2004
        ErrorCodePermissionServiceError = 2005
        ErrorCodeExtensionServiceError = 2006

        // Entity-related errors (300X)
        ErrorCodeEntityNotFound       = 3000
        ErrorCodeEntityAlreadyExists  = 3001
        ErrorCodeEntityValidationFailed = 3002
        ErrorCodeEntityDeleteFailed   = 3003
        ErrorCodeEntityUpdateFailed   = 3004
        ErrorCodeEntityCreateFailed   = 3005
)

// ErrorMessages provides default English error messages
var ErrorMessages = map[int]string{
        ErrorCodeNoError:                 "Success",
        ErrorCodeInvalidRequest:          "Invalid request",
        ErrorCodeInvalidAction:           "Invalid action",
        ErrorCodeMissingJWT:              "Missing JWT token",
        ErrorCodeInvalidJWT:              "Invalid JWT token",
        ErrorCodeMissingObject:           "Missing object type",
        ErrorCodeInvalidObject:           "Invalid object type",
        ErrorCodeMissingData:             "Missing required data",
        ErrorCodeInvalidData:             "Invalid data format",
        ErrorCodeUnauthorized:            "Unauthorized",
        ErrorCodeForbidden:               "Forbidden - insufficient permissions",
        ErrorCodeInternalError:           "Internal server error",
        ErrorCodeDatabaseError:           "Database error",
        ErrorCodeServiceUnavailable:      "Service unavailable",
        ErrorCodeConfigurationError:      "Configuration error",
        ErrorCodeAuthServiceError:        "Authentication service error",
        ErrorCodePermissionServiceError:  "Permission service error",
        ErrorCodeExtensionServiceError:   "Extension service error",
        ErrorCodeEntityNotFound:          "Entity not found",
        ErrorCodeEntityAlreadyExists:     "Entity already exists",
        ErrorCodeEntityValidationFailed:  "Entity validation failed",
        ErrorCodeEntityDeleteFailed:      "Failed to delete entity",
        ErrorCodeEntityUpdateFailed:      "Failed to update entity",
        ErrorCodeEntityCreateFailed:      "Failed to create entity",
}

// GetErrorMessage returns the error message for a given error code
func GetErrorMessage(code int) string <span class="cov10" title="49">{
        if msg, ok := ErrorMessages[code]; ok </span><span class="cov9" title="48">{
                return msg
        }</span>
        <span class="cov1" title="1">return "Unknown error"</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package models

import (
        "time"
)

// EventType represents the type of event
type EventType string

// Event type constants
const (
        // Entity lifecycle events
        EventEntityCreated EventType = "entity.created"
        EventEntityUpdated EventType = "entity.updated"
        EventEntityDeleted EventType = "entity.deleted"
        EventEntityRead    EventType = "entity.read"

        // Ticket events
        EventTicketCreated EventType = "ticket.created"
        EventTicketUpdated EventType = "ticket.updated"
        EventTicketDeleted EventType = "ticket.deleted"
        EventTicketRead    EventType = "ticket.read"

        // Project events
        EventProjectCreated EventType = "project.created"
        EventProjectUpdated EventType = "project.updated"
        EventProjectDeleted EventType = "project.deleted"
        EventProjectRead    EventType = "project.read"

        // Comment events
        EventCommentCreated EventType = "comment.created"
        EventCommentUpdated EventType = "comment.updated"
        EventCommentDeleted EventType = "comment.deleted"
        EventCommentRead    EventType = "comment.read"

        // Priority events
        EventPriorityCreated EventType = "priority.created"
        EventPriorityUpdated EventType = "priority.updated"
        EventPriorityDeleted EventType = "priority.deleted"
        EventPriorityRead    EventType = "priority.read"

        // Resolution events
        EventResolutionCreated EventType = "resolution.created"
        EventResolutionUpdated EventType = "resolution.updated"
        EventResolutionDeleted EventType = "resolution.deleted"
        EventResolutionRead    EventType = "resolution.read"

        // Version events
        EventVersionCreated  EventType = "version.created"
        EventVersionUpdated  EventType = "version.updated"
        EventVersionDeleted  EventType = "version.deleted"
        EventVersionRead     EventType = "version.read"
        EventVersionReleased EventType = "version.released"
        EventVersionArchived EventType = "version.archived"

        // Watcher events
        EventWatcherAdded   EventType = "watcher.added"
        EventWatcherRemoved EventType = "watcher.removed"

        // Filter events
        EventFilterSaved   EventType = "filter.saved"
        EventFilterUpdated EventType = "filter.updated"
        EventFilterDeleted EventType = "filter.deleted"
        EventFilterShared  EventType = "filter.shared"

        // Custom field events
        EventCustomFieldCreated EventType = "customfield.created"
        EventCustomFieldUpdated EventType = "customfield.updated"
        EventCustomFieldDeleted EventType = "customfield.deleted"
        EventCustomFieldRead    EventType = "customfield.read"

        // Board events
        EventBoardCreated EventType = "board.created"
        EventBoardUpdated EventType = "board.updated"
        EventBoardDeleted EventType = "board.deleted"

        // Cycle events (Sprint/Milestone/Release)
        EventCycleCreated EventType = "cycle.created"
        EventCycleUpdated EventType = "cycle.updated"
        EventCycleDeleted EventType = "cycle.deleted"

        // Workflow events
        EventWorkflowCreated EventType = "workflow.created"
        EventWorkflowUpdated EventType = "workflow.updated"
        EventWorkflowDeleted EventType = "workflow.deleted"

        // Account events
        EventAccountCreated EventType = "account.created"
        EventAccountUpdated EventType = "account.updated"
        EventAccountDeleted EventType = "account.deleted"

        // Organization events
        EventOrganizationCreated EventType = "organization.created"
        EventOrganizationUpdated EventType = "organization.updated"
        EventOrganizationDeleted EventType = "organization.deleted"

        // Team events
        EventTeamCreated EventType = "team.created"
        EventTeamUpdated EventType = "team.updated"
        EventTeamDeleted EventType = "team.deleted"

        // User events
        EventUserCreated EventType = "user.created"
        EventUserUpdated EventType = "user.updated"
        EventUserDeleted EventType = "user.deleted"

        // System events
        EventSystemHealthCheck EventType = "system.health_check"
        EventSystemError       EventType = "system.error"
        EventSystemShutdown    EventType = "system.shutdown"

        // Connection events
        EventConnectionEstablished EventType = "connection.established"
        EventConnectionClosed      EventType = "connection.closed"
        EventConnectionError       EventType = "connection.error"
)

// Event represents a system event to be broadcasted via WebSocket
type Event struct {
        ID        string                 `json:"id"`        // Unique event ID (UUID)
        Type      EventType              `json:"type"`      // Event type (e.g., "ticket.created")
        Action    string                 `json:"action"`    // Action that triggered the event (e.g., "create", "modify")
        Object    string                 `json:"object"`    // Object type (e.g., "ticket", "project")
        EntityID  string                 `json:"entityId"`  // ID of the entity affected
        Username  string                 `json:"username"`  // Username who triggered the event
        Timestamp time.Time              `json:"timestamp"` // When the event occurred
        Data      map[string]interface{} `json:"data"`      // Additional event data
        Context   EventContext           `json:"context"`   // Event context (permissions, etc.)
}

// EventContext contains contextual information about the event
type EventContext struct {
        ProjectID      string   `json:"projectId,omitempty"`      // Project ID if relevant
        OrganizationID string   `json:"organizationId,omitempty"` // Organization ID if relevant
        TeamID         string   `json:"teamId,omitempty"`         // Team ID if relevant
        AccountID      string   `json:"accountId,omitempty"`      // Account ID if relevant
        Permissions    []string `json:"permissions,omitempty"`    // Required permissions to see this event
}

// Subscription represents a client's subscription to specific event types
type Subscription struct {
        EventTypes     []EventType          `json:"eventTypes"`     // Event types to subscribe to
        EntityTypes    []string             `json:"entityTypes"`    // Entity types to filter (ticket, project, etc.)
        EntityIDs      []string             `json:"entityIds"`      // Specific entity IDs to filter
        Filters        map[string]string    `json:"filters"`        // Additional filters (projectId, teamId, etc.)
        IncludeReads   bool                 `json:"includeReads"`   // Whether to include read events
        CustomFilters  map[string][]string  `json:"customFilters"`  // Custom filter criteria
        PermissionMask int                  `json:"permissionMask"` // Required permission level
}

// NewEvent creates a new event with the given parameters
func NewEvent(eventType EventType, action, object, entityID, username string, data map[string]interface{}) *Event <span class="cov6" title="8">{
        return &amp;Event{
                ID:        generateEventID(),
                Type:      eventType,
                Action:    action,
                Object:    object,
                EntityID:  entityID,
                Username:  username,
                Timestamp: time.Now().UTC(),
                Data:      data,
                Context:   EventContext{},
        }
}</span>

// WithContext adds context to the event
func (e *Event) WithContext(context EventContext) *Event <span class="cov5" title="5">{
        e.Context = context
        return e
}</span>

// MatchesSubscription checks if the event matches a subscription
func (e *Event) MatchesSubscription(sub *Subscription) bool <span class="cov8" title="15">{
        // Check event type
        if len(sub.EventTypes) &gt; 0 </span><span class="cov4" title="3">{
                matched := false
                for _, et := range sub.EventTypes </span><span class="cov4" title="4">{
                        if e.Type == et </span><span class="cov2" title="2">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov4" title="3">if !matched </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check entity type
        <span class="cov8" title="14">if len(sub.EntityTypes) &gt; 0 </span><span class="cov4" title="3">{
                matched := false
                for _, et := range sub.EntityTypes </span><span class="cov4" title="4">{
                        if e.Object == et </span><span class="cov2" title="2">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov4" title="3">if !matched </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check entity ID
        <span class="cov8" title="13">if len(sub.EntityIDs) &gt; 0 </span><span class="cov4" title="3">{
                matched := false
                for _, eid := range sub.EntityIDs </span><span class="cov4" title="4">{
                        if e.EntityID == eid </span><span class="cov2" title="2">{
                                matched = true
                                break</span>
                        }
                }
                <span class="cov4" title="3">if !matched </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check if read events should be included
        <span class="cov8" title="12">if !sub.IncludeReads &amp;&amp; isReadEvent(e.Type) </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check filters (projectId, teamId, etc.)
        <span class="cov7" title="11">if len(sub.Filters) &gt; 0 </span><span class="cov6" title="6">{
                for key, value := range sub.Filters </span><span class="cov6" title="6">{
                        switch key </span>{
                        case "projectId":<span class="cov4" title="3">
                                if e.Context.ProjectID != value </span><span class="cov1" title="1">{
                                        return false
                                }</span>
                        case "organizationId":<span class="cov1" title="1">
                                if e.Context.OrganizationID != value </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        case "teamId":<span class="cov1" title="1">
                                if e.Context.TeamID != value </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        case "accountId":<span class="cov1" title="1">
                                if e.Context.AccountID != value </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }
        }

        <span class="cov7" title="10">return true</span>
}

// generateEventID generates a unique event ID
func generateEventID() string <span class="cov6" title="8">{
        // Use UUID generation from existing codebase
        // This is a placeholder - will use github.com/google/uuid
        return time.Now().Format("20060102150405.000000")
}</span>

// isReadEvent checks if the event type is a read event
func isReadEvent(eventType EventType) bool <span class="cov10" title="23">{
        return eventType == EventEntityRead ||
                eventType == EventTicketRead ||
                eventType == EventProjectRead ||
                eventType == EventCommentRead ||
                eventType == EventPriorityRead ||
                eventType == EventResolutionRead ||
                eventType == EventVersionRead ||
                eventType == EventCustomFieldRead
}</span>

// GetEventTypeFromAction returns the appropriate event type for an action and object
func GetEventTypeFromAction(action, object string) EventType <span class="cov10" title="23">{
        switch action </span>{
        case ActionCreate:<span class="cov8" title="16">
                return getCreateEventType(object)</span>
        case ActionModify:<span class="cov4" title="3">
                return getUpdateEventType(object)</span>
        case ActionRemove:<span class="cov2" title="2">
                return getDeleteEventType(object)</span>
        case ActionRead:<span class="cov1" title="1">
                return getReadEventType(object)</span>
        default:<span class="cov1" title="1">
                return EventEntityCreated</span>
        }
}

func getCreateEventType(object string) EventType <span class="cov8" title="16">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketCreated</span>
        case "project":<span class="cov1" title="1">
                return EventProjectCreated</span>
        case "comment":<span class="cov1" title="1">
                return EventCommentCreated</span>
        case "priority":<span class="cov1" title="1">
                return EventPriorityCreated</span>
        case "resolution":<span class="cov1" title="1">
                return EventResolutionCreated</span>
        case "version":<span class="cov1" title="1">
                return EventVersionCreated</span>
        case "filter":<span class="cov1" title="1">
                return EventFilterSaved</span>
        case "customfield":<span class="cov1" title="1">
                return EventCustomFieldCreated</span>
        case "board":<span class="cov1" title="1">
                return EventBoardCreated</span>
        case "cycle":<span class="cov1" title="1">
                return EventCycleCreated</span>
        case "workflow":<span class="cov1" title="1">
                return EventWorkflowCreated</span>
        case "account":<span class="cov1" title="1">
                return EventAccountCreated</span>
        case "organization":<span class="cov1" title="1">
                return EventOrganizationCreated</span>
        case "team":<span class="cov1" title="1">
                return EventTeamCreated</span>
        case "user":<span class="cov1" title="1">
                return EventUserCreated</span>
        default:<span class="cov1" title="1">
                return EventEntityCreated</span>
        }
}

func getUpdateEventType(object string) EventType <span class="cov4" title="3">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketUpdated</span>
        case "project":<span class="cov1" title="1">
                return EventProjectUpdated</span>
        case "comment":<span class="cov0" title="0">
                return EventCommentUpdated</span>
        case "priority":<span class="cov1" title="1">
                return EventPriorityUpdated</span>
        case "resolution":<span class="cov0" title="0">
                return EventResolutionUpdated</span>
        case "version":<span class="cov0" title="0">
                return EventVersionUpdated</span>
        case "filter":<span class="cov0" title="0">
                return EventFilterUpdated</span>
        case "customfield":<span class="cov0" title="0">
                return EventCustomFieldUpdated</span>
        case "board":<span class="cov0" title="0">
                return EventBoardUpdated</span>
        case "cycle":<span class="cov0" title="0">
                return EventCycleUpdated</span>
        case "workflow":<span class="cov0" title="0">
                return EventWorkflowUpdated</span>
        case "account":<span class="cov0" title="0">
                return EventAccountUpdated</span>
        case "organization":<span class="cov0" title="0">
                return EventOrganizationUpdated</span>
        case "team":<span class="cov0" title="0">
                return EventTeamUpdated</span>
        case "user":<span class="cov0" title="0">
                return EventUserUpdated</span>
        default:<span class="cov0" title="0">
                return EventEntityUpdated</span>
        }
}

func getDeleteEventType(object string) EventType <span class="cov2" title="2">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketDeleted</span>
        case "project":<span class="cov1" title="1">
                return EventProjectDeleted</span>
        case "comment":<span class="cov0" title="0">
                return EventCommentDeleted</span>
        case "priority":<span class="cov0" title="0">
                return EventPriorityDeleted</span>
        case "resolution":<span class="cov0" title="0">
                return EventResolutionDeleted</span>
        case "version":<span class="cov0" title="0">
                return EventVersionDeleted</span>
        case "filter":<span class="cov0" title="0">
                return EventFilterDeleted</span>
        case "customfield":<span class="cov0" title="0">
                return EventCustomFieldDeleted</span>
        case "board":<span class="cov0" title="0">
                return EventBoardDeleted</span>
        case "cycle":<span class="cov0" title="0">
                return EventCycleDeleted</span>
        case "workflow":<span class="cov0" title="0">
                return EventWorkflowDeleted</span>
        case "account":<span class="cov0" title="0">
                return EventAccountDeleted</span>
        case "organization":<span class="cov0" title="0">
                return EventOrganizationDeleted</span>
        case "team":<span class="cov0" title="0">
                return EventTeamDeleted</span>
        case "user":<span class="cov0" title="0">
                return EventUserDeleted</span>
        default:<span class="cov0" title="0">
                return EventEntityDeleted</span>
        }
}

func getReadEventType(object string) EventType <span class="cov1" title="1">{
        switch object </span>{
        case "ticket":<span class="cov1" title="1">
                return EventTicketRead</span>
        case "project":<span class="cov0" title="0">
                return EventProjectRead</span>
        case "comment":<span class="cov0" title="0">
                return EventCommentRead</span>
        case "priority":<span class="cov0" title="0">
                return EventPriorityRead</span>
        case "resolution":<span class="cov0" title="0">
                return EventResolutionRead</span>
        case "version":<span class="cov0" title="0">
                return EventVersionRead</span>
        case "customfield":<span class="cov0" title="0">
                return EventCustomFieldRead</span>
        default:<span class="cov0" title="0">
                return EventEntityRead</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package models

// Extension represents an extension/plugin in the system
type Extension struct {
        ID          string  `json:"id" db:"id"`
        Title       string  `json:"title" db:"title" binding:"required"`
        Description *string `json:"description,omitempty" db:"description"` // NULL allowed
        Version     string  `json:"version" db:"version"`
        Enabled     bool    `json:"enabled" db:"enabled"`
        Created     int64   `json:"created" db:"created"`
        Modified    int64   `json:"modified" db:"modified"`
        Deleted     bool    `json:"deleted" db:"deleted"`
}

// ExtensionMetaData represents additional metadata for extensions
type ExtensionMetaData struct {
        ID          string `json:"id" db:"id"`
        ExtensionID string `json:"extensionId" db:"extension_id" binding:"required"`
        Property    string `json:"property" db:"property" binding:"required"`
        Value       string `json:"value" db:"value"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// IsValid validates if the extension has required fields
func (e *Extension) IsValid() bool <span class="cov0" title="0">{
        return e.Title != ""
}</span>

// IsEnabled checks if the extension is enabled
func (e *Extension) IsEnabled() bool <span class="cov0" title="0">{
        return e.Enabled &amp;&amp; !e.Deleted
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package models

// Filter represents a saved search filter
type Filter struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        OwnerID     string `json:"ownerId" db:"owner_id" binding:"required"`
        Query       string `json:"query" db:"query" binding:"required"` // JSON query structure
        IsPublic    bool   `json:"isPublic" db:"is_public"`
        IsFavorite  bool   `json:"isFavorite" db:"is_favorite"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// FilterShareMapping represents filter sharing with users/teams/projects
type FilterShareMapping struct {
        ID        string  `json:"id" db:"id"`
        FilterID  string  `json:"filterId" db:"filter_id" binding:"required"`
        UserID    *string `json:"userId,omitempty" db:"user_id"`    // Pointer for nullable
        TeamID    *string `json:"teamId,omitempty" db:"team_id"`    // Pointer for nullable
        ProjectID *string `json:"projectId,omitempty" db:"project_id"` // Pointer for nullable
        Created   int64   `json:"created" db:"created"`
        Deleted   bool    `json:"deleted" db:"deleted"`
}

// ShareType represents the type of share
type ShareType string

const (
        ShareTypeUser    ShareType = "user"
        ShareTypeTeam    ShareType = "team"
        ShareTypeProject ShareType = "project"
        ShareTypePublic  ShareType = "public"
)

// GetShareType determines the share type based on which ID is set
func (f *FilterShareMapping) GetShareType() ShareType <span class="cov5" title="4">{
        if f.UserID != nil </span><span class="cov1" title="1">{
                return ShareTypeUser
        }</span>
        <span class="cov4" title="3">if f.TeamID != nil </span><span class="cov1" title="1">{
                return ShareTypeTeam
        }</span>
        <span class="cov3" title="2">if f.ProjectID != nil </span><span class="cov1" title="1">{
                return ShareTypeProject
        }</span>
        <span class="cov1" title="1">return ShareTypePublic</span>
}

// IsSharedWith checks if the filter is shared with a specific entity
func (f *Filter) IsSharedWith(userID, teamID, projectID string, shares []FilterShareMapping) bool <span class="cov7" title="9">{
        if f.IsPublic </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov7" title="8">for _, share := range shares </span><span class="cov10" title="18">{
                if share.Deleted </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov9" title="16">if share.UserID != nil &amp;&amp; *share.UserID == userID </span><span class="cov3" title="2">{
                        return true
                }</span>
                <span class="cov9" title="14">if share.TeamID != nil &amp;&amp; *share.TeamID == teamID </span><span class="cov3" title="2">{
                        return true
                }</span>
                <span class="cov8" title="12">if share.ProjectID != nil &amp;&amp; *share.ProjectID == projectID </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov4" title="3">return false</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package models

import (
        "strings"

        "github.com/golang-jwt/jwt/v5"
)

// JWTClaims represents the JWT token claims structure
type JWTClaims struct {
        jwt.RegisteredClaims
        Name          string `json:"name"`
        Username      string `json:"username"`
        Email         string `json:"email"`
        Role          string `json:"role"`
        Permissions   string `json:"permissions"`
        HTCoreAddress string `json:"htCoreAddress"`
}

// PermissionLevel represents the access level for permissions
type PermissionLevel int

const (
        PermissionNone   PermissionLevel = 0
        PermissionRead   PermissionLevel = 1
        PermissionCreate PermissionLevel = 2
        PermissionUpdate PermissionLevel = 3
        PermissionDelete PermissionLevel = 5 // Also represents ALL permissions
)

// Permission represents a permission context and level
type Permission struct {
        ID          string          `json:"id" db:"id"`
        Title       string          `json:"title" db:"title"`
        Description string          `json:"description,omitempty" db:"description"`
        Context     string          `json:"context" db:"context"` // Hierarchical context (node → account → organization → team/project)
        Level       PermissionLevel `json:"level" db:"level"`     // Access level
        Created     int64           `json:"created" db:"created"`
        Modified    int64           `json:"modified" db:"modified"`
        Deleted     bool            `json:"deleted" db:"deleted"`
}

// PermissionContext represents a hierarchical permission context
type PermissionContext struct {
        Type       string // node, account, organization, team, project, ticket
        Identifier string // UUID of the entity
        Parent     *PermissionContext
}

// PermissionCheck represents a permission check request
type PermissionCheck struct {
        Username       string
        Context        string
        RequiredLevel  PermissionLevel
        EntityType     string // ticket, project, board, etc.
        EntityID       string
        Action         string // create, read, update, delete
}

// HasPermission checks if a permission level is sufficient
func (p PermissionLevel) HasPermission(required PermissionLevel) bool <span class="cov10" title="25">{
        return p &gt;= required
}</span>

// String returns the string representation of permission level
func (p PermissionLevel) String() string <span class="cov6" title="7">{
        switch p </span>{
        case PermissionNone:<span class="cov2" title="2">
                return "NONE"</span>
        case PermissionRead:<span class="cov1" title="1">
                return "READ"</span>
        case PermissionCreate:<span class="cov1" title="1">
                return "CREATE"</span>
        case PermissionUpdate:<span class="cov1" title="1">
                return "UPDATE"</span>
        case PermissionDelete:<span class="cov1" title="1">
                return "DELETE"</span>
        default:<span class="cov1" title="1">
                return "UNKNOWN"</span>
        }
}

// ParsePermissionLevel parses a string to PermissionLevel
func ParsePermissionLevel(level string) PermissionLevel <span class="cov7" title="12">{
        switch strings.ToUpper(level) </span>{
        case "READ":<span class="cov4" title="4">
                return PermissionRead</span>
        case "CREATE":<span class="cov1" title="1">
                return PermissionCreate</span>
        case "UPDATE":<span class="cov2" title="2">
                return PermissionUpdate</span>
        case "DELETE", "ALL":<span class="cov4" title="3">
                return PermissionDelete</span>
        default:<span class="cov2" title="2">
                return PermissionNone</span>
        }
}

// BuildContextPath builds a hierarchical context path
func BuildContextPath(contexts ...string) string <span class="cov4" title="4">{
        return strings.Join(contexts, "→")
}</span>

// ParseContextPath parses a hierarchical context path
func ParseContextPath(path string) []string <span class="cov9" title="18">{
        return strings.Split(path, "→")
}</span>

// IsParentContext checks if parent is a parent of child in hierarchy
func IsParentContext(parent, child string) bool <span class="cov6" title="7">{
        parentParts := ParseContextPath(parent)
        childParts := ParseContextPath(child)

        if len(parentParts) &gt;= len(childParts) </span><span class="cov4" title="3">{
                return false
        }</span>

        <span class="cov4" title="4">for i, part := range parentParts </span><span class="cov5" title="5">{
                if childParts[i] != part </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        <span class="cov4" title="3">return true</span>
}

// GetRequiredPermissionLevel returns the required permission level for an action
func GetRequiredPermissionLevel(action string) PermissionLevel <span class="cov8" title="15">{
        // Extract base action from compound actions like "priorityCreate"
        actionLower := strings.ToLower(action)

        if strings.Contains(actionLower, "create") </span><span class="cov4" title="3">{
                return PermissionCreate
        }</span>
        <span class="cov7" title="12">if strings.Contains(actionLower, "modify") || strings.Contains(actionLower, "update") || strings.Contains(actionLower, "edit") </span><span class="cov4" title="4">{
                return PermissionUpdate
        }</span>
        <span class="cov6" title="8">if strings.Contains(actionLower, "remove") || strings.Contains(actionLower, "delete") </span><span class="cov4" title="3">{
                return PermissionDelete
        }</span>
        // read, list, get, etc.
        <span class="cov5" title="5">return PermissionRead</span>
}

// HasPermission checks if the JWT claims contain a specific permission level
func (c *JWTClaims) HasPermission(required int) bool <span class="cov4" title="4">{
        if c == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Parse permissions string (e.g., "READ|CREATE|UPDATE|DELETE")
        <span class="cov4" title="4">permissionLevel := ParsePermissionLevel(c.Permissions)
        requiredLevel := PermissionLevel(required)

        return permissionLevel.HasPermission(requiredLevel)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package models

// Label represents a categorization tag that can be applied to various entities
type Label struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Color       string `json:"color,omitempty" db:"color"` // Hex color code for visual identification
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// LabelCategory represents a category for organizing labels
type LabelCategory struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// LabelLabelCategoryMapping represents the many-to-many relationship between labels and categories
type LabelLabelCategoryMapping struct {
        ID              string `json:"id" db:"id"`
        LabelID         string `json:"labelId" db:"label_id" binding:"required"`
        LabelCategoryID string `json:"labelCategoryId" db:"label_category_id" binding:"required"`
        Created         int64  `json:"created" db:"created"`
        Modified        int64  `json:"modified" db:"modified"`
        Deleted         bool   `json:"deleted" db:"deleted"`
}

// LabelTicketMapping represents the many-to-many relationship between labels and tickets
type LabelTicketMapping struct {
        ID       string `json:"id" db:"id"`
        LabelID  string `json:"labelId" db:"label_id" binding:"required"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// LabelAssetMapping represents the many-to-many relationship between labels and assets
type LabelAssetMapping struct {
        ID       string `json:"id" db:"id"`
        LabelID  string `json:"labelId" db:"label_id" binding:"required"`
        AssetID  string `json:"assetId" db:"asset_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// LabelTeamMapping represents the many-to-many relationship between labels and teams
type LabelTeamMapping struct {
        ID       string `json:"id" db:"id"`
        LabelID  string `json:"labelId" db:"label_id" binding:"required"`
        TeamID   string `json:"teamId" db:"team_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// LabelProjectMapping represents the many-to-many relationship between labels and projects
type LabelProjectMapping struct {
        ID        string `json:"id" db:"id"`
        LabelID   string `json:"labelId" db:"label_id" binding:"required"`
        ProjectID string `json:"projectId" db:"project_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Modified  int64  `json:"modified" db:"modified"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// GetDisplayName returns a user-friendly display name
func (l *Label) GetDisplayName() string <span class="cov0" title="0">{
        if l.Title != "" </span><span class="cov0" title="0">{
                return l.Title
        }</span>
        <span class="cov0" title="0">return "Unknown Label"</span>
}

// IsValid checks if the label has required fields
func (l *Label) IsValid() bool <span class="cov0" title="0">{
        return l.Title != ""
}</span>

// GetDisplayName returns a user-friendly display name for the category
func (lc *LabelCategory) GetDisplayName() string <span class="cov0" title="0">{
        if lc.Title != "" </span><span class="cov0" title="0">{
                return lc.Title
        }</span>
        <span class="cov0" title="0">return "Unknown Category"</span>
}

// IsValid checks if the label category has required fields
func (lc *LabelCategory) IsValid() bool <span class="cov0" title="0">{
        return lc.Title != ""
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package models

// PermissionEntity represents a permission type in the system (database model)
type PermissionEntity struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Value       int    `json:"value" db:"value" binding:"required"` // 1=READ, 2=CREATE, 3=UPDATE, 5=DELETE
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// PermissionContextEntity represents a context in which permissions can be applied (database model)
// Contexts form a hierarchy: node → account → organization → team/project
type PermissionContextEntity struct {
        ID       string `json:"id" db:"id"`
        Context  string `json:"context" db:"context" binding:"required"` // node, account, organization, team, project
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// PermissionUserMapping maps permissions to users within a specific context
type PermissionUserMapping struct {
        ID                  string `json:"id" db:"id"`
        PermissionID        string `json:"permissionId" db:"permission_id" binding:"required"`
        UserID              string `json:"userId" db:"user_id" binding:"required"`
        PermissionContextID string `json:"permissionContextId" db:"permission_context_id" binding:"required"`
        Created             int64  `json:"created" db:"created"`
        Deleted             bool   `json:"deleted" db:"deleted"`
}

// PermissionTeamMapping maps permissions to teams within a specific context
type PermissionTeamMapping struct {
        ID                  string `json:"id" db:"id"`
        PermissionID        string `json:"permissionId" db:"permission_id" binding:"required"`
        TeamID              string `json:"teamId" db:"team_id" binding:"required"`
        PermissionContextID string `json:"permissionContextId" db:"permission_context_id" binding:"required"`
        Created             int64  `json:"created" db:"created"`
        Deleted             bool   `json:"deleted" db:"deleted"`
}

// IsValidPermissionValue validates if the permission value is one of the allowed values
func (p *PermissionEntity) IsValidPermissionValue() bool <span class="cov0" title="0">{
        return p.Value == int(PermissionRead) || p.Value == int(PermissionCreate) ||
                p.Value == int(PermissionUpdate) || p.Value == int(PermissionDelete)
}</span>

// IsValidContext validates if the context is one of the allowed contexts
func (pc *PermissionContextEntity) IsValidContext() bool <span class="cov0" title="0">{
        validContexts := []string{"node", "account", "organization", "team", "project"}
        for _, ctx := range validContexts </span><span class="cov0" title="0">{
                if pc.Context == ctx </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package models

// Priority represents a ticket priority level (Lowest, Low, Medium, High, Highest)
type Priority struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Level       int    `json:"level" db:"level" binding:"required"` // 1 (Lowest) to 5 (Highest)
        Icon        string `json:"icon,omitempty" db:"icon"`
        Color       string `json:"color,omitempty" db:"color"` // Hex color code
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// Priority level constants
const (
        PriorityLevelLowest  = 1
        PriorityLevelLow     = 2
        PriorityLevelMedium  = 3
        PriorityLevelHigh    = 4
        PriorityLevelHighest = 5
)

// Default priority IDs
const (
        PriorityIDLowest  = "priority-lowest"
        PriorityIDLow     = "priority-low"
        PriorityIDMedium  = "priority-medium"
        PriorityIDHigh    = "priority-high"
        PriorityIDHighest = "priority-highest"
)

// IsValidLevel checks if the priority level is valid (1-5)
func (p *Priority) IsValidLevel() bool <span class="cov10" title="14">{
        return p.Level &gt;= PriorityLevelLowest &amp;&amp; p.Level &lt;= PriorityLevelHighest
}</span>

// GetDisplayName returns a user-friendly display name
func (p *Priority) GetDisplayName() string <span class="cov8" title="8">{
        if p.Title != "" </span><span class="cov7" title="7">{
                return p.Title
        }</span>
        <span class="cov1" title="1">return "Unknown Priority"</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package models

import "time"

// Project represents a project in the system
type Project struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title"`
        Description string `json:"description" db:"description"`
        Identifier  string `json:"identifier" db:"identifier"` // Short project key like "PROJ"
        WorkflowID  string `json:"workflowId" db:"workflow_id"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// NewProject creates a new project with current timestamps
func NewProject(id, title, description, identifier, workflowID string) *Project <span class="cov0" title="0">{
        now := time.Now().Unix()
        return &amp;Project{
                ID:          id,
                Title:       title,
                Description: description,
                Identifier:  identifier,
                WorkflowID:  workflowID,
                Created:     now,
                Modified:    now,
                Deleted:     false,
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package models

// Report represents a saved report definition
type Report struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Query       string `json:"query" db:"query"`              // JSON query definition
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// ReportMetaData represents additional metadata for reports
type ReportMetaData struct {
        ID       string `json:"id" db:"id"`
        ReportID string `json:"reportId" db:"report_id" binding:"required"`
        Property string `json:"property" db:"property" binding:"required"`
        Value    string `json:"value" db:"value"`
        Created  int64  `json:"created" db:"created"`
        Modified int64  `json:"modified" db:"modified"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// IsValid validates if the report has required fields
func (r *Report) IsValid() bool <span class="cov0" title="0">{
        return r.Title != ""
}</span>

// HasQuery checks if the report has a query definition
func (r *Report) HasQuery() bool <span class="cov0" title="0">{
        return r.Query != ""
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package models

// Request represents the unified API request format for the /do endpoint
type Request struct {
        Action string                 `json:"action" binding:"required"` // authenticate, version, jwtCapable, dbCapable, health, create, modify, remove
        JWT    string                 `json:"jwt"`                       // Required for authenticated actions
        Locale string                 `json:"locale"`                    // Optional locale for localized responses
        Object string                 `json:"object"`                    // Required for CRUD operations (create, modify, remove)
        Data   map[string]interface{} `json:"data"`                      // Additional data for the action
}

// IsAuthenticationRequired returns true if the action requires JWT authentication
func (r *Request) IsAuthenticationRequired() bool <span class="cov10" title="11">{
        switch r.Action </span>{
        case ActionVersion, ActionJWTCapable, ActionDBCapable, ActionHealth, ActionAuthenticate:<span class="cov7" title="5">
                return false</span>
        default:<span class="cov7" title="6">
                return true</span>
        }
}

// IsCRUDOperation returns true if the action is a CRUD operation requiring an object
func (r *Request) IsCRUDOperation() bool <span class="cov8" title="7">{
        switch r.Action </span>{
        case ActionCreate, ActionModify, ActionRemove:<span class="cov5" title="3">
                return true</span>
        default:<span class="cov6" title="4">
                return false</span>
        }
}

// Action constants
const (
        // System actions
        ActionAuthenticate = "authenticate"
        ActionVersion      = "version"
        ActionJWTCapable   = "jwtCapable"
        ActionDBCapable    = "dbCapable"
        ActionHealth       = "health"

        // Generic CRUD actions
        ActionCreate = "create"
        ActionModify = "modify"
        ActionRemove = "remove"
        ActionRead   = "read"
        ActionList   = "list"

        // Priority actions
        ActionPriorityCreate = "priorityCreate"
        ActionPriorityRead   = "priorityRead"
        ActionPriorityList   = "priorityList"
        ActionPriorityModify = "priorityModify"
        ActionPriorityRemove = "priorityRemove"

        // Resolution actions
        ActionResolutionCreate = "resolutionCreate"
        ActionResolutionRead   = "resolutionRead"
        ActionResolutionList   = "resolutionList"
        ActionResolutionModify = "resolutionModify"
        ActionResolutionRemove = "resolutionRemove"

        // Version actions
        ActionVersionCreate  = "versionCreate"
        ActionVersionRead    = "versionRead"
        ActionVersionList    = "versionList"
        ActionVersionModify  = "versionModify"
        ActionVersionRemove  = "versionRemove"
        ActionVersionRelease = "versionRelease" // Mark version as released
        ActionVersionArchive = "versionArchive" // Archive a version

        // Version mapping actions
        ActionVersionAddAffected    = "versionAddAffected"    // Add affected version to ticket
        ActionVersionRemoveAffected = "versionRemoveAffected" // Remove affected version from ticket
        ActionVersionListAffected   = "versionListAffected"   // List affected versions for ticket
        ActionVersionAddFix         = "versionAddFix"         // Add fix version to ticket
        ActionVersionRemoveFix      = "versionRemoveFix"      // Remove fix version from ticket
        ActionVersionListFix        = "versionListFix"        // List fix versions for ticket

        // Watcher actions
        ActionWatcherAdd    = "watcherAdd"    // Start watching a ticket
        ActionWatcherRemove = "watcherRemove" // Stop watching a ticket
        ActionWatcherList   = "watcherList"   // List watchers for a ticket

        // Filter actions
        ActionFilterSave   = "filterSave"   // Create or update a saved filter
        ActionFilterLoad   = "filterLoad"   // Load a saved filter
        ActionFilterList   = "filterList"   // List user's filters
        ActionFilterShare  = "filterShare"  // Share a filter
        ActionFilterModify = "filterModify" // Modify a filter
        ActionFilterRemove = "filterRemove" // Delete a filter

        // Custom field actions
        ActionCustomFieldCreate = "customFieldCreate"
        ActionCustomFieldRead   = "customFieldRead"
        ActionCustomFieldList   = "customFieldList"
        ActionCustomFieldModify = "customFieldModify"
        ActionCustomFieldRemove = "customFieldRemove"

        // Custom field option actions
        ActionCustomFieldOptionCreate = "customFieldOptionCreate"
        ActionCustomFieldOptionModify = "customFieldOptionModify"
        ActionCustomFieldOptionRemove = "customFieldOptionRemove"
        ActionCustomFieldOptionList   = "customFieldOptionList"

        // Custom field value actions (for tickets)
        ActionCustomFieldValueSet    = "customFieldValueSet"    // Set custom field value for a ticket
        ActionCustomFieldValueGet    = "customFieldValueGet"    // Get custom field value for a ticket
        ActionCustomFieldValueList   = "customFieldValueList"   // List all custom field values for a ticket
        ActionCustomFieldValueRemove = "customFieldValueRemove" // Remove custom field value from a ticket

        // Workflow actions
        ActionWorkflowCreate = "workflowCreate"
        ActionWorkflowRead   = "workflowRead"
        ActionWorkflowList   = "workflowList"
        ActionWorkflowModify = "workflowModify"
        ActionWorkflowRemove = "workflowRemove"

        // Workflow step actions
        ActionWorkflowStepCreate = "workflowStepCreate"
        ActionWorkflowStepRead   = "workflowStepRead"
        ActionWorkflowStepList   = "workflowStepList"
        ActionWorkflowStepModify = "workflowStepModify"
        ActionWorkflowStepRemove = "workflowStepRemove"

        // Ticket status actions
        ActionTicketStatusCreate = "ticketStatusCreate"
        ActionTicketStatusRead   = "ticketStatusRead"
        ActionTicketStatusList   = "ticketStatusList"
        ActionTicketStatusModify = "ticketStatusModify"
        ActionTicketStatusRemove = "ticketStatusRemove"

        // Ticket type actions
        ActionTicketTypeCreate        = "ticketTypeCreate"
        ActionTicketTypeRead          = "ticketTypeRead"
        ActionTicketTypeList          = "ticketTypeList"
        ActionTicketTypeModify        = "ticketTypeModify"
        ActionTicketTypeRemove        = "ticketTypeRemove"
        ActionTicketTypeAssign        = "ticketTypeAssign"        // Assign type to project
        ActionTicketTypeUnassign      = "ticketTypeUnassign"      // Unassign type from project
        ActionTicketTypeListByProject = "ticketTypeListByProject" // List types assigned to a project

        // Board actions
        ActionBoardCreate = "boardCreate"
        ActionBoardRead   = "boardRead"
        ActionBoardList   = "boardList"
        ActionBoardModify = "boardModify"
        ActionBoardRemove = "boardRemove"

        // Board ticket assignment
        ActionBoardAddTicket    = "boardAddTicket"
        ActionBoardRemoveTicket = "boardRemoveTicket"
        ActionBoardListTickets  = "boardListTickets"

        // Board metadata
        ActionBoardSetMetadata    = "boardSetMetadata"
        ActionBoardGetMetadata    = "boardGetMetadata"
        ActionBoardListMetadata   = "boardListMetadata"
        ActionBoardRemoveMetadata = "boardRemoveMetadata"

        // Cycle actions (Sprint/Milestone/Release management)
        ActionCycleCreate = "cycleCreate"
        ActionCycleRead   = "cycleRead"
        ActionCycleList   = "cycleList"
        ActionCycleModify = "cycleModify"
        ActionCycleRemove = "cycleRemove"

        // Cycle-project mapping
        ActionCycleAssignProject   = "cycleAssignProject"   // Assign cycle to project
        ActionCycleUnassignProject = "cycleUnassignProject" // Unassign cycle from project
        ActionCycleListProjects    = "cycleListProjects"    // List projects assigned to cycle

        // Cycle-ticket mapping
        ActionCycleAddTicket    = "cycleAddTicket"    // Add ticket to cycle
        ActionCycleRemoveTicket = "cycleRemoveTicket" // Remove ticket from cycle
        ActionCycleListTickets  = "cycleListTickets"  // List tickets in cycle

        // Account actions (Multi-tenancy support)
        ActionAccountCreate = "accountCreate"
        ActionAccountRead   = "accountRead"
        ActionAccountList   = "accountList"
        ActionAccountModify = "accountModify"
        ActionAccountRemove = "accountRemove"

        // Organization actions
        ActionOrganizationCreate        = "organizationCreate"
        ActionOrganizationRead          = "organizationRead"
        ActionOrganizationList          = "organizationList"
        ActionOrganizationModify        = "organizationModify"
        ActionOrganizationRemove        = "organizationRemove"
        ActionOrganizationAssignAccount = "organizationAssignAccount" // Assign organization to account
        ActionOrganizationListAccounts  = "organizationListAccounts"  // List accounts for organization

        // Team actions
        ActionTeamCreate              = "teamCreate"
        ActionTeamRead                = "teamRead"
        ActionTeamList                = "teamList"
        ActionTeamModify              = "teamModify"
        ActionTeamRemove              = "teamRemove"
        ActionTeamAssignOrganization  = "teamAssignOrganization"  // Assign team to organization
        ActionTeamUnassignOrganization = "teamUnassignOrganization" // Unassign team from organization
        ActionTeamListOrganizations   = "teamListOrganizations"   // List organizations for team
        ActionTeamAssignProject       = "teamAssignProject"       // Assign team to project
        ActionTeamUnassignProject     = "teamUnassignProject"     // Unassign team from project
        ActionTeamListProjects        = "teamListProjects"        // List projects for team

        // User-Organization mapping
        ActionUserAssignOrganization = "userAssignOrganization" // Assign user to organization
        ActionUserListOrganizations  = "userListOrganizations"  // List organizations for user
        ActionOrganizationListUsers  = "organizationListUsers"  // List users in organization

        // User-Team mapping
        ActionUserAssignTeam = "userAssignTeam" // Assign user to team
        ActionUserListTeams  = "userListTeams"  // List teams for user
        ActionTeamListUsers  = "teamListUsers"  // List users in team

        // Component actions
        ActionComponentCreate = "componentCreate"
        ActionComponentRead   = "componentRead"
        ActionComponentList   = "componentList"
        ActionComponentModify = "componentModify"
        ActionComponentRemove = "componentRemove"

        // Component-ticket mapping
        ActionComponentAddTicket    = "componentAddTicket"    // Add component to ticket
        ActionComponentRemoveTicket = "componentRemoveTicket" // Remove component from ticket
        ActionComponentListTickets  = "componentListTickets"  // List tickets for component

        // Component metadata
        ActionComponentSetMetadata    = "componentSetMetadata"    // Set component metadata
        ActionComponentGetMetadata    = "componentGetMetadata"    // Get component metadata
        ActionComponentListMetadata   = "componentListMetadata"   // List all metadata for component
        ActionComponentRemoveMetadata = "componentRemoveMetadata" // Remove component metadata

        // Label actions
        ActionLabelCreate = "labelCreate"
        ActionLabelRead   = "labelRead"
        ActionLabelList   = "labelList"
        ActionLabelModify = "labelModify"
        ActionLabelRemove = "labelRemove"

        // Label category actions
        ActionLabelCategoryCreate = "labelCategoryCreate"
        ActionLabelCategoryRead   = "labelCategoryRead"
        ActionLabelCategoryList   = "labelCategoryList"
        ActionLabelCategoryModify = "labelCategoryModify"
        ActionLabelCategoryRemove = "labelCategoryRemove"

        // Label-ticket mapping
        ActionLabelAddTicket    = "labelAddTicket"    // Add label to ticket
        ActionLabelRemoveTicket = "labelRemoveTicket" // Remove label from ticket
        ActionLabelListTickets  = "labelListTickets"  // List tickets for label

        // Label-category mapping
        ActionLabelAssignCategory   = "labelAssignCategory"   // Assign label to category
        ActionLabelUnassignCategory = "labelUnassignCategory" // Unassign label from category
        ActionLabelListCategories   = "labelListCategories"   // List categories for label

        // Asset actions
        ActionAssetCreate = "assetCreate"
        ActionAssetRead   = "assetRead"
        ActionAssetList   = "assetList"
        ActionAssetModify = "assetModify"
        ActionAssetRemove = "assetRemove"

        // Asset-ticket mapping
        ActionAssetAddTicket    = "assetAddTicket"    // Add asset to ticket
        ActionAssetRemoveTicket = "assetRemoveTicket" // Remove asset from ticket
        ActionAssetListTickets  = "assetListTickets"  // List tickets for asset

        // Asset-comment mapping
        ActionAssetAddComment    = "assetAddComment"    // Add asset to comment
        ActionAssetRemoveComment = "assetRemoveComment" // Remove asset from comment
        ActionAssetListComments  = "assetListComments"  // List comments for asset

        // Asset-project mapping
        ActionAssetAddProject    = "assetAddProject"    // Add asset to project
        ActionAssetRemoveProject = "assetRemoveProject" // Remove asset from project
        ActionAssetListProjects  = "assetListProjects"  // List projects for asset

        // Permission actions
        ActionPermissionCreate = "permissionCreate"
        ActionPermissionRead   = "permissionRead"
        ActionPermissionList   = "permissionList"
        ActionPermissionModify = "permissionModify"
        ActionPermissionRemove = "permissionRemove"

        // Permission context actions
        ActionPermissionContextCreate = "permissionContextCreate"
        ActionPermissionContextRead   = "permissionContextRead"
        ActionPermissionContextList   = "permissionContextList"
        ActionPermissionContextModify = "permissionContextModify"
        ActionPermissionContextRemove = "permissionContextRemove"

        // Permission-user mapping actions
        ActionPermissionAssignUser   = "permissionAssignUser"   // Assign permission to user
        ActionPermissionUnassignUser = "permissionUnassignUser" // Unassign permission from user

        // Permission-team mapping actions
        ActionPermissionAssignTeam   = "permissionAssignTeam"   // Assign permission to team
        ActionPermissionUnassignTeam = "permissionUnassignTeam" // Unassign permission from team

        // Permission query action
        ActionPermissionCheck = "permissionCheck" // Check if user has permission

        // Audit actions
        ActionAuditCreate  = "auditCreate"  // Create audit entry
        ActionAuditRead    = "auditRead"    // Read audit entry
        ActionAuditList    = "auditList"    // List audit entries
        ActionAuditQuery   = "auditQuery"   // Query audit entries with filters
        ActionAuditAddMeta = "auditAddMeta" // Add metadata to audit entry

        // Report actions
        ActionReportCreate  = "reportCreate"  // Create report
        ActionReportRead    = "reportRead"    // Read report
        ActionReportList    = "reportList"    // List reports
        ActionReportModify  = "reportModify"  // Modify report
        ActionReportRemove  = "reportRemove"  // Remove report
        ActionReportExecute = "reportExecute" // Execute/run report

        // Report metadata actions
        ActionReportSetMetadata    = "reportSetMetadata"    // Set report metadata
        ActionReportGetMetadata    = "reportGetMetadata"    // Get report metadata
        ActionReportRemoveMetadata = "reportRemoveMetadata" // Remove report metadata

        // Extension actions
        ActionExtensionCreate  = "extensionCreate"  // Create/register extension
        ActionExtensionRead    = "extensionRead"    // Read extension
        ActionExtensionList    = "extensionList"    // List extensions
        ActionExtensionModify  = "extensionModify"  // Modify extension
        ActionExtensionRemove  = "extensionRemove"  // Remove extension
        ActionExtensionEnable  = "extensionEnable"  // Enable extension
        ActionExtensionDisable = "extensionDisable" // Disable extension

        // Extension metadata actions
        ActionExtensionSetMetadata = "extensionSetMetadata" // Set extension metadata

        // Repository actions
        ActionRepositoryCreate = "repositoryCreate"
        ActionRepositoryRead   = "repositoryRead"
        ActionRepositoryList   = "repositoryList"
        ActionRepositoryModify = "repositoryModify"
        ActionRepositoryRemove = "repositoryRemove"

        // Repository type actions
        ActionRepositoryTypeCreate = "repositoryTypeCreate"
        ActionRepositoryTypeRead   = "repositoryTypeRead"
        ActionRepositoryTypeList   = "repositoryTypeList"
        ActionRepositoryTypeModify = "repositoryTypeModify"
        ActionRepositoryTypeRemove = "repositoryTypeRemove"

        // Repository-project mapping
        ActionRepositoryAssignProject   = "repositoryAssignProject"   // Assign repository to project
        ActionRepositoryUnassignProject = "repositoryUnassignProject" // Unassign repository from project
        ActionRepositoryListProjects    = "repositoryListProjects"    // List projects for repository

        // Repository-commit-ticket mapping
        ActionRepositoryAddCommit    = "repositoryAddCommit"    // Add commit to ticket
        ActionRepositoryRemoveCommit = "repositoryRemoveCommit" // Remove commit from ticket
        ActionRepositoryListCommits  = "repositoryListCommits"  // List commits for ticket
        ActionRepositoryGetCommit    = "repositoryGetCommit"    // Get commit details

        // Ticket relationship type actions
        ActionTicketRelationshipTypeCreate = "ticketRelationshipTypeCreate"
        ActionTicketRelationshipTypeRead   = "ticketRelationshipTypeRead"
        ActionTicketRelationshipTypeList   = "ticketRelationshipTypeList"
        ActionTicketRelationshipTypeModify = "ticketRelationshipTypeModify"
        ActionTicketRelationshipTypeRemove = "ticketRelationshipTypeRemove"

        // Ticket relationship actions
        ActionTicketRelationshipCreate = "ticketRelationshipCreate" // Create relationship between tickets
        ActionTicketRelationshipRemove = "ticketRelationshipRemove" // Remove relationship between tickets
        ActionTicketRelationshipList   = "ticketRelationshipList"   // List relationships for a ticket
)
</pre>
		
		<pre class="file" id="file59" style="display: none">package models

// Resolution represents how a ticket was resolved
type Resolution struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// Default resolution IDs
const (
        ResolutionIDFixed            = "resolution-fixed"
        ResolutionIDWontFix          = "resolution-wont-fix"
        ResolutionIDDuplicate        = "resolution-duplicate"
        ResolutionIDIncomplete       = "resolution-incomplete"
        ResolutionIDCannotReproduce  = "resolution-cannot-reproduce"
        ResolutionIDDone             = "resolution-done"
)

// GetDisplayName returns a user-friendly display name
func (r *Resolution) GetDisplayName() string <span class="cov10" title="9">{
        if r.Title != "" </span><span class="cov9" title="8">{
                return r.Title
        }</span>
        <span class="cov1" title="1">return "Unknown Resolution"</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package models

// Response represents the unified API response format
type Response struct {
        ErrorCode              int                    `json:"errorCode"`                        // -1 means no error
        ErrorMessage           string                 `json:"errorMessage,omitempty"`           // Error message in English
        ErrorMessageLocalised  string                 `json:"errorMessageLocalised,omitempty"`  // Localized error message
        Data                   map[string]interface{} `json:"data,omitempty"`                   // Response data
}

// NewSuccessResponse creates a successful response with optional data
func NewSuccessResponse(data map[string]interface{}) *Response <span class="cov7" title="3">{
        return &amp;Response{
                ErrorCode: ErrorCodeNoError,
                Data:      data,
        }
}</span>

// NewErrorResponse creates an error response
func NewErrorResponse(code int, message string, localisedMessage string) *Response <span class="cov4" title="2">{
        return &amp;Response{
                ErrorCode:             code,
                ErrorMessage:          message,
                ErrorMessageLocalised: localisedMessage,
        }
}</span>

// IsSuccess returns true if the response indicates success
func (r *Response) IsSuccess() bool <span class="cov10" title="5">{
        return r.ErrorCode == ErrorCodeNoError
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package models

import (
        "crypto/sha256"
        "encoding/hex"
        "time"
)

// ServiceType represents the type of service
type ServiceType string

const (
        ServiceTypeAuthentication ServiceType = "authentication"
        ServiceTypePermissions    ServiceType = "permissions"
        ServiceTypeLokalization   ServiceType = "lokalisation"
        ServiceTypeExtension      ServiceType = "extension"
)

// ServiceRole represents the role of a service in failover scenarios
type ServiceRole string

const (
        ServiceRolePrimary ServiceRole = "primary"
        ServiceRoleBackup  ServiceRole = "backup"
)

// ServiceStatus represents the current status of a service
type ServiceStatus string

const (
        ServiceStatusHealthy      ServiceStatus = "healthy"
        ServiceStatusUnhealthy    ServiceStatus = "unhealthy"
        ServiceStatusRegistering  ServiceStatus = "registering"
        ServiceStatusRotating     ServiceStatus = "rotating"
        ServiceStatusDecommission ServiceStatus = "decommissioned"
)

// ServiceRegistration represents a registered service in the system
type ServiceRegistration struct {
        ID                string        `json:"id"`                  // Unique service ID (UUID)
        Name              string        `json:"name"`                // Service name
        Type              ServiceType   `json:"type"`                // Service type
        Version           string        `json:"version"`             // Service version
        URL               string        `json:"url"`                 // Service base URL
        HealthCheckURL    string        `json:"health_check_url"`    // Health check endpoint
        PublicKey         string        `json:"public_key"`          // RSA public key for verification
        Signature         string        `json:"signature"`           // Service metadata signature
        Certificate       string        `json:"certificate"`         // TLS certificate (PEM format)
        Status            ServiceStatus `json:"status"`              // Current status
        Role              ServiceRole   `json:"role"`                // Service role (primary/backup)
        FailoverGroup     string        `json:"failover_group"`      // Failover group identifier
        IsActive          bool          `json:"is_active"`           // Currently active service for its group
        Priority          int           `json:"priority"`            // Service priority (higher = preferred)
        Metadata          string        `json:"metadata"`            // JSON metadata
        RegisteredBy      string        `json:"registered_by"`       // Username who registered
        RegisteredAt      time.Time     `json:"registered_at"`       // Registration timestamp
        LastHealthCheck   time.Time     `json:"last_health_check"`   // Last health check timestamp
        HealthCheckCount  int           `json:"health_check_count"`  // Total health checks performed
        FailedHealthCount int           `json:"failed_health_count"` // Failed health check count
        LastFailoverAt    time.Time     `json:"last_failover_at"`    // Last failover timestamp
        Deleted           bool          `json:"deleted"`             // Soft delete flag
}

// ServiceHealthCheck represents a health check record
type ServiceHealthCheck struct {
        ID            string        `json:"id"`              // Unique check ID
        ServiceID     string        `json:"service_id"`      // Service being checked
        Timestamp     time.Time     `json:"timestamp"`       // Check timestamp
        Status        ServiceStatus `json:"status"`          // Health status result
        ResponseTime  int64         `json:"response_time"`   // Response time in milliseconds
        StatusCode    int           `json:"status_code"`     // HTTP status code
        ErrorMessage  string        `json:"error_message"`   // Error message if unhealthy
        CheckedBy     string        `json:"checked_by"`      // System/user performing check
}

// ServiceRotationRequest represents a request to rotate a service
type ServiceRotationRequest struct {
        CurrentServiceID string              `json:"current_service_id"` // Service to be replaced
        NewService       ServiceRegistration `json:"new_service"`        // New service to replace with
        Reason           string              `json:"reason"`             // Reason for rotation
        RequestedBy      string              `json:"requested_by"`       // User requesting rotation
        AdminToken       string              `json:"admin_token"`        // Admin authorization token
        VerificationCode string              `json:"verification_code"`  // Additional verification code
}

// ServiceRotationResponse represents the response to a rotation request
type ServiceRotationResponse struct {
        Success          bool      `json:"success"`
        OldServiceID     string    `json:"old_service_id"`
        NewServiceID     string    `json:"new_service_id"`
        RotationTime     time.Time `json:"rotation_time"`
        VerificationHash string    `json:"verification_hash"` // Hash for audit trail
        Message          string    `json:"message"`
}

// ServiceDiscoveryRequest represents a request to discover services
type ServiceDiscoveryRequest struct {
        Type       ServiceType `json:"type"`        // Type of service to discover
        MinVersion string      `json:"min_version"` // Minimum version required
        OnlyHealthy bool       `json:"only_healthy"` // Return only healthy services
}

// ServiceDiscoveryResponse represents the response with discovered services
type ServiceDiscoveryResponse struct {
        Services   []ServiceRegistration `json:"services"`
        TotalCount int                   `json:"total_count"`
        Timestamp  time.Time             `json:"timestamp"`
}

// ComputeServiceSignature computes a signature for service metadata
func (s *ServiceRegistration) ComputeServiceSignature() string <span class="cov0" title="0">{
        data := s.ID + s.Name + string(s.Type) + s.Version + s.URL + s.PublicKey
        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

// VerifySignature verifies the service signature matches the computed signature
func (s *ServiceRegistration) VerifySignature() bool <span class="cov0" title="0">{
        expectedSignature := s.ComputeServiceSignature()
        return s.Signature == expectedSignature
}</span>

// IsHealthy returns whether the service is currently healthy
func (s *ServiceRegistration) IsHealthy() bool <span class="cov0" title="0">{
        return s.Status == ServiceStatusHealthy
}</span>

// CanRotate returns whether the service can be rotated
func (s *ServiceRegistration) CanRotate() bool <span class="cov0" title="0">{
        return s.Status != ServiceStatusRotating &amp;&amp; s.Status != ServiceStatusDecommission
}</span>

// ServiceFailoverEvent represents a failover event
type ServiceFailoverEvent struct {
        ID              string        `json:"id"`               // Unique event ID
        FailoverGroup   string        `json:"failover_group"`   // Failover group
        ServiceType     ServiceType   `json:"service_type"`     // Type of service
        OldServiceID    string        `json:"old_service_id"`   // Previous active service
        NewServiceID    string        `json:"new_service_id"`   // New active service
        FailoverReason  string        `json:"failover_reason"`  // Reason for failover
        FailoverType    string        `json:"failover_type"`    // "failover" or "failback"
        Timestamp       time.Time     `json:"timestamp"`        // When failover occurred
        Automatic       bool          `json:"automatic"`        // Was it automatic or manual
}

// ServiceRegistrationRequest represents a request to register a new service
type ServiceRegistrationRequest struct {
        Name           string      `json:"name"`
        Type           ServiceType `json:"type"`
        Version        string      `json:"version"`
        URL            string      `json:"url"`
        HealthCheckURL string      `json:"health_check_url"`
        PublicKey      string      `json:"public_key"`
        Certificate    string      `json:"certificate"`
        Role           ServiceRole `json:"role"`            // primary or backup
        FailoverGroup  string      `json:"failover_group"`  // Failover group (optional)
        Priority       int         `json:"priority"`
        Metadata       string      `json:"metadata"`
        AdminToken     string      `json:"admin_token"` // Required for registration
}

// ServiceUpdateRequest represents a request to update service metadata
type ServiceUpdateRequest struct {
        ServiceID      string `json:"service_id"`
        Version        string `json:"version,omitempty"`
        URL            string `json:"url,omitempty"`
        HealthCheckURL string `json:"health_check_url,omitempty"`
        Priority       int    `json:"priority,omitempty"`
        Metadata       string `json:"metadata,omitempty"`
        AdminToken     string `json:"admin_token"` // Required for update
}

// ServiceDecommissionRequest represents a request to decommission a service
type ServiceDecommissionRequest struct {
        ServiceID  string `json:"service_id"`
        Reason     string `json:"reason"`
        AdminToken string `json:"admin_token"` // Required for decommission
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package models

import "time"

// Ticket represents a ticket/issue in the system
type Ticket struct {
        ID             string  `json:"id" db:"id"`
        TicketNumber   int     `json:"ticketNumber" db:"ticket_number"`
        Title          string  `json:"title" db:"title"`
        Description    string  `json:"description" db:"description"`
        TicketTypeID   string  `json:"ticketTypeId" db:"ticket_type_id"`
        TicketStatusID string  `json:"ticketStatusId" db:"ticket_status_id"`
        ProjectID      string  `json:"projectId" db:"project_id"`
        UserID         string  `json:"userId" db:"user_id"`         // Assignee
        Creator        string  `json:"creator" db:"creator"`        // Creator username
        Estimation     *int    `json:"estimation" db:"estimation"`  // In hours
        StoryPoints    *int    `json:"storyPoints" db:"story_points"`
        Created        int64   `json:"created" db:"created"`
        Modified       int64   `json:"modified" db:"modified"`
        Deleted        bool    `json:"deleted" db:"deleted"`
}

// NewTicket creates a new ticket with current timestamps
func NewTicket(id, title, description, ticketTypeID, ticketStatusID, projectID, userID, creator string, ticketNumber int) *Ticket <span class="cov0" title="0">{
        now := time.Now().Unix()
        return &amp;Ticket{
                ID:             id,
                TicketNumber:   ticketNumber,
                Title:          title,
                Description:    description,
                TicketTypeID:   ticketTypeID,
                TicketStatusID: ticketStatusID,
                ProjectID:      projectID,
                UserID:         userID,
                Creator:        creator,
                Created:        now,
                Modified:       now,
                Deleted:        false,
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package models

// Version represents a product version/release
type Version struct {
        ID          string `json:"id" db:"id"`
        Title       string `json:"title" db:"title" binding:"required"`
        Description string `json:"description,omitempty" db:"description"`
        ProjectID   string `json:"projectId" db:"project_id" binding:"required"`
        StartDate   *int64 `json:"startDate,omitempty" db:"start_date"`   // Unix timestamp, pointer for nullable
        ReleaseDate *int64 `json:"releaseDate,omitempty" db:"release_date"` // Unix timestamp, pointer for nullable
        Released    bool   `json:"released" db:"released"`
        Archived    bool   `json:"archived" db:"archived"`
        Created     int64  `json:"created" db:"created"`
        Modified    int64  `json:"modified" db:"modified"`
        Deleted     bool   `json:"deleted" db:"deleted"`
}

// TicketVersionMapping represents the relationship between a ticket and a version
type TicketVersionMapping struct {
        ID        string `json:"id" db:"id"`
        TicketID  string `json:"ticketId" db:"ticket_id" binding:"required"`
        VersionID string `json:"versionId" db:"version_id" binding:"required"`
        Created   int64  `json:"created" db:"created"`
        Deleted   bool   `json:"deleted" db:"deleted"`
}

// IsReleased checks if the version has been released
func (v *Version) IsReleased() bool <span class="cov9" title="8">{
        return v.Released
}</span>

// IsArchived checks if the version is archived
func (v *Version) IsArchived() bool <span class="cov5" title="3">{
        return v.Archived
}</span>

// IsActive checks if the version is active (not archived and not deleted)
func (v *Version) IsActive() bool <span class="cov10" title="10">{
        return !v.Archived &amp;&amp; !v.Deleted
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package models

// TicketWatcherMapping represents a user watching a ticket for notifications
type TicketWatcherMapping struct {
        ID       string `json:"id" db:"id"`
        TicketID string `json:"ticketId" db:"ticket_id" binding:"required"`
        UserID   string `json:"userId" db:"user_id" binding:"required"`
        Created  int64  `json:"created" db:"created"`
        Deleted  bool   `json:"deleted" db:"deleted"`
}

// IsWatching checks if a user is watching a specific ticket
func IsWatching(userID, ticketID string, watchers []TicketWatcherMapping) bool <span class="cov7" title="11">{
        for _, watcher := range watchers </span><span class="cov10" title="27">{
                if watcher.UserID == userID &amp;&amp; watcher.TicketID == ticketID &amp;&amp; !watcher.Deleted </span><span class="cov5" title="6">{
                        return true
                }</span>
        }
        <span class="cov5" title="5">return false</span>
}

// GetWatcherCount returns the number of active watchers for a ticket
func GetWatcherCount(ticketID string, watchers []TicketWatcherMapping) int <span class="cov4" title="4">{
        count := 0
        for _, watcher := range watchers </span><span class="cov7" title="12">{
                if watcher.TicketID == ticketID &amp;&amp; !watcher.Deleted </span><span class="cov4" title="3">{
                        count++
                }</span>
        }
        <span class="cov4" title="4">return count</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package models

import (
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

// Client represents a WebSocket client connection
type Client struct {
        ID           string              // Unique client ID
        Conn         *websocket.Conn     // WebSocket connection
        Username     string              // Authenticated username
        Claims       *JWTClaims          // JWT claims from authentication
        Subscription *Subscription       // Current subscription preferences
        Send         chan []byte         // Buffered channel for outbound messages
        Manager      ClientManager       // Reference to the manager (for unregister)
        mu           sync.RWMutex        // Mutex for thread-safe operations
        Connected    time.Time           // Connection timestamp
        LastPing     time.Time           // Last ping timestamp
        LastActivity time.Time           // Last activity timestamp
        Metadata     map[string]string   // Additional client metadata
}

// ClientManager interface for managing clients (to avoid circular dependency)
type ClientManager interface {
        UnregisterClient(*Client)
}

// NewClient creates a new WebSocket client
func NewClient(id string, conn *websocket.Conn, username string, claims *JWTClaims, manager ClientManager) *Client <span class="cov6" title="14">{
        now := time.Now()
        return &amp;Client{
                ID:           id,
                Conn:         conn,
                Username:     username,
                Claims:       claims,
                Subscription: &amp;Subscription{
                        EventTypes:   []EventType{},
                        EntityTypes:  []string{},
                        EntityIDs:    []string{},
                        Filters:      make(map[string]string),
                        IncludeReads: false,
                },
                Send:         make(chan []byte, 256), // Buffer size of 256 messages
                Manager:      manager,
                Connected:    now,
                LastPing:     now,
                LastActivity: now,
                Metadata:     make(map[string]string),
        }
}</span>

// UpdateSubscription safely updates the client's subscription
func (c *Client) UpdateSubscription(sub *Subscription) <span class="cov9" title="101">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.Subscription = sub
}</span>

// GetSubscription safely gets the client's subscription
func (c *Client) GetSubscription() *Subscription <span class="cov10" title="103">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Subscription
}</span>

// UpdateActivity updates the last activity timestamp
func (c *Client) UpdateActivity() <span class="cov9" title="101">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.LastActivity = time.Now()
}</span>

// UpdatePing updates the last ping timestamp
func (c *Client) UpdatePing() <span class="cov9" title="101">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.LastPing = time.Now()
}</span>

// GetLastActivity gets the last activity timestamp
func (c *Client) GetLastActivity() time.Time <span class="cov3" title="4">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.LastActivity
}</span>

// GetLastPing gets the last ping timestamp
func (c *Client) GetLastPing() time.Time <span class="cov3" title="4">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.LastPing
}</span>

// Close closes the client connection and channels
func (c *Client) Close() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Close the send channel
        select </span>{
        case &lt;-c.Send:<span class="cov0" title="0"></span>
                // Channel already closed
        default:<span class="cov0" title="0">
                close(c.Send)</span>
        }

        // Close the WebSocket connection
        <span class="cov0" title="0">if c.Conn != nil </span><span class="cov0" title="0">{
                c.Conn.Close()
        }</span>
}

// HasPermission checks if the client has a specific permission
func (c *Client) HasPermission(permission int) bool <span class="cov4" title="5">{
        if c.Claims == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov3" title="4">return c.Claims.HasPermission(permission)</span>
}

// WebSocketMessage represents a message sent/received via WebSocket
type WebSocketMessage struct {
        Type    string                 `json:"type"`    // Message type (subscribe, unsubscribe, event, ping, pong, error)
        Action  string                 `json:"action"`  // Action for the message
        Data    map[string]interface{} `json:"data"`    // Message data
        EventID string                 `json:"eventId"` // Event ID if this is an event message
        Error   string                 `json:"error"`   // Error message if applicable
}

// WebSocketMessageType constants
const (
        WSMessageTypeSubscribe   = "subscribe"   // Client subscribes to events
        WSMessageTypeUnsubscribe = "unsubscribe" // Client unsubscribes from events
        WSMessageTypeEvent       = "event"       // Server sends an event
        WSMessageTypePing        = "ping"        // Ping message
        WSMessageTypePong        = "pong"        // Pong response
        WSMessageTypeError       = "error"       // Error message
        WSMessageTypeAck         = "ack"         // Acknowledgment
        WSMessageTypeAuth        = "auth"        // Authentication message
)

// NewWebSocketMessage creates a new WebSocket message
func NewWebSocketMessage(msgType, action string, data map[string]interface{}) *WebSocketMessage <span class="cov1" title="1">{
        return &amp;WebSocketMessage{
                Type:   msgType,
                Action: action,
                Data:   data,
        }
}</span>

// NewErrorMessage creates an error message
func NewErrorMessage(errorMsg string) *WebSocketMessage <span class="cov1" title="1">{
        return &amp;WebSocketMessage{
                Type:  WSMessageTypeError,
                Error: errorMsg,
        }
}</span>

// NewEventMessage creates an event message
func NewEventMessage(event *Event) *WebSocketMessage <span class="cov1" title="1">{
        return &amp;WebSocketMessage{
                Type:    WSMessageTypeEvent,
                Action:  event.Action,
                EventID: event.ID,
                Data: map[string]interface{}{
                        "event": event,
                },
        }
}</span>

// WebSocketConfig represents WebSocket configuration
type WebSocketConfig struct {
        Enabled             bool          `json:"enabled"`              // Whether WebSocket is enabled
        Path                string        `json:"path"`                 // WebSocket endpoint path (default: /ws)
        ReadBufferSize      int           `json:"readBufferSize"`       // Read buffer size in bytes
        WriteBufferSize     int           `json:"writeBufferSize"`      // Write buffer size in bytes
        MaxMessageSize      int64         `json:"maxMessageSize"`       // Maximum message size in bytes
        WriteWait           time.Duration `json:"writeWait"`            // Time allowed to write a message
        PongWait            time.Duration `json:"pongWait"`             // Time allowed to read pong
        PingPeriod          time.Duration `json:"pingPeriod"`           // Period for sending pings
        MaxClients          int           `json:"maxClients"`           // Maximum number of concurrent clients
        RequireAuth         bool          `json:"requireAuth"`          // Whether authentication is required
        AllowOrigins        []string      `json:"allowOrigins"`         // Allowed origins for CORS
        EnableCompression   bool          `json:"enableCompression"`    // Enable per-message compression
        HandshakeTimeout    time.Duration `json:"handshakeTimeout"`     // WebSocket handshake timeout
}

// DefaultWebSocketConfig returns default WebSocket configuration
func DefaultWebSocketConfig() WebSocketConfig <span class="cov2" title="2">{
        return WebSocketConfig{
                Enabled:           true,
                Path:              "/ws",
                ReadBufferSize:    1024,
                WriteBufferSize:   1024,
                MaxMessageSize:    512 * 1024, // 512KB
                WriteWait:         10 * time.Second,
                PongWait:          60 * time.Second,
                PingPeriod:        54 * time.Second, // Must be less than pongWait
                MaxClients:        1000,
                RequireAuth:       true,
                AllowOrigins:      []string{"*"},
                EnableCompression: true,
                HandshakeTimeout:  10 * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package security

import (
        "fmt"
        "sync"
        "time"
)

// SecurityEvent represents a security-related event
type SecurityEvent struct {
        Timestamp   time.Time
        EventType   string
        IP          string
        UserAgent   string
        Details     string
        Severity    string // INFO, WARNING, CRITICAL
        Action      string // ALLOWED, BLOCKED, SUSPICIOUS
}

// SecurityAuditLog manages security event logging
type SecurityAuditLog struct {
        events    []SecurityEvent
        mu        sync.RWMutex
        maxEvents int
        callbacks []func(SecurityEvent)
}

// Global audit log
var globalAuditLog = &amp;SecurityAuditLog{
        events:    make([]SecurityEvent, 0, 10000),
        maxEvents: 10000,
        callbacks: make([]func(SecurityEvent), 0),
}

// LogSecurityEvent logs a security event
func LogSecurityEvent(eventType, ip, details string) <span class="cov9" title="157">{
        event := SecurityEvent{
                Timestamp: time.Now(),
                EventType: eventType,
                IP:        ip,
                Details:   details,
                Severity:  determineSeverity(eventType),
                Action:    determineAction(eventType),
        }

        globalAuditLog.mu.Lock()
        defer globalAuditLog.mu.Unlock()

        // Add event
        globalAuditLog.events = append(globalAuditLog.events, event)

        // Trim if over limit
        if len(globalAuditLog.events) &gt; globalAuditLog.maxEvents </span><span class="cov0" title="0">{
                globalAuditLog.events = globalAuditLog.events[len(globalAuditLog.events)-globalAuditLog.maxEvents:]
        }</span>

        // Call callbacks
        <span class="cov9" title="157">for _, callback := range globalAuditLog.callbacks </span><span class="cov9" title="130">{
                go callback(event)
        }</span>

        // Print critical events
        <span class="cov9" title="157">if event.Severity == "CRITICAL" </span><span class="cov5" title="10">{
                fmt.Printf("[SECURITY CRITICAL] %s from %s: %s\n", eventType, ip, details)
        }</span>
}

// RegisterCallback registers a callback for security events
func RegisterCallback(callback func(SecurityEvent)) <span class="cov1" title="1">{
        globalAuditLog.mu.Lock()
        defer globalAuditLog.mu.Unlock()
        globalAuditLog.callbacks = append(globalAuditLog.callbacks, callback)
}</span>

// GetRecentEvents returns recent security events
func GetRecentEvents(limit int) []SecurityEvent <span class="cov4" title="6">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        if limit &gt; len(globalAuditLog.events) </span><span class="cov3" title="4">{
                limit = len(globalAuditLog.events)
        }</span>

        <span class="cov4" title="6">events := make([]SecurityEvent, limit)
        copy(events, globalAuditLog.events[len(globalAuditLog.events)-limit:])
        return events</span>
}

// GetEventsByIP returns events for a specific IP
func GetEventsByIP(ip string, limit int) []SecurityEvent <span class="cov1" title="1">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        var events []SecurityEvent
        for i := len(globalAuditLog.events) - 1; i &gt;= 0 &amp;&amp; len(events) &lt; limit; i-- </span><span class="cov3" title="4">{
                if globalAuditLog.events[i].IP == ip </span><span class="cov2" title="2">{
                        events = append(events, globalAuditLog.events[i])
                }</span>
        }
        <span class="cov1" title="1">return events</span>
}

// GetEventsByType returns events of a specific type
func GetEventsByType(eventType string, limit int) []SecurityEvent <span class="cov1" title="1">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        var events []SecurityEvent
        for i := len(globalAuditLog.events) - 1; i &gt;= 0 &amp;&amp; len(events) &lt; limit; i-- </span><span class="cov2" title="3">{
                if globalAuditLog.events[i].EventType == eventType </span><span class="cov2" title="2">{
                        events = append(events, globalAuditLog.events[i])
                }</span>
        }
        <span class="cov1" title="1">return events</span>
}

// ClearAuditLog clears all events
func ClearAuditLog() <span class="cov5" title="11">{
        globalAuditLog.mu.Lock()
        defer globalAuditLog.mu.Unlock()
        globalAuditLog.events = make([]SecurityEvent, 0, globalAuditLog.maxEvents)
}</span>

// determineSeverity determines event severity
func determineSeverity(eventType string) string <span class="cov10" title="166">{
        critical := map[string]bool{
                "IP_BLOCKED":           true,
                "BRUTE_FORCE_DETECTED": true,
                "SQL_INJECTION":        true,
                "XSS_ATTEMPT":          true,
                "CSRF_DETECTED":        true,
                "MALICIOUS_PAYLOAD":    true,
                "INVALID_TOKEN":        true,
        }

        warning := map[string]bool{
                "REQUEST_BLOCKED":      true,
                "RATE_LIMIT_EXCEEDED":  true,
                "SUSPICIOUS_ACTIVITY":  true,
                "REQUEST_TOO_LARGE":    true,
                "URI_TOO_LONG":         true,
                "INVALID_INPUT":        true,
        }

        if critical[eventType] </span><span class="cov5" title="15">{
                return "CRITICAL"
        }</span>
        <span class="cov9" title="151">if warning[eventType] </span><span class="cov5" title="14">{
                return "WARNING"
        }</span>
        <span class="cov9" title="137">return "INFO"</span>
}

// determineAction determines the action taken
func determineAction(eventType string) string <span class="cov9" title="164">{
        blocked := map[string]bool{
                "IP_BLOCKED":           true,
                "REQUEST_BLOCKED":      true,
                "RATE_LIMIT_EXCEEDED":  true,
                "SQL_INJECTION":        true,
                "XSS_ATTEMPT":          true,
                "CSRF_DETECTED":        true,
                "MALICIOUS_PAYLOAD":    true,
        }

        suspicious := map[string]bool{
                "SUSPICIOUS_ACTIVITY":  true,
                "INVALID_INPUT":        true,
                "REQUEST_TOO_LARGE":    true,
                "URI_TOO_LONG":         true,
        }

        if blocked[eventType] </span><span class="cov6" title="19">{
                return "BLOCKED"
        }</span>
        <span class="cov9" title="145">if suspicious[eventType] </span><span class="cov4" title="7">{
                return "SUSPICIOUS"
        }</span>
        <span class="cov9" title="138">return "ALLOWED"</span>
}

// SecurityStatistics contains security statistics
type SecurityStatistics struct {
        TotalEvents       int
        CriticalEvents    int
        WarningEvents     int
        InfoEvents        int
        BlockedEvents     int
        SuspiciousEvents  int
        AllowedEvents     int
        UniqueIPs         int
        RecentEvents      []SecurityEvent
}

// GetSecurityStatistics returns security statistics
func GetSecurityStatistics(recentCount int) *SecurityStatistics <span class="cov2" title="2">{
        globalAuditLog.mu.RLock()
        defer globalAuditLog.mu.RUnlock()

        stats := &amp;SecurityStatistics{
                TotalEvents:  len(globalAuditLog.events),
                RecentEvents: make([]SecurityEvent, 0),
        }

        uniqueIPs := make(map[string]bool)

        for _, event := range globalAuditLog.events </span><span class="cov4" title="9">{
                uniqueIPs[event.IP] = true

                switch event.Severity </span>{
                case "CRITICAL":<span class="cov2" title="2">
                        stats.CriticalEvents++</span>
                case "WARNING":<span class="cov2" title="2">
                        stats.WarningEvents++</span>
                case "INFO":<span class="cov3" title="5">
                        stats.InfoEvents++</span>
                }

                <span class="cov4" title="9">switch event.Action </span>{
                case "BLOCKED":<span class="cov2" title="3">
                        stats.BlockedEvents++</span>
                case "SUSPICIOUS":<span class="cov1" title="1">
                        stats.SuspiciousEvents++</span>
                case "ALLOWED":<span class="cov3" title="5">
                        stats.AllowedEvents++</span>
                }
        }

        <span class="cov2" title="2">stats.UniqueIPs = len(uniqueIPs)

        // Get recent events
        if recentCount &gt; 0 </span><span class="cov2" title="2">{
                start := len(globalAuditLog.events) - recentCount
                if start &lt; 0 </span><span class="cov2" title="2">{
                        start = 0
                }</span>
                <span class="cov2" title="2">stats.RecentEvents = make([]SecurityEvent, len(globalAuditLog.events[start:]))
                copy(stats.RecentEvents, globalAuditLog.events[start:])</span>
        }

        <span class="cov2" title="2">return stats</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package security

import (
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// BruteForceProtectionConfig contains brute force protection configuration
type BruteForceProtectionConfig struct {
        // Failure tracking
        MaxFailedAttempts    int           // Maximum failed attempts before blocking
        FailureWindow        time.Duration // Time window for counting failures
        BlockDuration        time.Duration // Duration to block after max failures
        PermanentBlockThreshold int        // Failures before permanent block

        // Progressive delays
        EnableProgressiveDelay bool          // Enable progressive delays
        BaseDelay              time.Duration // Base delay (increases exponentially)
        MaxDelay               time.Duration // Maximum delay

        // Account lockout
        EnableAccountLockout   bool          // Enable account lockout
        LockoutDuration        time.Duration // Duration to lock account
        NotifyOnLockout        bool          // Notify on account lockout

        // IP tracking
        TrackByIP              bool          // Track failures by IP
        TrackByUsername        bool          // Track failures by username
        TrackByIPAndUsername   bool          // Track failures by IP+username combination

        // Whitelist
        WhitelistedIPs         []string      // IPs exempt from protection
        WhitelistedUsernames   []string      // Usernames exempt from protection

        // CAPTCHA integration
        EnableCAPTCHA          bool          // Enable CAPTCHA after failures
        CAPTCHAThreshold       int           // Failures before requiring CAPTCHA

        // Cleanup
        CleanupInterval        time.Duration // Cleanup interval for old entries
}

// DefaultBruteForceProtectionConfig returns secure default settings
func DefaultBruteForceProtectionConfig() BruteForceProtectionConfig <span class="cov5" title="12">{
        return BruteForceProtectionConfig{
                MaxFailedAttempts:       5,
                FailureWindow:           15 * time.Minute,
                BlockDuration:           30 * time.Minute,
                PermanentBlockThreshold: 20,
                EnableProgressiveDelay:  true,
                BaseDelay:               1 * time.Second,
                MaxDelay:                30 * time.Second,
                EnableAccountLockout:    true,
                LockoutDuration:         1 * time.Hour,
                NotifyOnLockout:         true,
                TrackByIP:               true,
                TrackByUsername:         true,
                TrackByIPAndUsername:    true,
                WhitelistedIPs:          []string{},
                WhitelistedUsernames:    []string{},
                EnableCAPTCHA:           false,
                CAPTCHAThreshold:        3,
                CleanupInterval:         5 * time.Minute,
        }
}</span>

// StrictBruteForceProtectionConfig returns very strict settings
func StrictBruteForceProtectionConfig() BruteForceProtectionConfig <span class="cov0" title="0">{
        cfg := DefaultBruteForceProtectionConfig()
        cfg.MaxFailedAttempts = 3
        cfg.BlockDuration = 1 * time.Hour
        cfg.PermanentBlockThreshold = 10
        cfg.LockoutDuration = 24 * time.Hour
        cfg.EnableCAPTCHA = true
        cfg.CAPTCHAThreshold = 2
        return cfg
}</span>

// failureRecord tracks failed login attempts
type failureRecord struct {
        Attempts      int
        FirstAttempt  time.Time
        LastAttempt   time.Time
        BlockedUntil  time.Time
        PermanentBlock bool
        TotalFailures int
}

// bruteForceProtector implements brute force protection
type bruteForceProtector struct {
        config           BruteForceProtectionConfig
        ipFailures       map[string]*failureRecord
        usernameFailures map[string]*failureRecord
        combinedFailures map[string]*failureRecord // IP+Username
        mu               sync.RWMutex
        stopCleanup      chan struct{}
        cleanupDone      sync.WaitGroup
}

// newBruteForceProtector creates a new brute force protector
func newBruteForceProtector(cfg BruteForceProtectionConfig) *bruteForceProtector <span class="cov5" title="12">{
        bp := &amp;bruteForceProtector{
                config:           cfg,
                ipFailures:       make(map[string]*failureRecord),
                usernameFailures: make(map[string]*failureRecord),
                combinedFailures: make(map[string]*failureRecord),
                stopCleanup:      make(chan struct{}),
        }

        // Start background cleanup
        bp.cleanupDone.Add(1)
        go bp.cleanupLoop()

        return bp
}</span>

// checkAttempt checks if an attempt should be allowed
func (bp *bruteForceProtector) checkAttempt(ip, username string) (allowed bool, reason string, delay time.Duration) <span class="cov6" title="20">{
        // Check whitelists
        if bp.isWhitelisted(ip, username) </span><span class="cov2" title="2">{
                return true, "", 0
        }</span>

        <span class="cov6" title="18">bp.mu.Lock()
        defer bp.mu.Unlock()

        now := time.Now()
        blocked := false
        var blockReason string
        maxDelay := time.Duration(0)

        // Check IP-based failures
        if bp.config.TrackByIP </span><span class="cov6" title="18">{
                if record, exists := bp.ipFailures[ip]; exists </span><span class="cov5" title="11">{
                        isBlocked, reason, delay := bp.checkRecord(record, now, "IP")
                        if isBlocked </span><span class="cov5" title="8">{
                                blocked = true
                                blockReason = reason
                        }</span>
                        <span class="cov5" title="11">if delay &gt; maxDelay </span><span class="cov2" title="2">{
                                maxDelay = delay
                        }</span>
                }
        }

        // Check username-based failures
        <span class="cov6" title="18">if bp.config.TrackByUsername &amp;&amp; username != "" </span><span class="cov6" title="13">{
                if record, exists := bp.usernameFailures[username]; exists </span><span class="cov5" title="8">{
                        isBlocked, reason, delay := bp.checkRecord(record, now, "username")
                        if isBlocked </span><span class="cov4" title="6">{
                                blocked = true
                                blockReason = reason
                        }</span>
                        <span class="cov5" title="8">if delay &gt; maxDelay </span><span class="cov0" title="0">{
                                maxDelay = delay
                        }</span>
                }
        }

        // Check combined IP+username failures
        <span class="cov6" title="18">if bp.config.TrackByIPAndUsername &amp;&amp; username != "" </span><span class="cov6" title="15">{
                key := fmt.Sprintf("%s:%s", ip, username)
                if record, exists := bp.combinedFailures[key]; exists </span><span class="cov5" title="9">{
                        isBlocked, reason, delay := bp.checkRecord(record, now, "IP+username")
                        if isBlocked </span><span class="cov4" title="7">{
                                blocked = true
                                blockReason = reason
                        }</span>
                        <span class="cov5" title="9">if delay &gt; maxDelay </span><span class="cov0" title="0">{
                                maxDelay = delay
                        }</span>
                }
        }

        <span class="cov6" title="18">if blocked </span><span class="cov5" title="8">{
                return false, blockReason, maxDelay
        }</span>

        <span class="cov5" title="10">return true, "", maxDelay</span>
}

// checkRecord checks if a failure record indicates blocking
func (bp *bruteForceProtector) checkRecord(record *failureRecord, now time.Time, recordType string) (blocked bool, reason string, delay time.Duration) <span class="cov7" title="28">{
        // Check permanent block
        if record.PermanentBlock </span><span class="cov4" title="6">{
                return true, fmt.Sprintf("Permanently blocked (%s)", recordType), 0
        }</span>

        // Check temporary block
        <span class="cov7" title="22">if now.Before(record.BlockedUntil) </span><span class="cov6" title="15">{
                remaining := record.BlockedUntil.Sub(now)
                return true, fmt.Sprintf("Temporarily blocked (%s) - %v remaining", recordType, remaining.Round(time.Second)), 0
        }</span>

        // If block has expired, reset attempts
        <span class="cov4" title="7">if !record.BlockedUntil.IsZero() &amp;&amp; now.After(record.BlockedUntil) </span><span class="cov3" title="3">{
                record.Attempts = 0
                record.BlockedUntil = time.Time{} // Clear block time
                return false, "", 0
        }</span>

        // Check if we're in the failure window
        <span class="cov3" title="4">if now.Sub(record.FirstAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                // Outside window, reset
                record.Attempts = 0
                record.FirstAttempt = now
                return false, "", 0
        }</span>

        // Check if we've exceeded max attempts
        <span class="cov3" title="4">if record.Attempts &gt;= bp.config.MaxFailedAttempts </span><span class="cov0" title="0">{
                return true, fmt.Sprintf("Too many failed attempts (%s)", recordType), 0
        }</span>

        // Calculate progressive delay if enabled
        <span class="cov3" title="4">if bp.config.EnableProgressiveDelay &amp;&amp; record.Attempts &gt; 0 </span><span class="cov3" title="4">{
                delay = bp.calculateDelay(record.Attempts)
                return false, "", delay
        }</span>

        <span class="cov0" title="0">return false, "", 0</span>
}

// recordFailure records a failed attempt
func (bp *bruteForceProtector) recordFailure(ip, username string) <span class="cov9" title="71">{
        // Check whitelists
        if bp.isWhitelisted(ip, username) </span><span class="cov8" title="40">{
                return
        }</span>

        <span class="cov7" title="31">bp.mu.Lock()
        defer bp.mu.Unlock()

        now := time.Now()

        // Record IP failure
        if bp.config.TrackByIP </span><span class="cov7" title="31">{
                bp.updateFailureRecord(bp.ipFailures, ip, now)
        }</span>

        // Record username failure
        <span class="cov7" title="31">if bp.config.TrackByUsername &amp;&amp; username != "" </span><span class="cov7" title="26">{
                bp.updateFailureRecord(bp.usernameFailures, username, now)
        }</span>

        // Record combined failure
        <span class="cov7" title="31">if bp.config.TrackByIPAndUsername &amp;&amp; username != "" </span><span class="cov7" title="29">{
                key := fmt.Sprintf("%s:%s", ip, username)
                bp.updateFailureRecord(bp.combinedFailures, key, now)
        }</span>
}

// updateFailureRecord updates a failure record
func (bp *bruteForceProtector) updateFailureRecord(records map[string]*failureRecord, key string, now time.Time) <span class="cov9" title="86">{
        record, exists := records[key]
        if !exists </span><span class="cov8" title="36">{
                record = &amp;failureRecord{
                        FirstAttempt: now,
                }
                records[key] = record
        }</span>

        // Reset if outside failure window
        <span class="cov9" title="86">if now.Sub(record.FirstAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                record.Attempts = 0
                record.FirstAttempt = now
        }</span>

        <span class="cov9" title="86">record.Attempts++
        record.LastAttempt = now
        record.TotalFailures++

        // Check if we should block
        if record.Attempts &gt;= bp.config.MaxFailedAttempts </span><span class="cov8" title="41">{
                record.BlockedUntil = now.Add(bp.config.BlockDuration)

                // Check for permanent block
                if record.TotalFailures &gt;= bp.config.PermanentBlockThreshold </span><span class="cov4" title="6">{
                        record.PermanentBlock = true
                }</span>
        }
}

// recordSuccess records a successful attempt (resets counters)
func (bp *bruteForceProtector) recordSuccess(ip, username string) <span class="cov2" title="2">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        // Reset IP failures
        if bp.config.TrackByIP </span><span class="cov2" title="2">{
                delete(bp.ipFailures, ip)
        }</span>

        // Reset username failures
        <span class="cov2" title="2">if bp.config.TrackByUsername &amp;&amp; username != "" </span><span class="cov2" title="2">{
                delete(bp.usernameFailures, username)
        }</span>

        // Reset combined failures
        <span class="cov2" title="2">if bp.config.TrackByIPAndUsername &amp;&amp; username != "" </span><span class="cov2" title="2">{
                key := fmt.Sprintf("%s:%s", ip, username)
                delete(bp.combinedFailures, key)
        }</span>
}

// isWhitelisted checks if IP or username is whitelisted
func (bp *bruteForceProtector) isWhitelisted(ip, username string) bool <span class="cov10" title="91">{
        // Check IP whitelist
        for _, whitelistedIP := range bp.config.WhitelistedIPs </span><span class="cov8" title="42">{
                if ip == whitelistedIP </span><span class="cov7" title="21">{
                        return true
                }</span>
        }

        // Check username whitelist
        <span class="cov9" title="70">for _, whitelistedUsername := range bp.config.WhitelistedUsernames </span><span class="cov7" title="21">{
                if username == whitelistedUsername </span><span class="cov7" title="21">{
                        return true
                }</span>
        }

        <span class="cov8" title="49">return false</span>
}

// calculateDelay calculates progressive delay based on attempt count
func (bp *bruteForceProtector) calculateDelay(attempts int) time.Duration <span class="cov3" title="4">{
        // Exponential backoff: baseDelay * 2^(attempts-1)
        delay := bp.config.BaseDelay * time.Duration(1&lt;&lt;uint(attempts-1))

        if delay &gt; bp.config.MaxDelay </span><span class="cov0" title="0">{
                delay = bp.config.MaxDelay
        }</span>

        <span class="cov3" title="4">return delay</span>
}

// cleanupLoop runs background cleanup
func (bp *bruteForceProtector) cleanupLoop() <span class="cov5" title="12">{
        defer bp.cleanupDone.Done()

        ticker := time.NewTicker(bp.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov5" title="12">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        bp.cleanup()</span>
                case &lt;-bp.stopCleanup:<span class="cov5" title="10">
                        return</span>
                }
        }
}

// cleanup removes old entries
func (bp *bruteForceProtector) cleanup() <span class="cov0" title="0">{
        bp.mu.Lock()
        defer bp.mu.Unlock()

        now := time.Now()

        // Cleanup IP failures
        for ip, record := range bp.ipFailures </span><span class="cov0" title="0">{
                if !record.PermanentBlock &amp;&amp; now.After(record.BlockedUntil) &amp;&amp;
                        now.Sub(record.LastAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                        delete(bp.ipFailures, ip)
                }</span>
        }

        // Cleanup username failures
        <span class="cov0" title="0">for username, record := range bp.usernameFailures </span><span class="cov0" title="0">{
                if !record.PermanentBlock &amp;&amp; now.After(record.BlockedUntil) &amp;&amp;
                        now.Sub(record.LastAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                        delete(bp.usernameFailures, username)
                }</span>
        }

        // Cleanup combined failures
        <span class="cov0" title="0">for key, record := range bp.combinedFailures </span><span class="cov0" title="0">{
                if !record.PermanentBlock &amp;&amp; now.After(record.BlockedUntil) &amp;&amp;
                        now.Sub(record.LastAttempt) &gt; bp.config.FailureWindow </span><span class="cov0" title="0">{
                        delete(bp.combinedFailures, key)
                }</span>
        }
}

// close stops the brute force protector
func (bp *bruteForceProtector) close() <span class="cov5" title="10">{
        close(bp.stopCleanup)
        bp.cleanupDone.Wait()
}</span>

// getStatistics returns statistics
func (bp *bruteForceProtector) getStatistics() *BruteForceStatistics <span class="cov1" title="1">{
        bp.mu.RLock()
        defer bp.mu.RUnlock()

        stats := &amp;BruteForceStatistics{
                TrackedIPs:       len(bp.ipFailures),
                TrackedUsernames: len(bp.usernameFailures),
                TrackedCombined:  len(bp.combinedFailures),
        }

        now := time.Now()

        // Count blocked entries
        for _, record := range bp.ipFailures </span><span class="cov3" title="3">{
                if record.PermanentBlock </span><span class="cov0" title="0">{
                        stats.PermanentlyBlockedIPs++
                }</span> else<span class="cov3" title="3"> if now.Before(record.BlockedUntil) </span><span class="cov0" title="0">{
                        stats.BlockedIPs++
                }</span>
        }

        <span class="cov1" title="1">for _, record := range bp.usernameFailures </span><span class="cov3" title="3">{
                if record.PermanentBlock </span><span class="cov0" title="0">{
                        stats.PermanentlyBlockedUsernames++
                }</span> else<span class="cov3" title="3"> if now.Before(record.BlockedUntil) </span><span class="cov0" title="0">{
                        stats.BlockedUsernames++
                }</span>
        }

        <span class="cov1" title="1">return stats</span>
}

// Global brute force protector
var globalBruteForceProtector *bruteForceProtector

// InitBruteForceProtection initializes brute force protection
func InitBruteForceProtection(cfg BruteForceProtectionConfig) <span class="cov4" title="5">{
        if globalBruteForceProtector != nil </span><span class="cov3" title="4">{
                globalBruteForceProtector.close()
        }</span>
        <span class="cov4" title="5">globalBruteForceProtector = newBruteForceProtector(cfg)</span>
}

// BruteForceProtectionMiddleware creates brute force protection middleware
func BruteForceProtectionMiddleware(cfg BruteForceProtectionConfig) gin.HandlerFunc <span class="cov1" title="1">{
        protector := newBruteForceProtector(cfg)

        return func(c *gin.Context) </span><span class="cov3" title="3">{
                // Only protect authentication endpoints
                // This should be applied to login/authentication routes only

                ip := c.ClientIP()

                // Try to get username from request
                username := ""
                if user, exists := c.Get("username"); exists </span><span class="cov0" title="0">{
                        username = user.(string)
                }</span> else<span class="cov3" title="3"> {
                        // Try to extract from request body
                        var body map[string]interface{}
                        if err := c.ShouldBindJSON(&amp;body); err == nil </span><span class="cov0" title="0">{
                                if u, ok := body["username"].(string); ok </span><span class="cov0" title="0">{
                                        username = u
                                }</span> else<span class="cov0" title="0"> if u, ok := body["email"].(string); ok </span><span class="cov0" title="0">{
                                        username = u
                                }</span>
                        }
                }

                // Check if attempt should be allowed
                <span class="cov3" title="3">allowed, reason, delay := protector.checkAttempt(ip, username)

                if !allowed </span><span class="cov1" title="1">{
                        LogSecurityEvent("BRUTE_FORCE_DETECTED", ip,
                                fmt.Sprintf("Brute force attempt blocked for username '%s': %s",
                                        username, reason))

                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "Too many failed attempts",
                                "reason":      reason,
                                "retry_after": cfg.BlockDuration.String(),
                        })
                        c.Abort()
                        return
                }</span>

                // Apply progressive delay if needed
                <span class="cov2" title="2">if delay &gt; 0 </span><span class="cov1" title="1">{
                        time.Sleep(delay)
                }</span>

                // Process request
                <span class="cov2" title="2">c.Next()

                // Check if authentication was successful
                statusCode := c.Writer.Status()

                if statusCode == http.StatusOK || statusCode == http.StatusCreated </span><span class="cov0" title="0">{
                        // Successful authentication
                        protector.recordSuccess(ip, username)
                }</span> else<span class="cov2" title="2"> if statusCode == http.StatusUnauthorized || statusCode == http.StatusForbidden </span><span class="cov2" title="2">{
                        // Failed authentication
                        protector.recordFailure(ip, username)

                        LogSecurityEvent("FAILED_LOGIN_ATTEMPT", ip,
                                fmt.Sprintf("Failed login attempt for username '%s'", username))
                }</span>
        }
}

// RecordLoginFailure manually records a login failure
func RecordLoginFailure(ip, username string) <span class="cov6" title="14">{
        if globalBruteForceProtector != nil </span><span class="cov6" title="14">{
                globalBruteForceProtector.recordFailure(ip, username)
        }</span>
}

// RecordLoginSuccess manually records a login success
func RecordLoginSuccess(ip, username string) <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                globalBruteForceProtector.recordSuccess(ip, username)
        }</span>
}

// IsBlocked checks if IP or username is currently blocked
func IsBlocked(ip, username string) (bool, string) <span class="cov4" title="5">{
        if globalBruteForceProtector != nil </span><span class="cov4" title="5">{
                allowed, reason, _ := globalBruteForceProtector.checkAttempt(ip, username)
                return !allowed, reason
        }</span>
        <span class="cov0" title="0">return false, ""</span>
}

// UnblockIP unblocks an IP address
func UnblockIP(ip string) <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                globalBruteForceProtector.mu.Lock()
                defer globalBruteForceProtector.mu.Unlock()

                // Delete IP-specific record
                delete(globalBruteForceProtector.ipFailures, ip)

                // Delete all combined IP+username records for this IP
                for key := range globalBruteForceProtector.combinedFailures </span><span class="cov1" title="1">{
                        // Combined key format is "ip:username"
                        if len(key) &gt; len(ip) &amp;&amp; key[:len(ip)] == ip &amp;&amp; key[len(ip)] == ':' </span><span class="cov1" title="1">{
                                delete(globalBruteForceProtector.combinedFailures, key)
                        }</span>
                }
        }
}

// UnblockUsername unblocks a username
func UnblockUsername(username string) <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                globalBruteForceProtector.mu.Lock()
                defer globalBruteForceProtector.mu.Unlock()

                // Delete username-specific record
                delete(globalBruteForceProtector.usernameFailures, username)

                // Delete all combined IP+username records for this username
                for key := range globalBruteForceProtector.combinedFailures </span><span class="cov1" title="1">{
                        // Combined key format is "ip:username"
                        // Find the colon and check if username matches
                        colonIdx := -1
                        for i := range key </span><span class="cov5" title="12">{
                                if key[i] == ':' </span><span class="cov1" title="1">{
                                        colonIdx = i
                                        break</span>
                                }
                        }
                        <span class="cov1" title="1">if colonIdx &gt;= 0 &amp;&amp; colonIdx+1 &lt; len(key) &amp;&amp; key[colonIdx+1:] == username </span><span class="cov1" title="1">{
                                delete(globalBruteForceProtector.combinedFailures, key)
                        }</span>
                }
        }
}

// BruteForceStatistics contains brute force protection statistics
type BruteForceStatistics struct {
        TrackedIPs                  int `json:"tracked_ips"`
        TrackedUsernames            int `json:"tracked_usernames"`
        TrackedCombined             int `json:"tracked_combined"`
        BlockedIPs                  int `json:"blocked_ips"`
        BlockedUsernames            int `json:"blocked_usernames"`
        PermanentlyBlockedIPs       int `json:"permanently_blocked_ips"`
        PermanentlyBlockedUsernames int `json:"permanently_blocked_usernames"`
}

// GetBruteForceStatistics returns brute force protection statistics
func GetBruteForceStatistics() *BruteForceStatistics <span class="cov1" title="1">{
        if globalBruteForceProtector != nil </span><span class="cov1" title="1">{
                return globalBruteForceProtector.getStatistics()
        }</span>
        <span class="cov0" title="0">return &amp;BruteForceStatistics{}</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package security

import (
        "crypto/rand"
        "crypto/subtle"
        "encoding/base64"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// CSRFProtectionConfig contains CSRF protection configuration
type CSRFProtectionConfig struct {
        // Token configuration
        TokenLength       int           // Length of CSRF token in bytes (default: 32)
        TokenLifetime     time.Duration // Lifetime of CSRF token (default: 1 hour)
        CookieName        string        // Name of CSRF cookie (default: "csrf_token")
        HeaderName        string        // Name of CSRF header (default: "X-CSRF-Token")
        FormFieldName     string        // Name of form field (default: "csrf_token")

        // Cookie configuration
        CookiePath        string        // Cookie path (default: "/")
        CookieDomain      string        // Cookie domain (default: "")
        CookieSecure      bool          // Secure cookie (HTTPS only, default: true)
        CookieHTTPOnly    bool          // HTTPOnly cookie (default: true)
        CookieSameSite    http.SameSite // SameSite cookie attribute (default: Strict)

        // Protection options
        RequireTokenRefresh bool          // Require token refresh on each request
        EnableDoubleSubmit  bool          // Enable double-submit cookie pattern
        TrustedOrigins      []string      // List of trusted origins
        ExcludePaths        []string      // Paths to exclude from CSRF protection
        ExcludeMethods      []string      // HTTP methods to exclude (default: GET, HEAD, OPTIONS)

        // Error handling
        ErrorHandler      func(*gin.Context) // Custom error handler
        RegenerateOnError bool               // Regenerate token on validation error
}

// DefaultCSRFProtectionConfig returns secure default settings
func DefaultCSRFProtectionConfig() CSRFProtectionConfig <span class="cov4" title="3">{
        return CSRFProtectionConfig{
                TokenLength:         32,
                TokenLifetime:       1 * time.Hour,
                CookieName:          "csrf_token",
                HeaderName:          "X-CSRF-Token",
                FormFieldName:       "csrf_token",
                CookiePath:          "/",
                CookieSecure:        true,
                CookieHTTPOnly:      true,
                CookieSameSite:      http.SameSiteLaxMode,
                RequireTokenRefresh: false,
                EnableDoubleSubmit:  true,
                TrustedOrigins:      []string{},
                ExcludePaths:        []string{},
                ExcludeMethods:      []string{"GET", "HEAD", "OPTIONS"},
                RegenerateOnError:   true,
        }
}</span>

// StrictCSRFProtectionConfig returns very strict CSRF protection settings
func StrictCSRFProtectionConfig() CSRFProtectionConfig <span class="cov0" title="0">{
        cfg := DefaultCSRFProtectionConfig()
        cfg.TokenLifetime = 15 * time.Minute
        cfg.CookieSameSite = http.SameSiteStrictMode
        cfg.RequireTokenRefresh = true
        cfg.RegenerateOnError = true
        return cfg
}</span>

// csrfToken represents a CSRF token with metadata
type csrfToken struct {
        Value      string
        CreatedAt  time.Time
        ExpiresAt  time.Time
        Used       bool
        IPAddress  string
        UserAgent  string
}

// csrfTokenStore manages CSRF tokens
type csrfTokenStore struct {
        tokens    map[string]*csrfToken
        mu        sync.RWMutex
        maxTokens int
}

// newCSRFTokenStore creates a new token store
func newCSRFTokenStore(maxTokens int) *csrfTokenStore <span class="cov6" title="7">{
        store := &amp;csrfTokenStore{
                tokens:    make(map[string]*csrfToken),
                maxTokens: maxTokens,
        }

        // Start cleanup goroutine
        go store.cleanupExpired()

        return store
}</span>

// generateToken generates a new CSRF token
func (store *csrfTokenStore) generateToken(length int, lifetime time.Duration, ip, userAgent string) (*csrfToken, error) <span class="cov10" title="22">{
        // Generate random bytes
        tokenBytes := make([]byte, length)
        if _, err := rand.Read(tokenBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // Encode to base64
        <span class="cov10" title="22">tokenValue := base64.URLEncoding.EncodeToString(tokenBytes)

        // Create token
        now := time.Now()
        token := &amp;csrfToken{
                Value:     tokenValue,
                CreatedAt: now,
                ExpiresAt: now.Add(lifetime),
                Used:      false,
                IPAddress: ip,
                UserAgent: userAgent,
        }

        // Store token
        store.mu.Lock()
        defer store.mu.Unlock()

        // Check if we need to cleanup
        if len(store.tokens) &gt;= store.maxTokens </span><span class="cov0" title="0">{
                store.removeOldest()
        }</span>

        <span class="cov10" title="22">store.tokens[tokenValue] = token

        return token, nil</span>
}

// validateToken validates a CSRF token
func (store *csrfTokenStore) validateToken(tokenValue, ip, userAgent string, requireMatch bool) bool <span class="cov7" title="8">{
        store.mu.RLock()
        token, exists := store.tokens[tokenValue]
        store.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check if token is expired
        <span class="cov6" title="7">if time.Now().After(token.ExpiresAt) </span><span class="cov1" title="1">{
                store.removeToken(tokenValue)
                return false
        }</span>

        // Check if token was already used (one-time use)
        <span class="cov6" title="6">if token.Used </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check IP address match if required
        <span class="cov5" title="5">if requireMatch &amp;&amp; token.IPAddress != ip </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check user agent match if required
        <span class="cov5" title="4">if requireMatch &amp;&amp; token.UserAgent != userAgent </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov4" title="3">return true</span>
}

// markTokenUsed marks a token as used
func (store *csrfTokenStore) markTokenUsed(tokenValue string) <span class="cov1" title="1">{
        store.mu.Lock()
        defer store.mu.Unlock()

        if token, exists := store.tokens[tokenValue]; exists </span><span class="cov1" title="1">{
                token.Used = true
        }</span>
}

// removeToken removes a token from the store
func (store *csrfTokenStore) removeToken(tokenValue string) <span class="cov1" title="1">{
        store.mu.Lock()
        defer store.mu.Unlock()
        delete(store.tokens, tokenValue)
}</span>

// removeOldest removes the oldest token
func (store *csrfTokenStore) removeOldest() <span class="cov0" title="0">{
        var oldestKey string
        var oldestTime time.Time

        for key, token := range store.tokens </span><span class="cov0" title="0">{
                if oldestKey == "" || token.CreatedAt.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestKey = key
                        oldestTime = token.CreatedAt
                }</span>
        }

        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(store.tokens, oldestKey)
        }</span>
}

// cleanupExpired removes expired tokens
func (store *csrfTokenStore) cleanupExpired() <span class="cov6" title="7">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                store.mu.Lock()
                now := time.Now()
                for key, token := range store.tokens </span><span class="cov0" title="0">{
                        if now.After(token.ExpiresAt) </span><span class="cov0" title="0">{
                                delete(store.tokens, key)
                        }</span>
                }
                <span class="cov0" title="0">store.mu.Unlock()</span>
        }
}

// getStats returns token store statistics
func (store *csrfTokenStore) getStats() map[string]interface{} <span class="cov1" title="1">{
        store.mu.RLock()
        defer store.mu.RUnlock()

        totalTokens := len(store.tokens)
        usedTokens := 0
        expiredTokens := 0
        now := time.Now()

        for _, token := range store.tokens </span><span class="cov7" title="10">{
                if token.Used </span><span class="cov0" title="0">{
                        usedTokens++
                }</span>
                <span class="cov7" title="10">if now.After(token.ExpiresAt) </span><span class="cov0" title="0">{
                        expiredTokens++
                }</span>
        }

        <span class="cov1" title="1">return map[string]interface{}{
                "total_tokens":   totalTokens,
                "used_tokens":    usedTokens,
                "expired_tokens": expiredTokens,
                "active_tokens":  totalTokens - usedTokens - expiredTokens,
        }</span>
}

// Global token store
var globalCSRFStore = newCSRFTokenStore(10000)

// CSRFProtectionMiddleware creates CSRF protection middleware
func CSRFProtectionMiddleware(cfg CSRFProtectionConfig) gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov5" title="4">{
                // Check if path is excluded
                for _, path := range cfg.ExcludePaths </span><span class="cov0" title="0">{
                        if c.Request.URL.Path == path </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>
                }

                // Check if method is excluded (GET, HEAD, OPTIONS are safe)
                <span class="cov5" title="4">for _, method := range cfg.ExcludeMethods </span><span class="cov7" title="8">{
                        if c.Request.Method == method </span><span class="cov3" title="2">{
                                // Generate and set token for safe methods
                                token, err := generateAndSetCSRFToken(c, cfg)
                                if err != nil </span><span class="cov0" title="0">{
                                        LogSecurityEvent("CSRF_TOKEN_GENERATION_FAILED", c.ClientIP(),
                                                fmt.Sprintf("Failed to generate CSRF token: %v", err))
                                }</span> else<span class="cov3" title="2"> {
                                        // Make token available to response
                                        c.Set("csrf_token", token)
                                }</span>
                                <span class="cov3" title="2">c.Next()
                                return</span>
                        }
                }

                // For state-changing methods (POST, PUT, DELETE, PATCH), validate token
                <span class="cov3" title="2">valid := validateCSRFToken(c, cfg)

                if !valid </span><span class="cov1" title="1">{
                        LogSecurityEvent("CSRF_DETECTED", c.ClientIP(),
                                fmt.Sprintf("CSRF token validation failed for %s %s",
                                        c.Request.Method, c.Request.URL.Path))

                        // Call custom error handler if provided
                        if cfg.ErrorHandler != nil </span><span class="cov0" title="0">{
                                cfg.ErrorHandler(c)
                        }</span> else<span class="cov1" title="1"> {
                                c.JSON(http.StatusForbidden, gin.H{
                                        "error": "CSRF token validation failed",
                                })
                        }</span>

                        <span class="cov1" title="1">c.Abort()
                        return</span>
                }

                // Token is valid, mark as used if one-time use is enabled
                <span class="cov1" title="1">if cfg.RequireTokenRefresh </span><span class="cov0" title="0">{
                        tokenValue := getCSRFTokenFromRequest(c, cfg)
                        globalCSRFStore.markTokenUsed(tokenValue)
                }</span>

                // Generate new token for response
                <span class="cov1" title="1">newToken, err := generateAndSetCSRFToken(c, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        LogSecurityEvent("CSRF_TOKEN_GENERATION_FAILED", c.ClientIP(),
                                fmt.Sprintf("Failed to generate new CSRF token: %v", err))
                }</span> else<span class="cov1" title="1"> {
                        c.Set("csrf_token", newToken)
                }</span>

                <span class="cov1" title="1">c.Next()</span>
        }
}

// generateAndSetCSRFToken generates a new CSRF token and sets it in cookie
func generateAndSetCSRFToken(c *gin.Context, cfg CSRFProtectionConfig) (string, error) <span class="cov4" title="3">{
        ip := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        token, err := globalCSRFStore.generateToken(cfg.TokenLength, cfg.TokenLifetime, ip, userAgent)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Set cookie
        <span class="cov4" title="3">c.SetCookie(
                cfg.CookieName,
                token.Value,
                int(cfg.TokenLifetime.Seconds()),
                cfg.CookiePath,
                cfg.CookieDomain,
                cfg.CookieSecure,
                cfg.CookieHTTPOnly,
        )

        // Also set SameSite attribute
        // Note: Gin's SetCookie doesn't support SameSite directly,
        // so we need to set it manually
        if cfg.CookieSameSite != http.SameSiteDefaultMode </span><span class="cov4" title="3">{
                sameSite := "Lax"
                if cfg.CookieSameSite == http.SameSiteStrictMode </span><span class="cov0" title="0">{
                        sameSite = "Strict"
                }</span> else<span class="cov4" title="3"> if cfg.CookieSameSite == http.SameSiteNoneMode </span><span class="cov0" title="0">{
                        sameSite = "None"
                }</span>

                <span class="cov4" title="3">cookie := fmt.Sprintf("%s=%s; Path=%s; Max-Age=%d; SameSite=%s",
                        cfg.CookieName, token.Value, cfg.CookiePath,
                        int(cfg.TokenLifetime.Seconds()), sameSite)

                if cfg.CookieSecure </span><span class="cov4" title="3">{
                        cookie += "; Secure"
                }</span>
                <span class="cov4" title="3">if cfg.CookieHTTPOnly </span><span class="cov4" title="3">{
                        cookie += "; HttpOnly"
                }</span>
                <span class="cov4" title="3">if cfg.CookieDomain != "" </span><span class="cov0" title="0">{
                        cookie += fmt.Sprintf("; Domain=%s", cfg.CookieDomain)
                }</span>

                <span class="cov4" title="3">c.Header("Set-Cookie", cookie)</span>
        }

        <span class="cov4" title="3">return token.Value, nil</span>
}

// validateCSRFToken validates the CSRF token from request
func validateCSRFToken(c *gin.Context, cfg CSRFProtectionConfig) bool <span class="cov3" title="2">{
        // Get token from request
        requestToken := getCSRFTokenFromRequest(c, cfg)
        if requestToken == "" </span><span class="cov1" title="1">{
                return false
        }</span>

        // Get token from cookie
        <span class="cov1" title="1">cookieToken, err := c.Cookie(cfg.CookieName)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Double-submit cookie pattern: compare request token with cookie token
        <span class="cov1" title="1">if cfg.EnableDoubleSubmit </span><span class="cov1" title="1">{
                // Use constant-time comparison to prevent timing attacks
                if subtle.ConstantTimeCompare([]byte(requestToken), []byte(cookieToken)) != 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Validate token in store
        <span class="cov1" title="1">ip := c.ClientIP()
        userAgent := c.GetHeader("User-Agent")

        return globalCSRFStore.validateToken(requestToken, ip, userAgent, true)</span>
}

// getCSRFTokenFromRequest extracts CSRF token from request
func getCSRFTokenFromRequest(c *gin.Context, cfg CSRFProtectionConfig) string <span class="cov3" title="2">{
        // Try header first
        token := c.GetHeader(cfg.HeaderName)
        if token != "" </span><span class="cov1" title="1">{
                return token
        }</span>

        // Try form field
        <span class="cov1" title="1">token = c.PostForm(cfg.FormFieldName)
        if token != "" </span><span class="cov0" title="0">{
                return token
        }</span>

        // Try JSON body
        <span class="cov1" title="1">var body map[string]interface{}
        if err := c.ShouldBindJSON(&amp;body); err == nil </span><span class="cov0" title="0">{
                if tokenValue, ok := body[cfg.FormFieldName].(string); ok </span><span class="cov0" title="0">{
                        return tokenValue
                }</span>
        }

        <span class="cov1" title="1">return ""</span>
}

// GetCSRFToken returns the current CSRF token for the request
func GetCSRFToken(c *gin.Context) string <span class="cov4" title="3">{
        if token, exists := c.Get("csrf_token"); exists </span><span class="cov3" title="2">{
                if tokenStr, ok := token.(string); ok </span><span class="cov3" title="2">{
                        return tokenStr
                }</span>
        }
        <span class="cov1" title="1">return ""</span>
}

// CSRFTokenResponse adds CSRF token to response
func CSRFTokenResponse() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Add CSRF token to response headers
                if token := GetCSRFToken(c); token != "" </span><span class="cov0" title="0">{
                        c.Header("X-CSRF-Token", token)
                }</span>
        }
}

// OriginValidationMiddleware validates the Origin header
func OriginValidationMiddleware(trustedOrigins []string) gin.HandlerFunc <span class="cov0" title="0">{
        trustedMap := make(map[string]bool)
        for _, origin := range trustedOrigins </span><span class="cov0" title="0">{
                trustedMap[origin] = true
        }</span>

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.GetHeader("Origin")
                if origin == "" </span><span class="cov0" title="0">{
                        // No Origin header, allow (might be same-origin request)
                        c.Next()
                        return
                }</span>

                // Check if origin is trusted
                <span class="cov0" title="0">if !trustedMap[origin] </span><span class="cov0" title="0">{
                        LogSecurityEvent("UNTRUSTED_ORIGIN", c.ClientIP(),
                                fmt.Sprintf("Request from untrusted origin: %s", origin))

                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Untrusted origin",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RefererValidationMiddleware validates the Referer header
func RefererValidationMiddleware(trustedDomains []string) gin.HandlerFunc <span class="cov0" title="0">{
        trustedMap := make(map[string]bool)
        for _, domain := range trustedDomains </span><span class="cov0" title="0">{
                trustedMap[domain] = true
        }</span>

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                referer := c.GetHeader("Referer")
                if referer == "" </span><span class="cov0" title="0">{
                        // No Referer header for state-changing methods
                        if c.Request.Method != "GET" &amp;&amp; c.Request.Method != "HEAD" &amp;&amp; c.Request.Method != "OPTIONS" </span><span class="cov0" title="0">{
                                LogSecurityEvent("MISSING_REFERER", c.ClientIP(),
                                        fmt.Sprintf("State-changing request without Referer: %s %s",
                                                c.Request.Method, c.Request.URL.Path))

                                c.JSON(http.StatusForbidden, gin.H{
                                        "error": "Missing Referer header",
                                })
                                c.Abort()
                                return
                        }</span>
                        <span class="cov0" title="0">c.Next()
                        return</span>
                }

                // Extract domain from referer
                // Simple validation - can be enhanced
                <span class="cov0" title="0">trusted := false
                for domain := range trustedMap </span><span class="cov0" title="0">{
                        if len(referer) &gt;= len(domain) &amp;&amp; referer[:len(domain)] == domain </span><span class="cov0" title="0">{
                                trusted = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !trusted </span><span class="cov0" title="0">{
                        LogSecurityEvent("UNTRUSTED_REFERER", c.ClientIP(),
                                fmt.Sprintf("Request from untrusted referer: %s", referer))

                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Untrusted referer",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// CSRFStatistics contains CSRF protection statistics
type CSRFStatistics struct {
        TotalTokens       int `json:"total_tokens"`
        ActiveTokens      int `json:"active_tokens"`
        UsedTokens        int `json:"used_tokens"`
        ExpiredTokens     int `json:"expired_tokens"`
        ValidationsFailed int `json:"validations_failed"`
        ValidationsSucceeded int `json:"validations_succeeded"`
}

// GetCSRFStatistics returns CSRF protection statistics
func GetCSRFStatistics() *CSRFStatistics <span class="cov1" title="1">{
        stats := globalCSRFStore.getStats()

        return &amp;CSRFStatistics{
                TotalTokens:   stats["total_tokens"].(int),
                ActiveTokens:  stats["active_tokens"].(int),
                UsedTokens:    stats["used_tokens"].(int),
                ExpiredTokens: stats["expired_tokens"].(int),
        }
}</span>

// ClearExpiredCSRFTokens manually clears expired tokens
func ClearExpiredCSRFTokens() int <span class="cov1" title="1">{
        globalCSRFStore.mu.Lock()
        defer globalCSRFStore.mu.Unlock()

        count := 0
        now := time.Now()

        for key, token := range globalCSRFStore.tokens </span><span class="cov5" title="5">{
                if now.After(token.ExpiresAt) </span><span class="cov5" title="5">{
                        delete(globalCSRFStore.tokens, key)
                        count++
                }</span>
        }

        <span class="cov1" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package security

import (
        "net"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// DDoSProtectionConfig contains DDoS protection configuration
type DDoSProtectionConfig struct {
        // Rate limiting (per IP)
        MaxRequestsPerSecond  int           // Maximum requests per second per IP
        MaxRequestsPerMinute  int           // Maximum requests per minute per IP
        MaxRequestsPerHour    int           // Maximum requests per hour per IP
        BurstSize             int           // Maximum burst size

        // Connection limits
        MaxConcurrentPerIP    int           // Maximum concurrent connections per IP
        MaxTotalConcurrent    int           // Maximum total concurrent connections

        // Request size limits
        MaxRequestSize        int64         // Maximum request size in bytes
        MaxHeaderSize         int           // Maximum header size in bytes
        MaxURILength          int           // Maximum URI length

        // Timeouts
        RequestTimeout        time.Duration // Maximum request processing time
        SlowlorisTimeout      time.Duration // Timeout for slow requests (Slowloris attack)
        ReadTimeout           time.Duration // Read timeout
        WriteTimeout          time.Duration // Write timeout

        // Protection features
        EnableIPBlocking      bool          // Enable automatic IP blocking
        BlockDuration         time.Duration // Duration to block IP
        SuspiciousThreshold   int           // Requests before marking as suspicious
        BanThreshold          int           // Failed attempts before banning

        // Cleanup
        CleanupInterval       time.Duration // Cleanup interval for old entries
}

// DefaultDDoSProtectionConfig returns secure default settings
func DefaultDDoSProtectionConfig() DDoSProtectionConfig <span class="cov5" title="9">{
        return DDoSProtectionConfig{
                // Rate limiting
                MaxRequestsPerSecond: 100,              // 100 req/sec per IP
                MaxRequestsPerMinute: 3000,             // 3000 req/min per IP
                MaxRequestsPerHour:   50000,            // 50k req/hour per IP
                BurstSize:            200,              // Allow short bursts

                // Connection limits
                MaxConcurrentPerIP:   50,               // 50 concurrent per IP
                MaxTotalConcurrent:   10000,            // 10k total concurrent

                // Request size limits
                MaxRequestSize:       10 * 1024 * 1024, // 10MB max request
                MaxHeaderSize:        8192,             // 8KB max headers
                MaxURILength:         4096,             // 4KB max URI

                // Timeouts
                RequestTimeout:       30 * time.Second,
                SlowlorisTimeout:     10 * time.Second,
                ReadTimeout:          10 * time.Second,
                WriteTimeout:         10 * time.Second,

                // Protection
                EnableIPBlocking:     true,
                BlockDuration:        15 * time.Minute, // Block for 15 minutes
                SuspiciousThreshold:  500,              // 500 req/sec is suspicious
                BanThreshold:         10,               // 10 failed attempts = ban

                // Cleanup
                CleanupInterval:      1 * time.Minute,
        }
}</span>

// ipStats tracks statistics for an IP address
type ipStats struct {
        // Request counts
        requestsLastSecond   int
        requestsLastMinute   int
        requestsLastHour     int
        lastSecond           time.Time
        lastMinute           time.Time
        lastHour             time.Time

        // Connection tracking
        concurrentRequests   int

        // Blocking
        blocked              bool
        blockExpiry          time.Time
        failedAttempts       int
        suspiciousActivity   bool

        // Timing
        lastRequest          time.Time
        firstRequest         time.Time

        mu                   sync.RWMutex
}

// ddosProtector implements DDoS protection
type ddosProtector struct {
        config              DDoSProtectionConfig
        ipStats             map[string]*ipStats
        ipStatsMu           sync.RWMutex

        // Global statistics
        totalConcurrent     int
        totalConcurrentMu   sync.RWMutex

        // Blocked IPs
        blockedIPs          map[string]time.Time
        blockedIPsMu        sync.RWMutex

        // Whitelisted IPs
        whitelistedIPs      map[string]bool
        whitelistedIPsMu    sync.RWMutex

        // Cleanup
        stopCleanup         chan struct{}
        cleanupDone         sync.WaitGroup
}

// newDDoSProtector creates a new DDoS protector
func newDDoSProtector(cfg DDoSProtectionConfig) *ddosProtector <span class="cov6" title="10">{
        dp := &amp;ddosProtector{
                config:         cfg,
                ipStats:        make(map[string]*ipStats),
                blockedIPs:     make(map[string]time.Time),
                whitelistedIPs: make(map[string]bool),
                stopCleanup:    make(chan struct{}),
        }

        // Start background cleanup
        dp.cleanupDone.Add(1)
        go dp.cleanupLoop()

        return dp
}</span>

// checkRequest checks if a request should be allowed
func (dp *ddosProtector) checkRequest(ip string) (allowed bool, reason string) <span class="cov10" title="61">{
        // Check if IP is whitelisted
        dp.whitelistedIPsMu.RLock()
        if dp.whitelistedIPs[ip] </span><span class="cov7" title="20">{
                dp.whitelistedIPsMu.RUnlock()
                return true, ""
        }</span>
        <span class="cov9" title="41">dp.whitelistedIPsMu.RUnlock()

        // Check if IP is blocked
        dp.blockedIPsMu.RLock()
        if blockExpiry, blocked := dp.blockedIPs[ip]; blocked </span><span class="cov2" title="2">{
                if time.Now().Before(blockExpiry) </span><span class="cov1" title="1">{
                        dp.blockedIPsMu.RUnlock()
                        return false, "IP address is blocked"
                }</span>
                // Block expired, remove it
                <span class="cov1" title="1">dp.blockedIPsMu.RUnlock()
                dp.blockedIPsMu.Lock()
                delete(dp.blockedIPs, ip)
                dp.blockedIPsMu.Unlock()</span>
        } else<span class="cov9" title="39"> {
                dp.blockedIPsMu.RUnlock()
        }</span>

        // Check global concurrent limit
        <span class="cov9" title="40">dp.totalConcurrentMu.RLock()
        if dp.totalConcurrent &gt;= dp.config.MaxTotalConcurrent </span><span class="cov0" title="0">{
                dp.totalConcurrentMu.RUnlock()
                return false, "Server at maximum capacity"
        }</span>
        <span class="cov9" title="40">dp.totalConcurrentMu.RUnlock()

        // Get or create IP stats
        stats := dp.getOrCreateIPStats(ip)
        stats.mu.Lock()
        defer stats.mu.Unlock()

        now := time.Now()

        // Check if IP is blocked
        if stats.blocked &amp;&amp; now.Before(stats.blockExpiry) </span><span class="cov0" title="0">{
                return false, "IP address is temporarily blocked"
        }</span>
        <span class="cov9" title="40">if stats.blocked &amp;&amp; now.After(stats.blockExpiry) </span><span class="cov0" title="0">{
                stats.blocked = false
                stats.failedAttempts = 0
        }</span>

        // Update rate counters
        <span class="cov9" title="40">if now.Sub(stats.lastSecond) &gt;= time.Second </span><span class="cov0" title="0">{
                stats.requestsLastSecond = 0
                stats.lastSecond = now
        }</span>
        <span class="cov9" title="40">if now.Sub(stats.lastMinute) &gt;= time.Minute </span><span class="cov0" title="0">{
                stats.requestsLastMinute = 0
                stats.lastMinute = now
        }</span>
        <span class="cov9" title="40">if now.Sub(stats.lastHour) &gt;= time.Hour </span><span class="cov0" title="0">{
                stats.requestsLastHour = 0
                stats.lastHour = now
        }</span>

        // Check rate limits
        <span class="cov9" title="40">if stats.requestsLastSecond &gt;= dp.config.MaxRequestsPerSecond </span><span class="cov4" title="6">{
                stats.suspiciousActivity = true
                if stats.requestsLastSecond &gt;= dp.config.SuspiciousThreshold </span><span class="cov0" title="0">{
                        dp.blockIP(ip, "Excessive requests per second")
                        return false, "Rate limit exceeded - IP blocked"
                }</span>
                <span class="cov4" title="6">return false, "Rate limit exceeded (per second)"</span>
        }

        <span class="cov8" title="34">if stats.requestsLastMinute &gt;= dp.config.MaxRequestsPerMinute </span><span class="cov0" title="0">{
                return false, "Rate limit exceeded (per minute)"
        }</span>

        <span class="cov8" title="34">if stats.requestsLastHour &gt;= dp.config.MaxRequestsPerHour </span><span class="cov0" title="0">{
                return false, "Rate limit exceeded (per hour)"
        }</span>

        // Check concurrent connections
        <span class="cov8" title="34">if stats.concurrentRequests &gt;= dp.config.MaxConcurrentPerIP </span><span class="cov1" title="1">{
                return false, "Too many concurrent connections"
        }</span>

        // Increment counters
        <span class="cov8" title="33">stats.requestsLastSecond++
        stats.requestsLastMinute++
        stats.requestsLastHour++
        stats.concurrentRequests++
        stats.lastRequest = now

        if stats.firstRequest.IsZero() </span><span class="cov7" title="20">{
                stats.firstRequest = now
        }</span>

        // Increment global counter
        <span class="cov8" title="33">dp.totalConcurrentMu.Lock()
        dp.totalConcurrent++
        dp.totalConcurrentMu.Unlock()

        return true, ""</span>
}

// releaseRequest releases a concurrent request slot
func (dp *ddosProtector) releaseRequest(ip string) <span class="cov5" title="9">{
        stats := dp.getIPStats(ip)
        if stats != nil </span><span class="cov5" title="9">{
                stats.mu.Lock()
                if stats.concurrentRequests &gt; 0 </span><span class="cov5" title="9">{
                        stats.concurrentRequests--
                }</span>
                <span class="cov5" title="9">stats.mu.Unlock()</span>
        }

        <span class="cov5" title="9">dp.totalConcurrentMu.Lock()
        if dp.totalConcurrent &gt; 0 </span><span class="cov5" title="9">{
                dp.totalConcurrent--
        }</span>
        <span class="cov5" title="9">dp.totalConcurrentMu.Unlock()</span>
}

// blockIP blocks an IP address
func (dp *ddosProtector) blockIP(ip, reason string) <span class="cov2" title="2">{
        if !dp.config.EnableIPBlocking </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov2" title="2">stats := dp.getIPStats(ip)
        if stats != nil </span><span class="cov0" title="0">{
                stats.mu.Lock()
                stats.blocked = true
                stats.blockExpiry = time.Now().Add(dp.config.BlockDuration)
                stats.failedAttempts++
                stats.mu.Unlock()
        }</span>

        <span class="cov2" title="2">dp.blockedIPsMu.Lock()
        dp.blockedIPs[ip] = time.Now().Add(dp.config.BlockDuration)
        dp.blockedIPsMu.Unlock()

        LogSecurityEvent("IP_BLOCKED", ip, reason)</span>
}

// whitelistIP adds an IP to whitelist
func (dp *ddosProtector) whitelistIP(ip string) <span class="cov2" title="2">{
        dp.whitelistedIPsMu.Lock()
        dp.whitelistedIPs[ip] = true
        dp.whitelistedIPsMu.Unlock()
}</span>

// removeWhitelistIP removes an IP from whitelist
func (dp *ddosProtector) removeWhitelistIP(ip string) <span class="cov0" title="0">{
        dp.whitelistedIPsMu.Lock()
        delete(dp.whitelistedIPs, ip)
        dp.whitelistedIPsMu.Unlock()
}</span>

// unblockIP unblocks an IP address
func (dp *ddosProtector) unblockIP(ip string) <span class="cov0" title="0">{
        stats := dp.getIPStats(ip)
        if stats != nil </span><span class="cov0" title="0">{
                stats.mu.Lock()
                stats.blocked = false
                stats.failedAttempts = 0
                stats.mu.Unlock()
        }</span>

        <span class="cov0" title="0">dp.blockedIPsMu.Lock()
        delete(dp.blockedIPs, ip)
        dp.blockedIPsMu.Unlock()</span>
}

// getOrCreateIPStats gets or creates IP statistics
func (dp *ddosProtector) getOrCreateIPStats(ip string) *ipStats <span class="cov9" title="40">{
        dp.ipStatsMu.RLock()
        stats, exists := dp.ipStats[ip]
        dp.ipStatsMu.RUnlock()

        if exists </span><span class="cov7" title="20">{
                return stats
        }</span>

        <span class="cov7" title="20">dp.ipStatsMu.Lock()
        // Double-check after acquiring write lock
        stats, exists = dp.ipStats[ip]
        if !exists </span><span class="cov7" title="20">{
                stats = &amp;ipStats{
                        lastSecond: time.Now(),
                        lastMinute: time.Now(),
                        lastHour:   time.Now(),
                }
                dp.ipStats[ip] = stats
        }</span>
        <span class="cov7" title="20">dp.ipStatsMu.Unlock()

        return stats</span>
}

// getIPStats gets IP statistics if they exist
func (dp *ddosProtector) getIPStats(ip string) *ipStats <span class="cov6" title="11">{
        dp.ipStatsMu.RLock()
        defer dp.ipStatsMu.RUnlock()
        return dp.ipStats[ip]
}</span>

// cleanupLoop runs background cleanup
func (dp *ddosProtector) cleanupLoop() <span class="cov6" title="10">{
        defer dp.cleanupDone.Done()

        ticker := time.NewTicker(dp.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov6" title="11">{
                select </span>{
                case &lt;-ticker.C:<span class="cov1" title="1">
                        dp.cleanup()</span>
                case &lt;-dp.stopCleanup:<span class="cov4" title="6">
                        return</span>
                }
        }
}

// cleanup removes old entries
func (dp *ddosProtector) cleanup() <span class="cov1" title="1">{
        now := time.Now()

        // Cleanup IP stats
        dp.ipStatsMu.Lock()
        for ip, stats := range dp.ipStats </span><span class="cov6" title="10">{
                stats.mu.RLock()
                inactive := now.Sub(stats.lastRequest) &gt; 5*time.Minute
                stats.mu.RUnlock()

                if inactive </span><span class="cov0" title="0">{
                        delete(dp.ipStats, ip)
                }</span>
        }
        <span class="cov1" title="1">dp.ipStatsMu.Unlock()

        // Cleanup expired blocks
        dp.blockedIPsMu.Lock()
        for ip, expiry := range dp.blockedIPs </span><span class="cov0" title="0">{
                if now.After(expiry) </span><span class="cov0" title="0">{
                        delete(dp.blockedIPs, ip)
                }</span>
        }
        <span class="cov1" title="1">dp.blockedIPsMu.Unlock()</span>
}

// close stops the DDoS protector
func (dp *ddosProtector) close() <span class="cov4" title="6">{
        close(dp.stopCleanup)
        dp.cleanupDone.Wait()
}</span>

// DDoSProtectionMiddleware creates DDoS protection middleware
func DDoSProtectionMiddleware(cfg DDoSProtectionConfig) gin.HandlerFunc <span class="cov4" title="4">{
        protector := newDDoSProtector(cfg)

        return func(c *gin.Context) </span><span class="cov6" title="15">{
                // Get client IP
                ip := c.ClientIP()

                // Check request size
                if c.Request.ContentLength &gt; cfg.MaxRequestSize </span><span class="cov1" title="1">{
                        LogSecurityEvent("REQUEST_TOO_LARGE", ip, "Request size exceeded limit")
                        c.JSON(http.StatusRequestEntityTooLarge, gin.H{
                                "error": "Request entity too large",
                        })
                        c.Abort()
                        return
                }</span>

                // Check URI length
                <span class="cov6" title="14">if len(c.Request.RequestURI) &gt; cfg.MaxURILength </span><span class="cov1" title="1">{
                        LogSecurityEvent("URI_TOO_LONG", ip, "URI length exceeded limit")
                        c.JSON(http.StatusRequestURITooLong, gin.H{
                                "error": "Request URI too long",
                        })
                        c.Abort()
                        return
                }</span>

                // Check if request should be allowed
                <span class="cov6" title="13">allowed, reason := protector.checkRequest(ip)
                if !allowed </span><span class="cov4" title="5">{
                        LogSecurityEvent("REQUEST_BLOCKED", ip, reason)
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": reason,
                                "retry_after": cfg.BlockDuration.String(),
                        })
                        c.Abort()
                        return
                }</span>

                // Process request
                <span class="cov5" title="8">c.Next()

                // Release concurrent request slot
                protector.releaseRequest(ip)

                // Check for failed authentication (401, 403)
                if c.Writer.Status() == http.StatusUnauthorized || c.Writer.Status() == http.StatusForbidden </span><span class="cov0" title="0">{
                        stats := protector.getIPStats(ip)
                        if stats != nil </span><span class="cov0" title="0">{
                                stats.mu.Lock()
                                stats.failedAttempts++
                                if stats.failedAttempts &gt;= cfg.BanThreshold </span><span class="cov0" title="0">{
                                        protector.blockIP(ip, "Too many failed authentication attempts")
                                }</span>
                                <span class="cov0" title="0">stats.mu.Unlock()</span>
                        }
                }
        }
}

// extractIPFromContext extracts IP address from request
func extractIPFromContext(c *gin.Context) string <span class="cov3" title="3">{
        // Try X-Forwarded-For header first
        forwarded := c.GetHeader("X-Forwarded-For")
        if forwarded != "" </span><span class="cov1" title="1">{
                // Take first IP in the list
                if ip := net.ParseIP(forwarded); ip != nil </span><span class="cov1" title="1">{
                        return ip.String()
                }</span>
        }

        // Try X-Real-IP header
        <span class="cov2" title="2">realIP := c.GetHeader("X-Real-IP")
        if realIP != "" </span><span class="cov1" title="1">{
                if ip := net.ParseIP(realIP); ip != nil </span><span class="cov1" title="1">{
                        return ip.String()
                }</span>
        }

        // Fall back to RemoteAddr
        <span class="cov1" title="1">ip, _, _ := net.SplitHostPort(c.Request.RemoteAddr)
        return ip</span>
}

// DDoSStatistics contains DDoS protection statistics
type DDoSStatistics struct {
        TotalRequests     int64
        BlockedRequests   int64
        BlockedIPs        int
        WhitelistedIPs    int
        ActiveConnections int
        TrackedIPs        int
}

// GetStatistics returns DDoS protection statistics
func (dp *ddosProtector) GetStatistics() *DDoSStatistics <span class="cov1" title="1">{
        dp.ipStatsMu.RLock()
        trackedIPs := len(dp.ipStats)
        dp.ipStatsMu.RUnlock()

        dp.blockedIPsMu.RLock()
        blockedIPs := len(dp.blockedIPs)
        dp.blockedIPsMu.RUnlock()

        dp.whitelistedIPsMu.RLock()
        whitelistedIPs := len(dp.whitelistedIPs)
        dp.whitelistedIPsMu.RUnlock()

        dp.totalConcurrentMu.RLock()
        activeConnections := dp.totalConcurrent
        dp.totalConcurrentMu.RUnlock()

        return &amp;DDoSStatistics{
                TrackedIPs:        trackedIPs,
                BlockedIPs:        blockedIPs,
                WhitelistedIPs:    whitelistedIPs,
                ActiveConnections: activeConnections,
        }
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package security

import (
        "fmt"
        "html"
        "net/http"
        "regexp"
        "strings"
        "unicode"

        "github.com/gin-gonic/gin"
)

// InputValidationConfig contains input validation configuration
type InputValidationConfig struct {
        // SQL Injection Protection
        EnableSQLInjectionCheck   bool
        BlockSQLKeywords          bool

        // XSS Protection
        EnableXSSCheck            bool
        SanitizeHTML              bool
        AllowedHTMLTags           []string

        // Path Traversal Protection
        EnablePathTraversalCheck  bool

        // Command Injection Protection
        EnableCommandInjectionCheck bool

        // LDAP Injection Protection
        EnableLDAPInjectionCheck  bool

        // Max lengths
        MaxStringLength           int
        MaxArrayLength            int
        MaxJSONDepth              int

        // Character restrictions
        AllowUnicode              bool
        AllowSpecialChars         bool
        AllowedSpecialChars       string
}

// DefaultInputValidationConfig returns secure default settings
func DefaultInputValidationConfig() InputValidationConfig <span class="cov3" title="4">{
        return InputValidationConfig{
                EnableSQLInjectionCheck:     true,
                BlockSQLKeywords:            true,
                EnableXSSCheck:              true,
                SanitizeHTML:                true,
                AllowedHTMLTags:             []string{}, // No HTML allowed by default
                EnablePathTraversalCheck:    true,
                EnableCommandInjectionCheck: true,
                EnableLDAPInjectionCheck:    true,
                MaxStringLength:             10000,
                MaxArrayLength:              1000,
                MaxJSONDepth:                10,
                AllowUnicode:                true,
                AllowSpecialChars:           true,
                AllowedSpecialChars:         "!@#$%^&amp;*()_+-=[]{}|;:',.&lt;&gt;?/~` ",
        }
}</span>

// SQL injection patterns
var sqlInjectionPatterns = []*regexp.Regexp{
        regexp.MustCompile(`(?i)(union.*select)`),
        regexp.MustCompile(`(?i)(select.*from)`),
        regexp.MustCompile(`(?i)(insert.*into)`),
        regexp.MustCompile(`(?i)(delete.*from)`),
        regexp.MustCompile(`(?i)(drop.*table)`),
        regexp.MustCompile(`(?i)(update.*set)`),
        regexp.MustCompile(`(?i)(exec(ute)?)`),
        regexp.MustCompile(`(?i)(--)`),
        regexp.MustCompile(`(?i)(;.*--)`),
        regexp.MustCompile(`(?i)('.*or.*'.*=.*')`),
        regexp.MustCompile(`(?i)(or.*1.*=.*1)`),
        regexp.MustCompile(`(?i)(and.*1.*=.*1)`),
        regexp.MustCompile(`(?i)(having)`),
        regexp.MustCompile(`(?i)(group.*by)`),
        regexp.MustCompile(`(?i)(order.*by)`),
        regexp.MustCompile(`(?i)(waitfor.*delay)`),
        regexp.MustCompile(`(?i)(benchmark)`),
        regexp.MustCompile(`(?i)(sleep\()`),
}

// XSS patterns
var xssPatterns = []*regexp.Regexp{
        regexp.MustCompile(`(?i)&lt;script`),
        regexp.MustCompile(`(?i)&lt;/script&gt;`),
        regexp.MustCompile(`(?i)javascript:`),
        regexp.MustCompile(`(?i)onerror\s*=`),
        regexp.MustCompile(`(?i)onload\s*=`),
        regexp.MustCompile(`(?i)onclick\s*=`),
        regexp.MustCompile(`(?i)onmouseover\s*=`),
        regexp.MustCompile(`(?i)&lt;iframe`),
        regexp.MustCompile(`(?i)&lt;object`),
        regexp.MustCompile(`(?i)&lt;embed`),
        regexp.MustCompile(`(?i)&lt;img.*src`),
        regexp.MustCompile(`(?i)eval\(`),
        regexp.MustCompile(`(?i)expression\(`),
        regexp.MustCompile(`(?i)vbscript:`),
        regexp.MustCompile(`(?i)data:text/html`),
}

// Path traversal patterns
var pathTraversalPatterns = []*regexp.Regexp{
        regexp.MustCompile(`\.\.\/`),
        regexp.MustCompile(`\.\.\\`),
        regexp.MustCompile(`%2e%2e%2f`),
        regexp.MustCompile(`%2e%2e\\`),
        regexp.MustCompile(`\.\.%2f`),
        regexp.MustCompile(`\.\.%5c`),
}

// Command injection patterns
var commandInjectionPatterns = []*regexp.Regexp{
        regexp.MustCompile(`[;&amp;|]`),
        regexp.MustCompile(`\$\(`),
        regexp.MustCompile("`.*`"),
        regexp.MustCompile(`&gt;\s*/dev/null`),
        regexp.MustCompile(`&amp;&amp;`),
        regexp.MustCompile(`\|\|`),
}

// LDAP injection patterns
var ldapInjectionPatterns = []*regexp.Regexp{
        regexp.MustCompile(`\*`),
        regexp.MustCompile(`\(\)`),
        regexp.MustCompile(`\|\|`),
        regexp.MustCompile(`&amp;&amp;`),
}

// ValidateString validates a string input
func ValidateString(input string, cfg InputValidationConfig) (valid bool, sanitized string, reason string) <span class="cov5" title="18">{
        // Check length
        if len(input) &gt; cfg.MaxStringLength </span><span class="cov1" title="1">{
                return false, "", fmt.Sprintf("String exceeds maximum length of %d", cfg.MaxStringLength)
        }</span>

        // Check for SQL injection
        <span class="cov5" title="17">if cfg.EnableSQLInjectionCheck </span><span class="cov5" title="17">{
                for _, pattern := range sqlInjectionPatterns </span><span class="cov10" title="251">{
                        if pattern.MatchString(input) </span><span class="cov3" title="4">{
                                return false, "", "Potential SQL injection detected"
                        }</span>
                }
        }

        // Check for XSS
        <span class="cov5" title="13">if cfg.EnableXSSCheck </span><span class="cov5" title="13">{
                for _, pattern := range xssPatterns </span><span class="cov9" title="144">{
                        if pattern.MatchString(input) </span><span class="cov3" title="4">{
                                return false, "", "Potential XSS attack detected"
                        }</span>
                }
        }

        // Check for path traversal
        <span class="cov4" title="9">if cfg.EnablePathTraversalCheck </span><span class="cov4" title="9">{
                for _, pattern := range pathTraversalPatterns </span><span class="cov7" title="46">{
                        if pattern.MatchString(input) </span><span class="cov2" title="2">{
                                return false, "", "Potential path traversal detected"
                        }</span>
                }
        }

        // Check for command injection
        <span class="cov4" title="7">if cfg.EnableCommandInjectionCheck </span><span class="cov4" title="7">{
                for _, pattern := range commandInjectionPatterns </span><span class="cov6" title="29">{
                        if pattern.MatchString(input) </span><span class="cov2" title="3">{
                                return false, "", "Potential command injection detected"
                        }</span>
                }
        }

        // Check for LDAP injection
        <span class="cov3" title="4">if cfg.EnableLDAPInjectionCheck </span><span class="cov3" title="4">{
                for _, pattern := range ldapInjectionPatterns </span><span class="cov5" title="13">{
                        if pattern.MatchString(input) </span><span class="cov1" title="1">{
                                return false, "", "Potential LDAP injection detected"
                        }</span>
                }
        }

        // Sanitize HTML if enabled
        <span class="cov2" title="3">sanitized = input
        if cfg.SanitizeHTML </span><span class="cov2" title="3">{
                sanitized = html.EscapeString(input)
        }</span>

        // Check character restrictions
        <span class="cov2" title="3">if !cfg.AllowUnicode || !cfg.AllowSpecialChars </span><span class="cov0" title="0">{
                for _, r := range input </span><span class="cov0" title="0">{
                        if !cfg.AllowUnicode &amp;&amp; r &gt; unicode.MaxASCII </span><span class="cov0" title="0">{
                                return false, "", "Unicode characters not allowed"
                        }</span>

                        <span class="cov0" title="0">if !cfg.AllowSpecialChars </span><span class="cov0" title="0">{
                                if !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r) &amp;&amp; r != ' ' </span><span class="cov0" title="0">{
                                        if !strings.ContainsRune(cfg.AllowedSpecialChars, r) </span><span class="cov0" title="0">{
                                                return false, "", fmt.Sprintf("Special character not allowed: %c", r)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov2" title="3">return true, sanitized, ""</span>
}

// SanitizeInput sanitizes input by removing dangerous characters
func SanitizeInput(input string) string <span class="cov2" title="3">{
        // Remove null bytes
        input = strings.ReplaceAll(input, "\x00", "")

        // Trim whitespace
        input = strings.TrimSpace(input)

        // Escape HTML
        input = html.EscapeString(input)

        return input
}</span>

// SanitizeFilename sanitizes a filename
func SanitizeFilename(filename string) string <span class="cov3" title="4">{
        // Remove path separators
        filename = strings.ReplaceAll(filename, "/", "")
        filename = strings.ReplaceAll(filename, "\\", "")

        // Remove null bytes
        filename = strings.ReplaceAll(filename, "\x00", "")

        // Remove dangerous characters
        dangerousChars := []string{"&lt;", "&gt;", ":", "\"", "|", "?", "*"}
        for _, char := range dangerousChars </span><span class="cov6" title="28">{
                filename = strings.ReplaceAll(filename, char, "")
        }</span>

        // Remove leading dots (path traversal sequences)
        <span class="cov3" title="4">filename = strings.TrimLeft(filename, ".")

        return filename</span>
}

// SanitizeURL sanitizes a URL
func SanitizeURL(url string) (string, error) <span class="cov3" title="5">{
        // Check for javascript: protocol
        if strings.HasPrefix(strings.ToLower(url), "javascript:") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("javascript: protocol not allowed")
        }</span>

        // Check for data: protocol
        <span class="cov3" title="4">if strings.HasPrefix(strings.ToLower(url), "data:") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("data: protocol not allowed")
        }</span>

        // Only allow http: and https:
        <span class="cov2" title="3">if !strings.HasPrefix(strings.ToLower(url), "http://") &amp;&amp;
                !strings.HasPrefix(strings.ToLower(url), "https://") </span><span class="cov1" title="1">{
                return "", fmt.Errorf("only http: and https: protocols allowed")
        }</span>

        <span class="cov2" title="2">return url, nil</span>
}

// ValidateEmail validates an email address
func ValidateEmail(email string) bool <span class="cov4" title="7">{
        emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
        return emailRegex.MatchString(email)
}</span>

// ValidateUsername validates a username
func ValidateUsername(username string) (bool, string) <span class="cov3" title="6">{
        if len(username) &lt; 3 </span><span class="cov1" title="1">{
                return false, "Username must be at least 3 characters"
        }</span>
        <span class="cov3" title="5">if len(username) &gt; 50 </span><span class="cov1" title="1">{
                return false, "Username must be at most 50 characters"
        }</span>

        // Allow only alphanumeric and underscore
        <span class="cov3" title="4">usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
        if !usernameRegex.MatchString(username) </span><span class="cov2" title="2">{
                return false, "Username can only contain letters, numbers, and underscores"
        }</span>

        <span class="cov2" title="2">return true, ""</span>
}

// ValidatePassword validates a password
func ValidatePassword(password string) (bool, string) <span class="cov4" title="7">{
        if len(password) &lt; 8 </span><span class="cov1" title="1">{
                return false, "Password must be at least 8 characters"
        }</span>
        <span class="cov3" title="6">if len(password) &gt; 128 </span><span class="cov0" title="0">{
                return false, "Password must be at most 128 characters"
        }</span>

        // Check for at least one uppercase, one lowercase, one digit
        <span class="cov3" title="6">hasUpper := false
        hasLower := false
        hasDigit := false
        hasSpecial := false

        for _, r := range password </span><span class="cov7" title="70">{
                if unicode.IsUpper(r) </span><span class="cov5" title="13">{
                        hasUpper = true
                }</span>
                <span class="cov7" title="70">if unicode.IsLower(r) </span><span class="cov6" title="35">{
                        hasLower = true
                }</span>
                <span class="cov7" title="70">if unicode.IsDigit(r) </span><span class="cov5" title="17">{
                        hasDigit = true
                }</span>
                <span class="cov7" title="70">if !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r) </span><span class="cov3" title="5">{
                        hasSpecial = true
                }</span>
        }

        <span class="cov3" title="6">if !hasUpper </span><span class="cov1" title="1">{
                return false, "Password must contain at least one uppercase letter"
        }</span>
        <span class="cov3" title="5">if !hasLower </span><span class="cov1" title="1">{
                return false, "Password must contain at least one lowercase letter"
        }</span>
        <span class="cov3" title="4">if !hasDigit </span><span class="cov1" title="1">{
                return false, "Password must contain at least one digit"
        }</span>
        <span class="cov2" title="3">if !hasSpecial </span><span class="cov1" title="1">{
                return false, "Password must contain at least one special character"
        }</span>

        <span class="cov2" title="2">return true, ""</span>
}

// InputValidationMiddleware creates input validation middleware
func InputValidationMiddleware(cfg InputValidationConfig) gin.HandlerFunc <span class="cov2" title="3">{
        return func(c *gin.Context) </span><span class="cov2" title="3">{
                // Validate query parameters
                for key, values := range c.Request.URL.Query() </span><span class="cov3" title="4">{
                        for _, value := range values </span><span class="cov3" title="4">{
                                valid, _, reason := ValidateString(value, cfg)
                                if !valid </span><span class="cov2" title="2">{
                                        LogSecurityEvent("INVALID_INPUT", c.ClientIP(),
                                                fmt.Sprintf("Invalid query parameter %s: %s", key, reason))
                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "error": "Invalid input detected",
                                        })
                                        c.Abort()
                                        return
                                }</span>
                        }
                }

                // Validate headers
                <span class="cov1" title="1">suspiciousHeaders := []string{
                        "X-Forwarded-Host",
                        "X-Original-URL",
                        "X-Rewrite-URL",
                }

                for _, header := range suspiciousHeaders </span><span class="cov2" title="3">{
                        if value := c.GetHeader(header); value != "" </span><span class="cov0" title="0">{
                                valid, _, reason := ValidateString(value, cfg)
                                if !valid </span><span class="cov0" title="0">{
                                        LogSecurityEvent("INVALID_INPUT", c.ClientIP(),
                                                fmt.Sprintf("Invalid header %s: %s", header, reason))
                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "error": "Invalid input detected",
                                        })
                                        c.Abort()
                                        return
                                }</span>
                        }
                }

                <span class="cov1" title="1">c.Next()</span>
        }
}

// SQLInjectionPattern checks for SQL injection patterns
func SQLInjectionPattern(input string) bool <span class="cov4" title="8">{
        for _, pattern := range sqlInjectionPatterns </span><span class="cov7" title="59">{
                if pattern.MatchString(input) </span><span class="cov3" title="6">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// XSSPattern checks for XSS patterns
func XSSPattern(input string) bool <span class="cov4" title="8">{
        for _, pattern := range xssPatterns </span><span class="cov7" title="63">{
                if pattern.MatchString(input) </span><span class="cov3" title="6">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// PathTraversalPattern checks for path traversal patterns
func PathTraversalPattern(input string) bool <span class="cov3" title="5">{
        for _, pattern := range pathTraversalPatterns </span><span class="cov5" title="18">{
                if pattern.MatchString(input) </span><span class="cov2" title="3">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package security

import (
        "fmt"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
)

// SecurityHeadersConfig contains security headers configuration
type SecurityHeadersConfig struct {
        // HSTS (HTTP Strict Transport Security)
        EnableHSTS            bool
        HSTSMaxAge            int    // Seconds (default: 31536000 = 1 year)
        HSTSIncludeSubdomains bool
        HSTSPreload           bool

        // CSP (Content Security Policy)
        EnableCSP             bool
        CSPDirectives         map[string][]string
        CSPReportOnly         bool
        CSPReportURI          string

        // X-Frame-Options (Clickjacking protection)
        EnableFrameOptions    bool
        FrameOption           string // DENY, SAMEORIGIN, or ALLOW-FROM uri

        // X-Content-Type-Options (MIME sniffing protection)
        EnableContentTypeOptions bool

        // X-XSS-Protection
        EnableXSSProtection   bool
        XSSProtectionMode     string // "0", "1", "1; mode=block"

        // Referrer-Policy
        EnableReferrerPolicy  bool
        ReferrerPolicy        string // no-referrer, strict-origin-when-cross-origin, etc.

        // Permissions-Policy (formerly Feature-Policy)
        EnablePermissionsPolicy bool
        PermissionsDirectives   map[string]string

        // Additional security headers
        EnableExpectCT        bool
        ExpectCTMaxAge        int
        ExpectCTEnforce       bool
        ExpectCTReportURI     string

        // Cross-Origin headers
        EnableCORP            bool // Cross-Origin-Resource-Policy
        CORPPolicy            string // same-site, same-origin, cross-origin

        EnableCOEP            bool // Cross-Origin-Embedder-Policy
        COEPPolicy            string // require-corp, credentialless

        EnableCOOP            bool // Cross-Origin-Opener-Policy
        COOPPolicy            string // same-origin, same-origin-allow-popups, unsafe-none

        // Server header
        RemoveServerHeader    bool
        CustomServerHeader    string

        // X-Powered-By header
        RemovePoweredByHeader bool
}

// DefaultSecurityHeadersConfig returns secure default settings
func DefaultSecurityHeadersConfig() SecurityHeadersConfig <span class="cov5" title="6">{
        return SecurityHeadersConfig{
                // HSTS - Force HTTPS for 1 year
                EnableHSTS:            true,
                HSTSMaxAge:            31536000, // 1 year
                HSTSIncludeSubdomains: true,
                HSTSPreload:           true,

                // CSP - Strict content security policy
                EnableCSP:      true,
                CSPDirectives: map[string][]string{
                        "default-src": {"'self'"},
                        "script-src":  {"'self'", "'unsafe-inline'"}, // Allow inline scripts for now
                        "style-src":   {"'self'", "'unsafe-inline'"}, // Allow inline styles for now
                        "img-src":     {"'self'", "data:", "https:"},
                        "font-src":    {"'self'", "data:"},
                        "connect-src": {"'self'"},
                        "media-src":   {"'self'"},
                        "object-src":  {"'none'"},
                        "frame-src":   {"'none'"},
                        "base-uri":    {"'self'"},
                        "form-action": {"'self'"},
                        "frame-ancestors": {"'none'"}, // Prevent clickjacking
                        "upgrade-insecure-requests": {}, // Upgrade HTTP to HTTPS
                },
                CSPReportOnly: false,

                // X-Frame-Options - Prevent clickjacking
                EnableFrameOptions: true,
                FrameOption:        "DENY",

                // X-Content-Type-Options - Prevent MIME sniffing
                EnableContentTypeOptions: true,

                // X-XSS-Protection - Enable XSS filter
                EnableXSSProtection: true,
                XSSProtectionMode:   "1; mode=block",

                // Referrer-Policy - Strict referrer policy
                EnableReferrerPolicy: true,
                ReferrerPolicy:       "strict-origin-when-cross-origin",

                // Permissions-Policy - Disable dangerous features
                EnablePermissionsPolicy: true,
                PermissionsDirectives: map[string]string{
                        "geolocation":           "()",
                        "microphone":            "()",
                        "camera":                "()",
                        "payment":               "()",
                        "usb":                   "()",
                        "magnetometer":          "()",
                        "gyroscope":             "()",
                        "accelerometer":         "()",
                        "ambient-light-sensor":  "()",
                        "autoplay":              "()",
                        "encrypted-media":       "()",
                        "fullscreen":            "(self)",
                        "picture-in-picture":    "()",
                },

                // Expect-CT - Require Certificate Transparency
                EnableExpectCT:  true,
                ExpectCTMaxAge:  86400, // 24 hours
                ExpectCTEnforce: true,

                // Cross-Origin policies
                EnableCORP:   true,
                CORPPolicy:   "same-origin",
                EnableCOEP:   true,
                COEPPolicy:   "require-corp",
                EnableCOOP:   true,
                COOPPolicy:   "same-origin",

                // Remove identifying headers
                RemoveServerHeader:    true,
                RemovePoweredByHeader: true,
        }
}</span>

// StrictSecurityHeadersConfig returns very strict security settings
func StrictSecurityHeadersConfig() SecurityHeadersConfig <span class="cov1" title="1">{
        cfg := DefaultSecurityHeadersConfig()

        // Stricter CSP
        cfg.CSPDirectives = map[string][]string{
                "default-src":         {"'none'"},
                "script-src":          {"'self'"},
                "style-src":           {"'self'"},
                "img-src":             {"'self'"},
                "font-src":            {"'self'"},
                "connect-src":         {"'self'"},
                "media-src":           {"'none'"},
                "object-src":          {"'none'"},
                "frame-src":           {"'none'"},
                "base-uri":            {"'self'"},
                "form-action":         {"'self'"},
                "frame-ancestors":     {"'none'"},
                "upgrade-insecure-requests": {},
        }

        // Stricter referrer policy
        cfg.ReferrerPolicy = "no-referrer"

        return cfg
}</span>

// RelaxedSecurityHeadersConfig returns more permissive settings for development
func RelaxedSecurityHeadersConfig() SecurityHeadersConfig <span class="cov1" title="1">{
        cfg := DefaultSecurityHeadersConfig()

        // More permissive CSP for development
        cfg.CSPDirectives = map[string][]string{
                "default-src": {"'self'", "'unsafe-inline'", "'unsafe-eval'"},
                "img-src":     {"'self'", "data:", "https:", "http:"},
                "connect-src": {"'self'", "ws:", "wss:"},
        }

        // Disable some headers for development
        cfg.EnableHSTS = false
        cfg.EnableExpectCT = false

        return cfg
}</span>

// SecurityHeadersMiddleware creates security headers middleware
func SecurityHeadersMiddleware(cfg SecurityHeadersConfig) gin.HandlerFunc <span class="cov4" title="4">{
        return func(c *gin.Context) </span><span class="cov4" title="4">{
                // Remove identifying headers
                if cfg.RemoveServerHeader </span><span class="cov4" title="4">{
                        c.Header("Server", cfg.CustomServerHeader)
                }</span>
                <span class="cov4" title="4">if cfg.RemovePoweredByHeader </span><span class="cov4" title="4">{
                        c.Header("X-Powered-By", "")
                }</span>

                // HSTS - HTTP Strict Transport Security
                <span class="cov4" title="4">if cfg.EnableHSTS &amp;&amp; c.Request.TLS != nil </span><span class="cov1" title="1">{
                        hsts := fmt.Sprintf("max-age=%d", cfg.HSTSMaxAge)
                        if cfg.HSTSIncludeSubdomains </span><span class="cov1" title="1">{
                                hsts += "; includeSubDomains"
                        }</span>
                        <span class="cov1" title="1">if cfg.HSTSPreload </span><span class="cov1" title="1">{
                                hsts += "; preload"
                        }</span>
                        <span class="cov1" title="1">c.Header("Strict-Transport-Security", hsts)</span>
                }

                // CSP - Content Security Policy
                <span class="cov4" title="4">if cfg.EnableCSP </span><span class="cov4" title="4">{
                        csp := buildCSP(cfg.CSPDirectives)
                        if cfg.CSPReportURI != "" </span><span class="cov0" title="0">{
                                csp += fmt.Sprintf("; report-uri %s", cfg.CSPReportURI)
                        }</span>
                        <span class="cov4" title="4">headerName := "Content-Security-Policy"
                        if cfg.CSPReportOnly </span><span class="cov0" title="0">{
                                headerName = "Content-Security-Policy-Report-Only"
                        }</span>
                        <span class="cov4" title="4">c.Header(headerName, csp)</span>
                }

                // X-Frame-Options - Clickjacking protection
                <span class="cov4" title="4">if cfg.EnableFrameOptions </span><span class="cov4" title="4">{
                        c.Header("X-Frame-Options", cfg.FrameOption)
                }</span>

                // X-Content-Type-Options - MIME sniffing protection
                <span class="cov4" title="4">if cfg.EnableContentTypeOptions </span><span class="cov4" title="4">{
                        c.Header("X-Content-Type-Options", "nosniff")
                }</span>

                // X-XSS-Protection
                <span class="cov4" title="4">if cfg.EnableXSSProtection </span><span class="cov4" title="4">{
                        c.Header("X-XSS-Protection", cfg.XSSProtectionMode)
                }</span>

                // Referrer-Policy
                <span class="cov4" title="4">if cfg.EnableReferrerPolicy </span><span class="cov4" title="4">{
                        c.Header("Referrer-Policy", cfg.ReferrerPolicy)
                }</span>

                // Permissions-Policy (formerly Feature-Policy)
                <span class="cov4" title="4">if cfg.EnablePermissionsPolicy </span><span class="cov4" title="4">{
                        pp := buildPermissionsPolicy(cfg.PermissionsDirectives)
                        c.Header("Permissions-Policy", pp)
                }</span>

                // Expect-CT - Certificate Transparency
                <span class="cov4" title="4">if cfg.EnableExpectCT &amp;&amp; c.Request.TLS != nil </span><span class="cov1" title="1">{
                        expectCT := fmt.Sprintf("max-age=%d", cfg.ExpectCTMaxAge)
                        if cfg.ExpectCTEnforce </span><span class="cov1" title="1">{
                                expectCT += ", enforce"
                        }</span>
                        <span class="cov1" title="1">if cfg.ExpectCTReportURI != "" </span><span class="cov0" title="0">{
                                expectCT += fmt.Sprintf(", report-uri=\"%s\"", cfg.ExpectCTReportURI)
                        }</span>
                        <span class="cov1" title="1">c.Header("Expect-CT", expectCT)</span>
                }

                // Cross-Origin-Resource-Policy
                <span class="cov4" title="4">if cfg.EnableCORP </span><span class="cov4" title="4">{
                        c.Header("Cross-Origin-Resource-Policy", cfg.CORPPolicy)
                }</span>

                // Cross-Origin-Embedder-Policy
                <span class="cov4" title="4">if cfg.EnableCOEP </span><span class="cov4" title="4">{
                        c.Header("Cross-Origin-Embedder-Policy", cfg.COEPPolicy)
                }</span>

                // Cross-Origin-Opener-Policy
                <span class="cov4" title="4">if cfg.EnableCOOP </span><span class="cov4" title="4">{
                        c.Header("Cross-Origin-Opener-Policy", cfg.COOPPolicy)
                }</span>

                <span class="cov4" title="4">c.Next()</span>
        }
}

// buildCSP builds a Content-Security-Policy header value
func buildCSP(directives map[string][]string) string <span class="cov4" title="5">{
        var parts []string
        for directive, values := range directives </span><span class="cov10" title="55">{
                if len(values) == 0 </span><span class="cov4" title="4">{
                        // Directive with no value (like upgrade-insecure-requests)
                        parts = append(parts, directive)
                }</span> else<span class="cov9" title="51"> {
                        // Directive with values
                        parts = append(parts, fmt.Sprintf("%s %s", directive, strings.Join(values, " ")))
                }</span>
        }
        <span class="cov4" title="5">return strings.Join(parts, "; ")</span>
}

// buildPermissionsPolicy builds a Permissions-Policy header value
func buildPermissionsPolicy(directives map[string]string) string <span class="cov4" title="5">{
        var parts []string
        for feature, allowlist := range directives </span><span class="cov10" title="55">{
                parts = append(parts, fmt.Sprintf("%s=%s", feature, allowlist))
        }</span>
        <span class="cov4" title="5">return strings.Join(parts, ", ")</span>
}

// CSPViolationReport represents a CSP violation report
type CSPViolationReport struct {
        DocumentURI        string `json:"document-uri"`
        Referrer           string `json:"referrer"`
        BlockedURI         string `json:"blocked-uri"`
        ViolatedDirective  string `json:"violated-directive"`
        EffectiveDirective string `json:"effective-directive"`
        OriginalPolicy     string `json:"original-policy"`
        Disposition        string `json:"disposition"`
        StatusCode         int    `json:"status-code"`
}

// CSPReportHandler creates a handler for CSP violation reports
func CSPReportHandler() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                var report struct {
                        CSPReport CSPViolationReport `json:"csp-report"`
                }

                if err := c.ShouldBindJSON(&amp;report); err != nil </span><span class="cov1" title="1">{
                        c.JSON(400, gin.H{"error": "Invalid CSP report"})
                        return
                }</span>

                // Log the CSP violation
                <span class="cov0" title="0">LogSecurityEvent("CSP_VIOLATION", c.ClientIP(),
                        fmt.Sprintf("Violated directive: %s, Blocked URI: %s",
                                report.CSPReport.ViolatedDirective,
                                report.CSPReport.BlockedURI))

                c.Status(204)</span> // No Content
        }
}

// SecureRedirect redirects HTTP to HTTPS
func SecureRedirect(trustProxy bool) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                // Check if request is HTTPS
                isHTTPS := c.Request.TLS != nil

                // Check X-Forwarded-Proto header if behind proxy
                if trustProxy </span><span class="cov0" title="0">{
                        proto := c.GetHeader("X-Forwarded-Proto")
                        if proto == "https" </span><span class="cov0" title="0">{
                                isHTTPS = true
                        }</span>
                }

                // Redirect to HTTPS if not already
                <span class="cov1" title="1">if !isHTTPS </span><span class="cov1" title="1">{
                        host := c.Request.Host
                        if host == "" </span><span class="cov0" title="0">{
                                host = "localhost"
                        }</span>

                        <span class="cov1" title="1">target := fmt.Sprintf("https://%s%s", host, c.Request.RequestURI)
                        LogSecurityEvent("HTTP_TO_HTTPS_REDIRECT", c.ClientIP(),
                                fmt.Sprintf("Redirecting to %s", target))

                        c.Redirect(301, target) // Permanent redirect
                        c.Abort()
                        return</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// TLSVersionMiddleware enforces minimum TLS version
func TLSVersionMiddleware(minVersion uint16) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                if c.Request.TLS != nil </span><span class="cov2" title="2">{
                        if c.Request.TLS.Version &lt; minVersion </span><span class="cov1" title="1">{
                                LogSecurityEvent("TLS_VERSION_TOO_LOW", c.ClientIP(),
                                        fmt.Sprintf("TLS version %d is too low (min: %d)",
                                                c.Request.TLS.Version, minVersion))

                                c.JSON(400, gin.H{
                                        "error": "TLS version too low",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov1" title="1">c.Next()</span>
        }
}

// SecurityHeadersChecker checks if security headers are properly set
type SecurityHeadersChecker struct {
        RequiredHeaders map[string]bool
        ForbiddenHeaders []string
}

// DefaultSecurityHeadersChecker returns a checker with recommended headers
func DefaultSecurityHeadersChecker() *SecurityHeadersChecker <span class="cov2" title="2">{
        return &amp;SecurityHeadersChecker{
                RequiredHeaders: map[string]bool{
                        "Strict-Transport-Security":    false,
                        "Content-Security-Policy":      false,
                        "X-Frame-Options":              false,
                        "X-Content-Type-Options":       false,
                        "X-XSS-Protection":             false,
                        "Referrer-Policy":              false,
                },
                ForbiddenHeaders: []string{
                        "X-Powered-By",
                        "Server",
                },
        }
}</span>

// CheckHeaders checks if security headers are properly set
func (checker *SecurityHeadersChecker) CheckHeaders(headers map[string][]string) map[string]string <span class="cov2" title="2">{
        issues := make(map[string]string)

        // Check required headers
        for header := range checker.RequiredHeaders </span><span class="cov6" title="12">{
                if _, exists := headers[header]; !exists </span><span class="cov2" title="2">{
                        issues[header] = "Missing required security header"
                }</span>
        }

        // Check forbidden headers
        <span class="cov2" title="2">for _, header := range checker.ForbiddenHeaders </span><span class="cov4" title="4">{
                if value, exists := headers[header]; exists &amp;&amp; len(value) &gt; 0 &amp;&amp; value[0] != "" </span><span class="cov2" title="2">{
                        issues[header] = "Forbidden header present (information disclosure)"
                }</span>
        }

        <span class="cov2" title="2">return issues</span>
}

// SecurityHeadersAuditMiddleware logs security headers for audit
func SecurityHeadersAuditMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        checker := DefaultSecurityHeadersChecker()

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Check response headers
                issues := checker.CheckHeaders(c.Writer.Header())

                if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                        LogSecurityEvent("SECURITY_HEADERS_ISSUE", c.ClientIP(),
                                fmt.Sprintf("Issues found: %v", issues))
                }</span>
        }
}

// GetSecurityHeaders returns all security-related headers
func GetSecurityHeaders(c *gin.Context) map[string]string <span class="cov1" title="1">{
        headers := make(map[string]string)

        securityHeaderNames := []string{
                "Strict-Transport-Security",
                "Content-Security-Policy",
                "Content-Security-Policy-Report-Only",
                "X-Frame-Options",
                "X-Content-Type-Options",
                "X-XSS-Protection",
                "Referrer-Policy",
                "Permissions-Policy",
                "Feature-Policy",
                "Expect-CT",
                "Cross-Origin-Resource-Policy",
                "Cross-Origin-Embedder-Policy",
                "Cross-Origin-Opener-Policy",
        }

        for _, name := range securityHeaderNames </span><span class="cov6" title="13">{
                if value := c.Writer.Header().Get(name); value != "" </span><span class="cov5" title="9">{
                        headers[name] = value
                }</span>
        }

        <span class="cov1" title="1">return headers</span>
}

// SecurityHeadersInfo provides information about current security headers
type SecurityHeadersInfo struct {
        HSTSEnabled             bool          `json:"hsts_enabled"`
        HSTSMaxAge              time.Duration `json:"hsts_max_age,omitempty"`
        CSPEnabled              bool          `json:"csp_enabled"`
        CSPPolicy               string        `json:"csp_policy,omitempty"`
        FrameOptionsEnabled     bool          `json:"frame_options_enabled"`
        FrameOption             string        `json:"frame_option,omitempty"`
        ContentTypeNoSniff      bool          `json:"content_type_no_sniff"`
        XSSProtectionEnabled    bool          `json:"xss_protection_enabled"`
        ReferrerPolicyEnabled   bool          `json:"referrer_policy_enabled"`
        ReferrerPolicy          string        `json:"referrer_policy,omitempty"`
        PermissionsPolicyEnabled bool         `json:"permissions_policy_enabled"`
        ExpectCTEnabled         bool          `json:"expect_ct_enabled"`
        CORPEnabled             bool          `json:"corp_enabled"`
        COEPEnabled             bool          `json:"coep_enabled"`
        COOPEnabled             bool          `json:"coop_enabled"`
        ServerHeaderRemoved     bool          `json:"server_header_removed"`
        PoweredByHeaderRemoved  bool          `json:"powered_by_header_removed"`
}

// GetSecurityHeadersInfo extracts security headers information
func GetSecurityHeadersInfo(c *gin.Context) *SecurityHeadersInfo <span class="cov1" title="1">{
        info := &amp;SecurityHeadersInfo{}

        // Check HSTS
        if hsts := c.Writer.Header().Get("Strict-Transport-Security"); hsts != "" </span><span class="cov0" title="0">{
                info.HSTSEnabled = true
                // Parse max-age if needed
        }</span>

        // Check CSP
        <span class="cov1" title="1">if csp := c.Writer.Header().Get("Content-Security-Policy"); csp != "" </span><span class="cov1" title="1">{
                info.CSPEnabled = true
                info.CSPPolicy = csp
        }</span> else<span class="cov0" title="0"> if csp := c.Writer.Header().Get("Content-Security-Policy-Report-Only"); csp != "" </span><span class="cov0" title="0">{
                info.CSPEnabled = true
                info.CSPPolicy = csp + " (report-only)"
        }</span>

        // Check X-Frame-Options
        <span class="cov1" title="1">if fo := c.Writer.Header().Get("X-Frame-Options"); fo != "" </span><span class="cov1" title="1">{
                info.FrameOptionsEnabled = true
                info.FrameOption = fo
        }</span>

        // Check X-Content-Type-Options
        <span class="cov1" title="1">if ctno := c.Writer.Header().Get("X-Content-Type-Options"); ctno == "nosniff" </span><span class="cov1" title="1">{
                info.ContentTypeNoSniff = true
        }</span>

        // Check X-XSS-Protection
        <span class="cov1" title="1">if xss := c.Writer.Header().Get("X-XSS-Protection"); xss != "" </span><span class="cov1" title="1">{
                info.XSSProtectionEnabled = true
        }</span>

        // Check Referrer-Policy
        <span class="cov1" title="1">if rp := c.Writer.Header().Get("Referrer-Policy"); rp != "" </span><span class="cov1" title="1">{
                info.ReferrerPolicyEnabled = true
                info.ReferrerPolicy = rp
        }</span>

        // Check Permissions-Policy
        <span class="cov1" title="1">if pp := c.Writer.Header().Get("Permissions-Policy"); pp != "" </span><span class="cov1" title="1">{
                info.PermissionsPolicyEnabled = true
        }</span>

        // Check Expect-CT
        <span class="cov1" title="1">if ect := c.Writer.Header().Get("Expect-CT"); ect != "" </span><span class="cov0" title="0">{
                info.ExpectCTEnabled = true
        }</span>

        // Check Cross-Origin policies
        <span class="cov1" title="1">if corp := c.Writer.Header().Get("Cross-Origin-Resource-Policy"); corp != "" </span><span class="cov1" title="1">{
                info.CORPEnabled = true
        }</span>
        <span class="cov1" title="1">if coep := c.Writer.Header().Get("Cross-Origin-Embedder-Policy"); coep != "" </span><span class="cov1" title="1">{
                info.COEPEnabled = true
        }</span>
        <span class="cov1" title="1">if coop := c.Writer.Header().Get("Cross-Origin-Opener-Policy"); coop != "" </span><span class="cov1" title="1">{
                info.COOPEnabled = true
        }</span>

        // Check if identifying headers are removed
        <span class="cov1" title="1">if server := c.Writer.Header().Get("Server"); server == "" </span><span class="cov1" title="1">{
                info.ServerHeaderRemoved = true
        }</span>
        <span class="cov1" title="1">if poweredBy := c.Writer.Header().Get("X-Powered-By"); poweredBy == "" </span><span class="cov1" title="1">{
                info.PoweredByHeaderRemoved = true
        }</span>

        <span class="cov1" title="1">return info</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package security

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "time"

        "helixtrack.ru/core/internal/models"
)

// ServiceSigner handles cryptographic signing and verification of services
type ServiceSigner struct {
        privateKey *rsa.PrivateKey
        publicKey  *rsa.PublicKey
}

// NewServiceSigner creates a new service signer with generated keys
func NewServiceSigner() (*ServiceSigner, error) <span class="cov8" title="7">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }</span>

        <span class="cov8" title="7">return &amp;ServiceSigner{
                privateKey: privateKey,
                publicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// NewServiceSignerFromPrivateKey creates a signer from an existing private key
func NewServiceSignerFromPrivateKey(privateKeyPEM string) (*ServiceSigner, error) <span class="cov0" title="0">{
        block, _ := pem.Decode([]byte(privateKeyPEM))
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode PEM block containing private key")
        }</span>

        <span class="cov0" title="0">privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse private key: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ServiceSigner{
                privateKey: privateKey,
                publicKey:  &amp;privateKey.PublicKey,
        }, nil</span>
}

// SignServiceRegistration signs a service registration with the private key
func (s *ServiceSigner) SignServiceRegistration(service *models.ServiceRegistration) error <span class="cov8" title="9">{
        // Get the public key in PEM format
        publicKeyPEM, err := s.GetPublicKeyPEM()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get public key: %w", err)
        }</span>
        <span class="cov8" title="9">service.PublicKey = publicKeyPEM

        // Compute the data to sign
        data := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%d",
                service.ID,
                service.Name,
                service.Type,
                service.Version,
                service.URL,
                service.PublicKey,
                service.RegisteredAt.Unix(),
        )

        // Hash the data
        hashed := sha256.Sum256([]byte(data))

        // Sign the hash
        signature, err := rsa.SignPKCS1v15(rand.Reader, s.privateKey, crypto.SHA256, hashed[:])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sign service registration: %w", err)
        }</span>

        // Encode signature as base64
        <span class="cov8" title="9">service.Signature = base64.StdEncoding.EncodeToString(signature)

        return nil</span>
}

// VerifyServiceRegistration verifies the signature of a service registration
func (s *ServiceSigner) VerifyServiceRegistration(service *models.ServiceRegistration) error <span class="cov10" title="12">{
        // Decode the signature
        signature, err := base64.StdEncoding.DecodeString(service.Signature)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("failed to decode signature: %w", err)
        }</span>

        // Parse the public key from the service
        <span class="cov9" title="10">publicKey, err := ParsePublicKey(service.PublicKey)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        // Compute the data that was signed
        <span class="cov8" title="9">data := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%d",
                service.ID,
                service.Name,
                service.Type,
                service.Version,
                service.URL,
                service.PublicKey,
                service.RegisteredAt.Unix(),
        )

        // Hash the data
        hashed := sha256.Sum256([]byte(data))

        // Verify the signature
        err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hashed[:], signature)
        if err != nil </span><span class="cov3" title="2">{
                return fmt.Errorf("signature verification failed: %w", err)
        }</span>

        <span class="cov8" title="7">return nil</span>
}

// VerifyServiceRotation verifies that a service rotation request is legitimate
func (s *ServiceSigner) VerifyServiceRotation(
        oldService *models.ServiceRegistration,
        newService *models.ServiceRegistration,
        adminToken string,
) error <span class="cov8" title="8">{
        // 1. Verify old service is not already rotating or decommissioned
        if !oldService.CanRotate() </span><span class="cov3" title="2">{
                return fmt.Errorf("service cannot be rotated in current status: %s", oldService.Status)
        }</span>

        // 2. Verify new service signature
        <span class="cov7" title="6">if err := s.VerifyServiceRegistration(newService); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("new service signature invalid: %w", err)
        }</span>

        // 3. Verify admin token (implementation depends on your admin auth system)
        <span class="cov6" title="5">if !s.verifyAdminToken(adminToken) </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid admin token")
        }</span>

        // 4. Verify service types match
        <span class="cov6" title="4">if oldService.Type != newService.Type </span><span class="cov1" title="1">{
                return fmt.Errorf("service type mismatch: old=%s, new=%s", oldService.Type, newService.Type)
        }</span>

        // 5. Verify new service is healthy (should be checked before calling this)
        <span class="cov4" title="3">if !newService.IsHealthy() </span><span class="cov1" title="1">{
                return fmt.Errorf("new service is not healthy")
        }</span>

        // 6. Verify time-based constraints (prevent rapid rotations)
        <span class="cov3" title="2">if time.Since(oldService.RegisteredAt) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                return fmt.Errorf("service was registered too recently for rotation")
        }</span>

        // 7. Verify new service has been registered long enough
        <span class="cov3" title="2">if time.Since(newService.RegisteredAt) &lt; 5*time.Minute </span><span class="cov1" title="1">{
                return fmt.Errorf("new service must be registered for at least 5 minutes before rotation")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// verifyAdminToken verifies an admin authorization token
func (s *ServiceSigner) verifyAdminToken(token string) bool <span class="cov6" title="5">{
        // In a real implementation, this would verify against a secure token store
        // For now, we'll use a simple check
        if token == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Hash the token and compare with expected values
        <span class="cov6" title="5">hash := sha256.Sum256([]byte(token))
        hashStr := base64.StdEncoding.EncodeToString(hash[:])

        // This should be replaced with actual token verification
        // For production, integrate with the JWT service or a dedicated admin auth system
        _ = hashStr

        // For development/testing, accept non-empty tokens
        // TODO: Implement proper admin token verification
        return len(token) &gt;= 32</span>
}

// GetPublicKeyPEM returns the public key in PEM format
func (s *ServiceSigner) GetPublicKeyPEM() (string, error) <span class="cov9" title="11">{
        publicKeyBytes, err := x509.MarshalPKIXPublicKey(s.publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov9" title="11">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyBytes,
        })

        return string(publicKeyPEM), nil</span>
}

// GetPrivateKeyPEM returns the private key in PEM format
func (s *ServiceSigner) GetPrivateKeyPEM() string <span class="cov1" title="1">{
        privateKeyBytes := x509.MarshalPKCS1PrivateKey(s.privateKey)
        privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyBytes,
        })

        return string(privateKeyPEM)
}</span>

// ParsePublicKey parses a PEM-encoded public key
func ParsePublicKey(publicKeyPEM string) (*rsa.PublicKey, error) <span class="cov9" title="10">{
        block, _ := pem.Decode([]byte(publicKeyPEM))
        if block == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decode PEM block containing public key")
        }</span>

        <span class="cov8" title="9">publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        <span class="cov8" title="9">rsaPublicKey, ok := publicKey.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not an RSA public key")
        }</span>

        <span class="cov8" title="9">return rsaPublicKey, nil</span>
}

// GenerateAdminToken generates a secure admin token for service operations
func GenerateAdminToken(username string, secret string) string <span class="cov6" title="5">{
        // Combine username, secret, and timestamp
        data := fmt.Sprintf("%s|%s|%d", username, secret, time.Now().Unix())
        hash := sha256.Sum256([]byte(data))
        return base64.StdEncoding.EncodeToString(hash[:])
}</span>

// VerifyRotationCode verifies a rotation verification code
func VerifyRotationCode(serviceID string, code string, secret string) bool <span class="cov3" title="2">{
        // Generate expected code
        expected := GenerateRotationCode(serviceID, secret)
        return code == expected
}</span>

// GenerateRotationCode generates a verification code for service rotation
func GenerateRotationCode(serviceID string, secret string) string <span class="cov8" title="8">{
        // Combine service ID, secret, and current hour (time-based code)
        hour := time.Now().UTC().Hour()
        data := fmt.Sprintf("%s|%s|%d", serviceID, secret, hour)
        hash := sha256.Sum256([]byte(data))
        return base64.StdEncoding.EncodeToString(hash[:])[:16] // First 16 characters
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package security

import (
        "crypto/tls"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
)

// TLSConfig contains TLS/SSL enforcement configuration
type TLSConfig struct {
        // TLS version enforcement
        MinTLSVersion uint16 // Minimum TLS version (default: tls.VersionTLS12)
        MaxTLSVersion uint16 // Maximum TLS version (default: tls.VersionTLS13)

        // Cipher suites
        CipherSuites  []uint16 // Allowed cipher suites
        PreferServerCipherSuites bool // Prefer server cipher suites

        // Certificate configuration
        CertFile      string // Path to certificate file
        KeyFile       string // Path to private key file
        ClientCAFile  string // Path to client CA file (for mutual TLS)

        // Client authentication
        ClientAuth    tls.ClientAuthType // Client authentication mode

        // HTTPS enforcement
        EnforceHTTPS  bool // Redirect HTTP to HTTPS
        HTTPSPort     int  // HTTPS port (default: 443)

        // HSTS
        EnableHSTS    bool // Enable HTTP Strict Transport Security
        HSTSMaxAge    int  // HSTS max age in seconds

        // Certificate verification
        InsecureSkipVerify bool // Skip certificate verification (NOT RECOMMENDED)

        // Session tickets
        SessionTicketsDisabled bool // Disable session tickets

        // Renegotiation
        Renegotiation tls.RenegotiationSupport // Renegotiation support
}

// DefaultTLSConfig returns secure default TLS settings
func DefaultTLSConfig() TLSConfig <span class="cov4" title="9">{
        return TLSConfig{
                MinTLSVersion:            tls.VersionTLS12,
                MaxTLSVersion:            tls.VersionTLS13,
                CipherSuites:             getSecureCipherSuites(),
                PreferServerCipherSuites: true,
                ClientAuth:               tls.NoClientCert,
                EnforceHTTPS:             true,
                HTTPSPort:                443,
                EnableHSTS:               true,
                HSTSMaxAge:               31536000, // 1 year
                InsecureSkipVerify:       false,
                SessionTicketsDisabled:   false,
                Renegotiation:            tls.RenegotiateNever,
        }
}</span>

// StrictTLSConfig returns very strict TLS settings
func StrictTLSConfig() TLSConfig <span class="cov1" title="1">{
        cfg := DefaultTLSConfig()
        cfg.MinTLSVersion = tls.VersionTLS13 // TLS 1.3 only
        cfg.CipherSuites = getTLS13CipherSuites()
        cfg.SessionTicketsDisabled = true
        cfg.ClientAuth = tls.RequireAndVerifyClientCert // Mutual TLS
        return cfg
}</span>

// getSecureCipherSuites returns recommended cipher suites for TLS 1.2
func getSecureCipherSuites() []uint16 <span class="cov5" title="11">{
        return []uint16{
                // TLS 1.3 cipher suites (always enabled in TLS 1.3)
                tls.TLS_AES_128_GCM_SHA256,
                tls.TLS_AES_256_GCM_SHA384,
                tls.TLS_CHACHA20_POLY1305_SHA256,

                // TLS 1.2 cipher suites (recommended)
                tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
                tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
                tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
                tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
        }
}</span>

// getTLS13CipherSuites returns TLS 1.3 cipher suites
func getTLS13CipherSuites() []uint16 <span class="cov1" title="1">{
        return []uint16{
                tls.TLS_AES_128_GCM_SHA256,
                tls.TLS_AES_256_GCM_SHA384,
                tls.TLS_CHACHA20_POLY1305_SHA256,
        }
}</span>

// GetWeakCipherSuites returns a list of weak cipher suites to avoid
func GetWeakCipherSuites() []uint16 <span class="cov2" title="3">{
        return []uint16{
                tls.TLS_RSA_WITH_RC4_128_SHA,
                tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
                tls.TLS_RSA_WITH_AES_128_CBC_SHA,
                tls.TLS_RSA_WITH_AES_256_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
                tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
                tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
                tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
                tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
                tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
        }
}</span>

// CreateTLSConfig creates a *tls.Config from TLSConfig
func CreateTLSConfig(cfg TLSConfig) *tls.Config <span class="cov1" title="1">{
        return &amp;tls.Config{
                MinVersion:               cfg.MinTLSVersion,
                MaxVersion:               cfg.MaxTLSVersion,
                CipherSuites:             cfg.CipherSuites,
                PreferServerCipherSuites: cfg.PreferServerCipherSuites,
                ClientAuth:               cfg.ClientAuth,
                InsecureSkipVerify:       cfg.InsecureSkipVerify,
                SessionTicketsDisabled:   cfg.SessionTicketsDisabled,
                Renegotiation:            cfg.Renegotiation,
        }
}</span>

// TLSEnforcementMiddleware enforces TLS/SSL requirements
func TLSEnforcementMiddleware(cfg TLSConfig) gin.HandlerFunc <span class="cov3" title="4">{
        return func(c *gin.Context) </span><span class="cov3" title="4">{
                // Check if connection is TLS
                if c.Request.TLS == nil </span><span class="cov1" title="1">{
                        // Not using TLS
                        if cfg.EnforceHTTPS </span><span class="cov1" title="1">{
                                // Redirect to HTTPS
                                host := c.Request.Host
                                if cfg.HTTPSPort != 443 </span><span class="cov0" title="0">{
                                        host = fmt.Sprintf("%s:%d", c.Request.Host, cfg.HTTPSPort)
                                }</span>

                                <span class="cov1" title="1">target := fmt.Sprintf("https://%s%s", host, c.Request.RequestURI)
                                LogSecurityEvent("HTTP_TO_HTTPS_REDIRECT", c.ClientIP(),
                                        fmt.Sprintf("Redirecting to %s", target))

                                c.Redirect(http.StatusMovedPermanently, target)
                                c.Abort()
                                return</span>
                        } else<span class="cov0" title="0"> {
                                // Just log warning
                                LogSecurityEvent("INSECURE_CONNECTION", c.ClientIP(),
                                        "Request received over HTTP instead of HTTPS")
                        }</span>
                } else<span class="cov2" title="3"> {
                        // Using TLS, verify version and cipher suite
                        if c.Request.TLS.Version &lt; cfg.MinTLSVersion </span><span class="cov1" title="1">{
                                LogSecurityEvent("TLS_VERSION_TOO_LOW", c.ClientIP(),
                                        fmt.Sprintf("TLS version %d is below minimum %d",
                                                c.Request.TLS.Version, cfg.MinTLSVersion))

                                c.JSON(http.StatusBadRequest, gin.H{
                                        "error": "TLS version too low",
                                })
                                c.Abort()
                                return
                        }</span>

                        <span class="cov2" title="2">if cfg.MaxTLSVersion &gt; 0 &amp;&amp; c.Request.TLS.Version &gt; cfg.MaxTLSVersion </span><span class="cov0" title="0">{
                                LogSecurityEvent("TLS_VERSION_TOO_HIGH", c.ClientIP(),
                                        fmt.Sprintf("TLS version %d is above maximum %d",
                                                c.Request.TLS.Version, cfg.MaxTLSVersion))

                                c.JSON(http.StatusBadRequest, gin.H{
                                        "error": "TLS version not supported",
                                })
                                c.Abort()
                                return
                        }</span>

                        // Check cipher suite
                        <span class="cov2" title="2">if len(cfg.CipherSuites) &gt; 0 </span><span class="cov2" title="2">{
                                cipherAllowed := false
                                for _, allowed := range cfg.CipherSuites </span><span class="cov4" title="10">{
                                        if c.Request.TLS.CipherSuite == allowed </span><span class="cov1" title="1">{
                                                cipherAllowed = true
                                                break</span>
                                        }
                                }

                                <span class="cov2" title="2">if !cipherAllowed </span><span class="cov1" title="1">{
                                        LogSecurityEvent("WEAK_CIPHER_SUITE", c.ClientIP(),
                                                fmt.Sprintf("Cipher suite 0x%04X not allowed",
                                                        c.Request.TLS.CipherSuite))

                                        c.JSON(http.StatusBadRequest, gin.H{
                                                "error": "Cipher suite not allowed",
                                        })
                                        c.Abort()
                                        return
                                }</span>
                        }

                        // Add HSTS header if enabled
                        <span class="cov1" title="1">if cfg.EnableHSTS </span><span class="cov1" title="1">{
                                hsts := fmt.Sprintf("max-age=%d; includeSubDomains; preload", cfg.HSTSMaxAge)
                                c.Header("Strict-Transport-Security", hsts)
                        }</span>
                }

                <span class="cov1" title="1">c.Next()</span>
        }
}

// MutualTLSMiddleware enforces mutual TLS (client certificate authentication)
func MutualTLSMiddleware() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                if c.Request.TLS == nil </span><span class="cov0" title="0">{
                        LogSecurityEvent("MTLS_NO_TLS", c.ClientIP(), "Mutual TLS required but no TLS connection")
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "TLS required",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov1" title="1">if len(c.Request.TLS.PeerCertificates) == 0 </span><span class="cov1" title="1">{
                        LogSecurityEvent("MTLS_NO_CLIENT_CERT", c.ClientIP(),
                                "Mutual TLS required but no client certificate provided")

                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Client certificate required",
                        })
                        c.Abort()
                        return
                }</span>

                // Get client certificate
                <span class="cov0" title="0">clientCert := c.Request.TLS.PeerCertificates[0]

                // Verify certificate is not expired
                if clientCert.NotAfter.Before(c.Request.TLS.PeerCertificates[0].NotBefore) </span><span class="cov0" title="0">{
                        LogSecurityEvent("MTLS_CERT_EXPIRED", c.ClientIP(),
                                fmt.Sprintf("Client certificate expired: %s", clientCert.Subject.CommonName))

                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Client certificate expired",
                        })
                        c.Abort()
                        return
                }</span>

                // Store client certificate info in context
                <span class="cov0" title="0">c.Set("client_cert_subject", clientCert.Subject.CommonName)
                c.Set("client_cert_issuer", clientCert.Issuer.CommonName)
                c.Set("client_cert", clientCert)

                LogSecurityEvent("MTLS_SUCCESS", c.ClientIP(),
                        fmt.Sprintf("Mutual TLS authentication successful for %s", clientCert.Subject.CommonName))

                c.Next()</span>
        }
}

// TLSVersionInfo contains information about TLS connection
type TLSVersionInfo struct {
        Version              string   `json:"version"`
        VersionNumber        uint16   `json:"version_number"`
        CipherSuite          string   `json:"cipher_suite"`
        CipherSuiteNumber    uint16   `json:"cipher_suite_number"`
        ServerName           string   `json:"server_name"`
        NegotiatedProtocol   string   `json:"negotiated_protocol"`
        HandshakeComplete    bool     `json:"handshake_complete"`
        ClientCertPresent    bool     `json:"client_cert_present"`
        ClientCertSubject    string   `json:"client_cert_subject,omitempty"`
}

// GetTLSVersionInfo extracts TLS connection information
func GetTLSVersionInfo(c *gin.Context) *TLSVersionInfo <span class="cov2" title="3">{
        if c.Request.TLS == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="2">info := &amp;TLSVersionInfo{
                Version:            getTLSVersionName(c.Request.TLS.Version),
                VersionNumber:      c.Request.TLS.Version,
                CipherSuite:        getCipherSuiteName(c.Request.TLS.CipherSuite),
                CipherSuiteNumber:  c.Request.TLS.CipherSuite,
                ServerName:         c.Request.TLS.ServerName,
                NegotiatedProtocol: c.Request.TLS.NegotiatedProtocol,
                HandshakeComplete:  c.Request.TLS.HandshakeComplete,
                ClientCertPresent:  len(c.Request.TLS.PeerCertificates) &gt; 0,
        }

        if info.ClientCertPresent </span><span class="cov0" title="0">{
                info.ClientCertSubject = c.Request.TLS.PeerCertificates[0].Subject.CommonName
        }</span>

        <span class="cov2" title="2">return info</span>
}

// getTLSVersionName returns the name of a TLS version
func getTLSVersionName(version uint16) string <span class="cov4" title="7">{
        switch version </span>{
        case tls.VersionTLS10:<span class="cov1" title="1">
                return "TLS 1.0"</span>
        case tls.VersionTLS11:<span class="cov1" title="1">
                return "TLS 1.1"</span>
        case tls.VersionTLS12:<span class="cov1" title="1">
                return "TLS 1.2"</span>
        case tls.VersionTLS13:<span class="cov2" title="3">
                return "TLS 1.3"</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("Unknown (0x%04X)", version)</span>
        }
}

// getCipherSuiteName returns the name of a cipher suite
func getCipherSuiteName(suite uint16) string <span class="cov4" title="7">{
        // TLS 1.3 cipher suites
        switch suite </span>{
        case tls.TLS_AES_128_GCM_SHA256:<span class="cov2" title="3">
                return "TLS_AES_128_GCM_SHA256"</span>
        case tls.TLS_AES_256_GCM_SHA384:<span class="cov1" title="1">
                return "TLS_AES_256_GCM_SHA384"</span>
        case tls.TLS_CHACHA20_POLY1305_SHA256:<span class="cov1" title="1">
                return "TLS_CHACHA20_POLY1305_SHA256"</span>

        // TLS 1.2 cipher suites
        case tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:<span class="cov1" title="1">
                return "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"</span>
        case tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:<span class="cov0" title="0">
                return "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"</span>
        case tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"</span>
        case tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:<span class="cov0" title="0">
                return "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"</span>
        case tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"</span>
        case tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"</span>

        // Weak cipher suites
        case tls.TLS_RSA_WITH_RC4_128_SHA:<span class="cov1" title="1">
                return "TLS_RSA_WITH_RC4_128_SHA (WEAK)"</span>
        case tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA:<span class="cov0" title="0">
                return "TLS_RSA_WITH_3DES_EDE_CBC_SHA (WEAK)"</span>
        case tls.TLS_RSA_WITH_AES_128_CBC_SHA:<span class="cov0" title="0">
                return "TLS_RSA_WITH_AES_128_CBC_SHA (WEAK)"</span>
        case tls.TLS_RSA_WITH_AES_256_CBC_SHA:<span class="cov0" title="0">
                return "TLS_RSA_WITH_AES_256_CBC_SHA (WEAK)"</span>

        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown (0x%04X)", suite)</span>
        }
}

// ValidateTLSConfig validates a TLS configuration
func ValidateTLSConfig(cfg TLSConfig) []string <span class="cov2" title="2">{
        var issues []string

        // Check TLS version
        if cfg.MinTLSVersion &lt; tls.VersionTLS12 </span><span class="cov1" title="1">{
                issues = append(issues, "Minimum TLS version is below TLS 1.2 (insecure)")
        }</span>

        // Check if HTTPS is enforced
        <span class="cov2" title="2">if !cfg.EnforceHTTPS </span><span class="cov0" title="0">{
                issues = append(issues, "HTTPS enforcement is disabled")
        }</span>

        // Check HSTS
        <span class="cov2" title="2">if !cfg.EnableHSTS </span><span class="cov1" title="1">{
                issues = append(issues, "HSTS is disabled")
        }</span> else<span class="cov1" title="1"> if cfg.HSTSMaxAge &lt; 31536000 </span><span class="cov0" title="0">{
                issues = append(issues, "HSTS max-age is less than 1 year")
        }</span>

        // Check certificate verification
        <span class="cov2" title="2">if cfg.InsecureSkipVerify </span><span class="cov1" title="1">{
                issues = append(issues, "Certificate verification is disabled (CRITICAL SECURITY ISSUE)")
        }</span>

        // Check for weak cipher suites
        <span class="cov2" title="2">weakCiphers := GetWeakCipherSuites()
        for _, configured := range cfg.CipherSuites </span><span class="cov5" title="18">{
                for _, weak := range weakCiphers </span><span class="cov10" title="198">{
                        if configured == weak </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("Weak cipher suite enabled: %s",
                                        getCipherSuiteName(configured)))
                        }</span>
                }
        }

        <span class="cov2" title="2">return issues</span>
}

// TLSAuditMiddleware logs TLS connection details for audit
func TLSAuditMiddleware() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                if c.Request.TLS != nil </span><span class="cov1" title="1">{
                        info := GetTLSVersionInfo(c)
                        LogSecurityEvent("TLS_CONNECTION", c.ClientIP(),
                                fmt.Sprintf("TLS %s with %s", info.Version, info.CipherSuite))
                }</span> else<span class="cov0" title="0"> {
                        LogSecurityEvent("INSECURE_HTTP_CONNECTION", c.ClientIP(),
                                "Request received over insecure HTTP")
                }</span>

                <span class="cov1" title="1">c.Next()</span>
        }
}

// RequireHTTPSMiddleware strictly requires HTTPS (aborts non-HTTPS requests)
func RequireHTTPSMiddleware() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                if c.Request.TLS == nil </span><span class="cov1" title="1">{
                        LogSecurityEvent("HTTPS_REQUIRED", c.ClientIP(),
                                "HTTPS required but request was HTTP")

                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "HTTPS required",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov1" title="1">c.Next()</span>
        }
}

// TLSStatistics contains TLS usage statistics
type TLSStatistics struct {
        TotalTLSConnections    int            `json:"total_tls_connections"`
        TotalHTTPConnections   int            `json:"total_http_connections"`
        TLSVersions            map[string]int `json:"tls_versions"`
        CipherSuites           map[string]int `json:"cipher_suites"`
        ClientCertConnections  int            `json:"client_cert_connections"`
        WeakCipherDetections   int            `json:"weak_cipher_detections"`
}

// Global TLS statistics (would need to be implemented with proper tracking)
var tlsStats = &amp;TLSStatistics{
        TLSVersions:  make(map[string]int),
        CipherSuites: make(map[string]int),
}

// GetTLSStatistics returns TLS statistics
func GetTLSStatistics() *TLSStatistics <span class="cov0" title="0">{
        return tlsStats
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package server

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/config"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/handlers"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
        "helixtrack.ru/core/internal/websocket"
)

// Server represents the HTTP server
type Server struct {
        config                    *config.Config
        router                    *gin.Engine
        httpServer                *http.Server
        db                        database.Database
        authService               services.AuthService
        permService               services.PermissionService
        serviceDiscoveryHandler   *handlers.ServiceDiscoveryHandler
        wsManager                 *websocket.Manager
        wsPublisher               websocket.EventPublisher
        wsHandler                 *websocket.Handler
}

// NewServer creates a new server instance
func NewServer(cfg *config.Config) (*Server, error) <span class="cov10" title="8">{
        // Initialize database
        db, err := database.NewDatabase(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database: %w", err)
        }</span>

        // Initialize services
        <span class="cov10" title="8">authService := services.NewAuthService(
                cfg.Services.Authentication.URL,
                cfg.Services.Authentication.Timeout,
                cfg.Services.Authentication.Enabled,
        )

        permService := services.NewPermissionService(
                cfg.Services.Permissions.URL,
                cfg.Services.Permissions.Timeout,
                cfg.Services.Permissions.Enabled,
        )

        // Initialize service discovery handler
        serviceDiscoveryHandler, err := handlers.NewServiceDiscoveryHandler(db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize service discovery handler: %w", err)
        }</span>

        // Initialize WebSocket manager and publisher
        <span class="cov10" title="8">var wsManager *websocket.Manager
        var wsPublisher websocket.EventPublisher
        var wsHandler *websocket.Handler

        if cfg.IsWebSocketEnabled() </span><span class="cov0" title="0">{
                wsConfig := websocket.ConfigToModel(cfg.GetWebSocketConfig())
                wsManager = websocket.NewManager(wsConfig, permService)
                wsPublisher = websocket.NewPublisher(wsManager, true)
                wsHandler = websocket.NewHandler(wsManager, authService, wsConfig)

                logger.Info("WebSocket enabled",
                        zap.String("path", wsConfig.Path),
                        zap.Int("maxClients", wsConfig.MaxClients),
                )
        }</span> else<span class="cov10" title="8"> {
                wsPublisher = websocket.NewNoOpPublisher()
                logger.Info("WebSocket disabled")
        }</span>

        <span class="cov10" title="8">server := &amp;Server{
                config:                  cfg,
                db:                      db,
                authService:             authService,
                permService:             permService,
                serviceDiscoveryHandler: serviceDiscoveryHandler,
                wsManager:               wsManager,
                wsPublisher:             wsPublisher,
                wsHandler:               wsHandler,
        }

        server.setupRouter()

        return server, nil</span>
}

// setupRouter configures the Gin router with all routes and middleware
func (s *Server) setupRouter() <span class="cov10" title="8">{
        // Set Gin mode based on configuration
        gin.SetMode(gin.ReleaseMode)

        router := gin.New()

        // Add middleware
        router.Use(gin.Recovery())
        router.Use(s.loggingMiddleware())
        router.Use(s.corsMiddleware())

        // Initialize users table
        if err := handlers.InitializeUserTable(s.db); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize users table", zap.Error(err))
        }</span>

        // Initialize project, ticket, and comment tables
        <span class="cov10" title="8">if err := handlers.InitializeProjectTables(s.db); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize project tables", zap.Error(err))
        }</span>

        // Initialize service discovery tables
        <span class="cov10" title="8">if err := handlers.InitializeServiceDiscoveryTables(s.db); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize service discovery tables", zap.Error(err))
        }</span>

        // Start service health checker
        <span class="cov10" title="8">if err := s.serviceDiscoveryHandler.StartHealthChecker(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start health checker", zap.Error(err))
        }</span> else<span class="cov10" title="8"> {
                logger.Info("Service health checker started")
        }</span>

        // Create handlers
        <span class="cov10" title="8">handler := handlers.NewHandler(s.db, s.authService, s.permService, s.config.Version)
        handler.SetEventPublisher(s.wsPublisher) // Set event publisher for WebSocket events
        authHandler := handlers.NewAuthHandler(s.db)

        // WebSocket routes (if enabled)
        if s.config.IsWebSocketEnabled() &amp;&amp; s.wsHandler != nil </span><span class="cov0" title="0">{
                wsPath := s.config.WebSocket.Path
                router.GET(wsPath, s.wsHandler.HandleConnection)
                router.GET(wsPath+"/stats", s.wsHandler.HandleStats)
                logger.Info("WebSocket routes registered",
                        zap.String("path", wsPath),
                        zap.String("statsPath", wsPath+"/stats"),
                )
        }</span>

        // Authentication routes (public)
        <span class="cov10" title="8">auth := router.Group("/api/auth")
        </span><span class="cov10" title="8">{
                auth.POST("/register", authHandler.Register)
                auth.POST("/login", authHandler.Login)
                auth.POST("/logout", authHandler.Logout)
        }</span>

        // Service discovery routes (admin only)
        <span class="cov10" title="8">serviceDiscovery := router.Group("/api/services")
        </span><span class="cov10" title="8">{
                serviceDiscovery.POST("/register", s.serviceDiscoveryHandler.RegisterService)
                serviceDiscovery.POST("/discover", s.serviceDiscoveryHandler.DiscoverServices)
                serviceDiscovery.POST("/rotate", s.serviceDiscoveryHandler.RotateService)
                serviceDiscovery.POST("/decommission", s.serviceDiscoveryHandler.DecommissionService)
                serviceDiscovery.POST("/update", s.serviceDiscoveryHandler.UpdateService)
                serviceDiscovery.GET("/list", s.serviceDiscoveryHandler.ListServices)
                serviceDiscovery.GET("/health/:id", s.serviceDiscoveryHandler.GetServiceHealth)
        }</span>

        // Public routes (no JWT required)
        <span class="cov10" title="8">router.POST("/do", func(c *gin.Context) </span><span class="cov5" title="3">{
                // Log raw request body for debugging
                bodyBytes, _ := c.GetRawData()
                logger.Info("Received /do request", zap.String("body", string(bodyBytes)))

                // Restore body for binding
                c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

                // Parse request to check if authentication is required
                var req models.Request
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        logger.Error("Failed to bind JSON request",
                                zap.Error(err),
                                zap.String("error_details", err.Error()),
                                zap.String("body", string(bodyBytes)))
                        c.JSON(http.StatusBadRequest, models.NewErrorResponse(
                                models.ErrorCodeInvalidRequest,
                                fmt.Sprintf("Invalid request format: %v", err),
                                "",
                        ))
                        return
                }</span>

                <span class="cov4" title="2">logger.Info("Successfully parsed request", zap.String("action", req.Action))

                // If authentication is required, validate JWT
                if req.IsAuthenticationRequired() </span><span class="cov1" title="1">{
                        // Extract JWT from Authorization header or request body
                        var jwtToken string

                        // Check Authorization header first (format: "Bearer &lt;token&gt;")
                        authHeader := c.GetHeader("Authorization")
                        if authHeader != "" </span><span class="cov0" title="0">{
                                // Extract token from "Bearer &lt;token&gt;" format
                                if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                                        jwtToken = authHeader[7:]
                                }</span>
                        }

                        // Fall back to JWT field in request body
                        <span class="cov1" title="1">if jwtToken == "" </span><span class="cov1" title="1">{
                                jwtToken = req.JWT
                        }</span>

                        // Check if JWT is present
                        <span class="cov1" title="1">if jwtToken == "" </span><span class="cov1" title="1">{
                                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                        models.ErrorCodeMissingJWT,
                                        "JWT token is required for this action",
                                        "",
                                ))
                                return
                        }</span>

                        // Create JWT middleware and validate
                        <span class="cov0" title="0">jwtMiddleware := middleware.NewJWTMiddleware(s.authService, "")
                        claims, err := jwtMiddleware.ValidateToken(c.Request.Context(), jwtToken)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                        models.ErrorCodeInvalidJWT,
                                        "Invalid or expired JWT token",
                                        "",
                                ))
                                return
                        }</span>

                        // Store claims in context
                        <span class="cov0" title="0">c.Set("claims", claims)
                        c.Set("username", claims.Username)</span>
                }

                // Restore request body for handler
                <span class="cov1" title="1">c.Set("request", &amp;req)

                // Call handler
                handler.DoAction(c)</span>
        })

        // Health check endpoint
        <span class="cov10" title="8">router.GET("/health", func(c *gin.Context) </span><span class="cov1" title="1">{
                c.JSON(http.StatusOK, gin.H{
                        "status": "ok",
                })
        }</span>)

        <span class="cov10" title="8">s.router = router</span>
}

// loggingMiddleware logs HTTP requests
func (s *Server) loggingMiddleware() gin.HandlerFunc <span class="cov10" title="8">{
        return func(c *gin.Context) </span><span class="cov7" title="5">{
                start := time.Now()
                path := c.Request.URL.Path

                c.Next()

                latency := time.Since(start)
                statusCode := c.Writer.Status()

                logger.Info("HTTP Request",
                        zap.String("method", c.Request.Method),
                        zap.String("path", path),
                        zap.Int("status", statusCode),
                        zap.Duration("latency", latency),
                        zap.String("client_ip", c.ClientIP()),
                )
        }</span>
}

// corsMiddleware adds CORS headers
func (s *Server) corsMiddleware() gin.HandlerFunc <span class="cov10" title="8">{
        return func(c *gin.Context) </span><span class="cov7" title="5">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov1" title="1">{
                        c.AbortWithStatus(http.StatusOK)
                        return
                }</span>

                <span class="cov7" title="4">c.Next()</span>
        }
}

// Start starts the HTTP server
func (s *Server) Start() error <span class="cov0" title="0">{
        // Start WebSocket manager if enabled
        if s.wsManager != nil </span><span class="cov0" title="0">{
                if err := s.wsManager.Start(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start WebSocket manager: %w", err)
                }</span>
                <span class="cov0" title="0">logger.Info("WebSocket manager started")</span>
        }

        <span class="cov0" title="0">addr := s.config.GetListenerAddress()

        s.httpServer = &amp;http.Server{
                Addr:         addr,
                Handler:      s.router,
                ReadTimeout:  30 * time.Second,
                WriteTimeout: 30 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        logger.Info("Starting HTTP server", zap.String("address", addr))

        listener := s.config.GetPrimaryListener()
        if listener != nil &amp;&amp; listener.HTTPS </span><span class="cov0" title="0">{
                logger.Info("Starting HTTPS server",
                        zap.String("cert", listener.CertFile),
                        zap.String("key", listener.KeyFile),
                )
                return s.httpServer.ListenAndServeTLS(listener.CertFile, listener.KeyFile)
        }</span>

        <span class="cov0" title="0">return s.httpServer.ListenAndServe()</span>
}

// Shutdown gracefully shuts down the server
func (s *Server) Shutdown(ctx context.Context) error <span class="cov1" title="1">{
        logger.Info("Shutting down server...")

        // Stop WebSocket manager
        if s.wsManager != nil </span><span class="cov0" title="0">{
                logger.Info("Stopping WebSocket manager...")
                if err := s.wsManager.Stop(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error stopping WebSocket manager", zap.Error(err))
                }</span>
        }

        // Stop health checker
        <span class="cov1" title="1">if s.serviceDiscoveryHandler != nil </span><span class="cov1" title="1">{
                logger.Info("Stopping service health checker...")
                s.serviceDiscoveryHandler.StopHealthChecker()
        }</span>

        <span class="cov1" title="1">if s.httpServer != nil </span><span class="cov0" title="0">{
                if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error shutting down HTTP server", zap.Error(err))
                        return err
                }</span>
        }

        <span class="cov1" title="1">if s.db != nil </span><span class="cov1" title="1">{
                if err := s.db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing database", zap.Error(err))
                        return err
                }</span>
        }

        <span class="cov1" title="1">logger.Info("Server shutdown complete")
        return nil</span>
}

// GetRouter returns the Gin router (useful for testing)
func (s *Server) GetRouter() *gin.Engine <span class="cov1" title="1">{
        return s.router
}</span>

// GetEventPublisher returns the WebSocket event publisher
func (s *Server) GetEventPublisher() websocket.EventPublisher <span class="cov0" title="0">{
        return s.wsPublisher
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package services

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "helixtrack.ru/core/internal/models"
)

// AuthService defines the interface for authentication operations
type AuthService interface {
        // Authenticate validates credentials and returns a JWT token
        Authenticate(ctx context.Context, username, password string) (*models.JWTClaims, error)

        // ValidateToken validates a JWT token and returns the claims
        ValidateToken(ctx context.Context, token string) (*models.JWTClaims, error)

        // IsEnabled returns whether the authentication service is enabled
        IsEnabled() bool
}

// httpAuthService is the HTTP-based implementation of AuthService
type httpAuthService struct {
        baseURL    string
        httpClient *http.Client
        enabled    bool
}

// NewAuthService creates a new authentication service client
func NewAuthService(baseURL string, timeout int, enabled bool) AuthService <span class="cov10" title="17">{
        return &amp;httpAuthService{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: time.Duration(timeout) * time.Second,
                },
                enabled: enabled,
        }
}</span>

// AuthRequest represents an authentication request
type AuthRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// AuthResponse represents an authentication response
type AuthResponse struct {
        Token  string           `json:"token"`
        Claims *models.JWTClaims `json:"claims,omitempty"`
}

// Authenticate validates credentials and returns JWT claims
func (s *httpAuthService) Authenticate(ctx context.Context, username, password string) (*models.JWTClaims, error) <span class="cov8" title="10">{
        if !s.enabled </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("authentication service is not enabled")
        }</span>

        <span class="cov7" title="8">reqBody := AuthRequest{
                Username: username,
                Password: password,
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov7" title="8">req, err := http.NewRequestWithContext(ctx, http.MethodPost, s.baseURL+"/authenticate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov7" title="8">req.Header.Set("Content-Type", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov6" title="6">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov4" title="3">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("authentication failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov4" title="3">var authResp AuthResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;authResp); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov3" title="2">return authResp.Claims, nil</span>
}

// ValidateToken validates a JWT token and returns the claims
func (s *httpAuthService) ValidateToken(ctx context.Context, token string) (*models.JWTClaims, error) <span class="cov7" title="7">{
        if !s.enabled </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("authentication service is not enabled")
        }</span>

        <span class="cov6" title="5">req, err := http.NewRequestWithContext(ctx, http.MethodGet, s.baseURL+"/validate", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov6" title="5">req.Header.Set("Authorization", "Bearer "+token)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov6" title="5">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov3" title="2">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("token validation failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov4" title="3">var claims models.JWTClaims
        if err := json.NewDecoder(resp.Body).Decode(&amp;claims); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov3" title="2">return &amp;claims, nil</span>
}

// IsEnabled returns whether the authentication service is enabled
func (s *httpAuthService) IsEnabled() bool <span class="cov3" title="2">{
        return s.enabled
}</span>

// MockAuthService is a mock implementation for testing
type MockAuthService struct {
        AuthenticateFunc   func(ctx context.Context, username, password string) (*models.JWTClaims, error)
        ValidateTokenFunc  func(ctx context.Context, token string) (*models.JWTClaims, error)
        IsEnabledFunc      func() bool
}

func (m *MockAuthService) Authenticate(ctx context.Context, username, password string) (*models.JWTClaims, error) <span class="cov5" title="4">{
        if m.AuthenticateFunc != nil </span><span class="cov4" title="3">{
                return m.AuthenticateFunc(ctx, username, password)
        }</span>
        <span class="cov1" title="1">return nil, fmt.Errorf("not implemented")</span>
}

func (m *MockAuthService) ValidateToken(ctx context.Context, token string) (*models.JWTClaims, error) <span class="cov5" title="4">{
        if m.ValidateTokenFunc != nil </span><span class="cov4" title="3">{
                return m.ValidateTokenFunc(ctx, token)
        }</span>
        <span class="cov1" title="1">return nil, fmt.Errorf("not implemented")</span>
}

func (m *MockAuthService) IsEnabled() bool <span class="cov4" title="3">{
        if m.IsEnabledFunc != nil </span><span class="cov3" title="2">{
                return m.IsEnabledFunc()
        }</span>
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
)

// FailoverManager handles automatic failover and failback of services
type FailoverManager struct {
        db                      database.Database
        stabilityCheckCount     int           // Number of consecutive healthy checks before failback
        failbackDelay           time.Duration // Minimum time before attempting failback
        consecutiveHealthChecks map[string]int // Track consecutive healthy checks per service
}

// NewFailoverManager creates a new failover manager
func NewFailoverManager(db database.Database) *FailoverManager <span class="cov10" title="4">{
        return &amp;FailoverManager{
                db:                      db,
                stabilityCheckCount:     3,              // Primary must be healthy for 3 consecutive checks
                failbackDelay:           5 * time.Minute, // Wait at least 5 minutes before failback
                consecutiveHealthChecks: make(map[string]int),
        }
}</span>

// CheckFailoverNeeded checks if a service needs failover and executes it if necessary
func (fm *FailoverManager) CheckFailoverNeeded(serviceID string, isHealthy bool, status models.ServiceStatus) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Get service details
        query := `
                SELECT id, name, type, role, failover_group, is_active, status, last_failover_at
                FROM service_registry
                WHERE id = ? AND deleted = 0
        `

        var service struct {
                ID             string
                Name           string
                Type           string
                Role           string
                FailoverGroup  string
                IsActive       int
                Status         string
                LastFailoverAt int64
        }

        err := fm.db.QueryRow(ctx, query, serviceID).Scan(
                &amp;service.ID,
                &amp;service.Name,
                &amp;service.Type,
                &amp;service.Role,
                &amp;service.FailoverGroup,
                &amp;service.IsActive,
                &amp;service.Status,
                &amp;service.LastFailoverAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get service details: %w", err)
        }</span>

        // Only process services that are part of a failover group
        <span class="cov0" title="0">if service.FailoverGroup == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Update consecutive health check count
        <span class="cov0" title="0">if isHealthy </span><span class="cov0" title="0">{
                fm.consecutiveHealthChecks[serviceID]++
        }</span> else<span class="cov0" title="0"> {
                fm.consecutiveHealthChecks[serviceID] = 0
        }</span>

        // Check if failover is needed (active service became unhealthy)
        <span class="cov0" title="0">if service.IsActive == 1 &amp;&amp; !isHealthy &amp;&amp; status == models.ServiceStatusUnhealthy </span><span class="cov0" title="0">{
                logger.Warn("Active service became unhealthy, initiating failover",
                        zap.String("service_id", serviceID),
                        zap.String("service_name", service.Name),
                        zap.String("failover_group", service.FailoverGroup),
                )

                return fm.executeFailover(service.FailoverGroup, service.Type, serviceID)
        }</span>

        // Check if failback is needed (primary recovered while backup is active)
        <span class="cov0" title="0">if service.Role == "primary" &amp;&amp; service.IsActive == 0 &amp;&amp; isHealthy </span><span class="cov0" title="0">{
                consecutiveHealthy := fm.consecutiveHealthChecks[serviceID]
                timeSinceFailover := time.Now().Unix() - service.LastFailoverAt

                // Ensure primary is stable before failing back
                if consecutiveHealthy &gt;= fm.stabilityCheckCount &amp;&amp; timeSinceFailover &gt;= int64(fm.failbackDelay.Seconds()) </span><span class="cov0" title="0">{
                        logger.Info("Primary service recovered and stable, initiating failback",
                                zap.String("service_id", serviceID),
                                zap.String("service_name", service.Name),
                                zap.String("failover_group", service.FailoverGroup),
                                zap.Int("consecutive_healthy", consecutiveHealthy),
                        )

                        return fm.executeFailback(service.FailoverGroup, service.Type, serviceID)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeFailover performs failover from unhealthy active service to backup
func (fm *FailoverManager) executeFailover(failoverGroup, serviceType, oldServiceID string) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Find the best backup service in the same failover group
        query := `
                SELECT id, name, url, status, priority
                FROM service_registry
                WHERE failover_group = ?
                  AND type = ?
                  AND role = 'backup'
                  AND status = 'healthy'
                  AND deleted = 0
                  AND is_active = 0
                ORDER BY priority DESC, health_check_count DESC
                LIMIT 1
        `

        var backup struct {
                ID       string
                Name     string
                URL      string
                Status   string
                Priority int
        }

        err := fm.db.QueryRow(ctx, query, failoverGroup, serviceType).Scan(
                &amp;backup.ID,
                &amp;backup.Name,
                &amp;backup.URL,
                &amp;backup.Status,
                &amp;backup.Priority,
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("No healthy backup service available for failover",
                        zap.String("failover_group", failoverGroup),
                        zap.String("service_type", serviceType),
                        zap.Error(err),
                )
                return fmt.Errorf("no healthy backup available: %w", err)
        }</span>

        // Perform failover in a transaction-like manner
        <span class="cov0" title="0">now := time.Now().Unix()

        // 1. Deactivate old service
        _, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 0, last_failover_at = ? WHERE id = ?",
                now, oldServiceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate old service: %w", err)
        }</span>

        // 2. Activate backup service
        <span class="cov0" title="0">_, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 1, last_failover_at = ? WHERE id = ?",
                now, backup.ID)
        if err != nil </span><span class="cov0" title="0">{
                // Rollback: reactivate old service
                fm.db.Exec(ctx, "UPDATE service_registry SET is_active = 1 WHERE id = ?", oldServiceID)
                return fmt.Errorf("failed to activate backup service: %w", err)
        }</span>

        // 3. Record failover event
        <span class="cov0" title="0">event := models.ServiceFailoverEvent{
                ID:             uuid.New().String(),
                FailoverGroup:  failoverGroup,
                ServiceType:    models.ServiceType(serviceType),
                OldServiceID:   oldServiceID,
                NewServiceID:   backup.ID,
                FailoverReason: "Primary service became unhealthy",
                FailoverType:   "failover",
                Timestamp:      time.Now(),
                Automatic:      true,
        }

        _, err = fm.db.Exec(ctx, `
                INSERT INTO service_failover_events (
                        id, failover_group, service_type, old_service_id, new_service_id,
                        failover_reason, failover_type, timestamp, automatic
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, event.ID, event.FailoverGroup, event.ServiceType, event.OldServiceID,
                event.NewServiceID, event.FailoverReason, event.FailoverType,
                event.Timestamp.Unix(), 1)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to record failover event", zap.Error(err))
                // Don't fail the failover for logging issues
        }</span>

        <span class="cov0" title="0">logger.Info("Failover completed successfully",
                zap.String("failover_group", failoverGroup),
                zap.String("old_service", oldServiceID),
                zap.String("new_service", backup.ID),
                zap.String("backup_name", backup.Name),
                zap.String("backup_url", backup.URL),
        )

        return nil</span>
}

// executeFailback performs failback to primary service when it recovers
func (fm *FailoverManager) executeFailback(failoverGroup, serviceType, primaryServiceID string) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Find the currently active backup
        query := `
                SELECT id, name
                FROM service_registry
                WHERE failover_group = ?
                  AND type = ?
                  AND is_active = 1
                  AND deleted = 0
                LIMIT 1
        `

        var activeBackup struct {
                ID   string
                Name string
        }

        err := fm.db.QueryRow(ctx, query, failoverGroup, serviceType).Scan(
                &amp;activeBackup.ID,
                &amp;activeBackup.Name,
        )

        if err != nil </span><span class="cov0" title="0">{
                // No active backup found, primary might already be active
                return nil
        }</span>

        // Perform failback
        <span class="cov0" title="0">now := time.Now().Unix()

        // 1. Deactivate backup
        _, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 0, last_failover_at = ? WHERE id = ?",
                now, activeBackup.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate backup: %w", err)
        }</span>

        // 2. Activate primary
        <span class="cov0" title="0">_, err = fm.db.Exec(ctx,
                "UPDATE service_registry SET is_active = 1, last_failover_at = ? WHERE id = ?",
                now, primaryServiceID)
        if err != nil </span><span class="cov0" title="0">{
                // Rollback: reactivate backup
                fm.db.Exec(ctx, "UPDATE service_registry SET is_active = 1 WHERE id = ?", activeBackup.ID)
                return fmt.Errorf("failed to activate primary: %w", err)
        }</span>

        // 3. Record failback event
        <span class="cov0" title="0">event := models.ServiceFailoverEvent{
                ID:             uuid.New().String(),
                FailoverGroup:  failoverGroup,
                ServiceType:    models.ServiceType(serviceType),
                OldServiceID:   activeBackup.ID,
                NewServiceID:   primaryServiceID,
                FailoverReason: "Primary service recovered and stable",
                FailoverType:   "failback",
                Timestamp:      time.Now(),
                Automatic:      true,
        }

        _, err = fm.db.Exec(ctx, `
                INSERT INTO service_failover_events (
                        id, failover_group, service_type, old_service_id, new_service_id,
                        failover_reason, failover_type, timestamp, automatic
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, event.ID, event.FailoverGroup, event.ServiceType, event.OldServiceID,
                event.NewServiceID, event.FailoverReason, event.FailoverType,
                event.Timestamp.Unix(), 1)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to record failback event", zap.Error(err))
                // Don't fail the failback for logging issues
        }</span>

        // Reset consecutive health check counter
        <span class="cov0" title="0">fm.consecutiveHealthChecks[primaryServiceID] = 0

        logger.Info("Failback completed successfully",
                zap.String("failover_group", failoverGroup),
                zap.String("backup_service", activeBackup.ID),
                zap.String("primary_service", primaryServiceID),
        )

        return nil</span>
}

// GetFailoverHistory returns recent failover events for a failover group
func (fm *FailoverManager) GetFailoverHistory(failoverGroup string, limit int) ([]models.ServiceFailoverEvent, error) <span class="cov0" title="0">{
        ctx := context.Background()

        query := `
                SELECT id, failover_group, service_type, old_service_id, new_service_id,
                       failover_reason, failover_type, timestamp, automatic
                FROM service_failover_events
                WHERE failover_group = ?
                ORDER BY timestamp DESC
                LIMIT ?
        `

        rows, err := fm.db.Query(ctx, query, failoverGroup, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query failover history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []models.ServiceFailoverEvent

        for rows.Next() </span><span class="cov0" title="0">{
                var event models.ServiceFailoverEvent
                var timestamp int64
                var automatic int

                err := rows.Scan(
                        &amp;event.ID,
                        &amp;event.FailoverGroup,
                        &amp;event.ServiceType,
                        &amp;event.OldServiceID,
                        &amp;event.NewServiceID,
                        &amp;event.FailoverReason,
                        &amp;event.FailoverType,
                        &amp;timestamp,
                        &amp;automatic,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan failover event: %w", err)
                }</span>

                <span class="cov0" title="0">event.Timestamp = time.Unix(timestamp, 0)
                event.Automatic = automatic == 1

                events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}

// GetActiveService returns the currently active service for a failover group and type
func (fm *FailoverManager) GetActiveService(failoverGroup string, serviceType models.ServiceType) (*models.ServiceRegistration, error) <span class="cov0" title="0">{
        ctx := context.Background()

        query := `
                SELECT id, name, type, version, url, health_check_url, status, role,
                       failover_group, is_active, priority, last_health_check
                FROM service_registry
                WHERE failover_group = ?
                  AND type = ?
                  AND is_active = 1
                  AND deleted = 0
                LIMIT 1
        `

        var service models.ServiceRegistration
        var lastHealthCheck int64

        err := fm.db.QueryRow(ctx, query, failoverGroup, serviceType).Scan(
                &amp;service.ID,
                &amp;service.Name,
                &amp;service.Type,
                &amp;service.Version,
                &amp;service.URL,
                &amp;service.HealthCheckURL,
                &amp;service.Status,
                &amp;service.Role,
                &amp;service.FailoverGroup,
                &amp;service.IsActive,
                &amp;service.Priority,
                &amp;lastHealthCheck,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no active service found: %w", err)
        }</span>

        <span class="cov0" title="0">if lastHealthCheck &gt; 0 </span><span class="cov0" title="0">{
                service.LastHealthCheck = time.Unix(lastHealthCheck, 0)
        }</span>

        <span class="cov0" title="0">return &amp;service, nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package services

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "go.uber.org/zap"
        "helixtrack.ru/core/internal/database"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
)

// HealthChecker performs periodic health checks on registered services
type HealthChecker struct {
        db               database.Database
        httpClient       *http.Client
        checkInterval    time.Duration
        checkTimeout     time.Duration
        stopChan         chan struct{}
        wg               sync.WaitGroup
        mu               sync.RWMutex
        running          bool
        failureThreshold int // Number of failures before marking unhealthy
        failoverManager  *FailoverManager
}

// NewHealthChecker creates a new health checker
func NewHealthChecker(db database.Database, checkInterval, checkTimeout time.Duration) *HealthChecker <span class="cov10" title="3">{
        return &amp;HealthChecker{
                db:            db,
                httpClient: &amp;http.Client{
                        Timeout: checkTimeout,
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse // Don't follow redirects
                        }</span>,
                },
                checkInterval:    checkInterval,
                checkTimeout:     checkTimeout,
                stopChan:         make(chan struct{}),
                failureThreshold: 3, // Mark unhealthy after 3 consecutive failures
                failoverManager:  NewFailoverManager(db),
        }
}

// Start begins the health check loop
func (h *HealthChecker) Start() error <span class="cov6" title="2">{
        h.mu.Lock()
        if h.running </span><span class="cov1" title="1">{
                h.mu.Unlock()
                return fmt.Errorf("health checker is already running")
        }</span>
        <span class="cov1" title="1">h.running = true
        h.mu.Unlock()

        logger.Info("Starting service health checker", zap.Duration("interval", h.checkInterval))

        h.wg.Add(1)
        go h.checkLoop()

        return nil</span>
}

// Stop stops the health check loop
func (h *HealthChecker) Stop() <span class="cov6" title="2">{
        h.mu.Lock()
        if !h.running </span><span class="cov1" title="1">{
                h.mu.Unlock()
                return
        }</span>
        <span class="cov1" title="1">h.running = false
        h.mu.Unlock()

        close(h.stopChan)
        h.wg.Wait()

        logger.Info("Service health checker stopped")</span>
}

// IsRunning returns whether the health checker is currently running
func (h *HealthChecker) IsRunning() bool <span class="cov10" title="3">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return h.running
}</span>

// checkLoop is the main health check loop
func (h *HealthChecker) checkLoop() <span class="cov1" title="1">{
        defer h.wg.Done()

        ticker := time.NewTicker(h.checkInterval)
        defer ticker.Stop()

        // Perform initial check immediately
        h.checkAllServices()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.checkAllServices()</span>
                case &lt;-h.stopChan:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// checkAllServices checks health of all registered services
func (h *HealthChecker) checkAllServices() <span class="cov1" title="1">{
        ctx := context.Background()

        // Get all non-deleted, non-decommissioned services
        query := `
                SELECT id, name, type, url, health_check_url, status, failed_health_count
                FROM service_registry
                WHERE deleted = 0 AND status != ?
        `

        rows, err := h.db.Query(ctx, query, models.ServiceStatusDecommission)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to query services for health check", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var services []struct {
                ID               string
                Name             string
                Type             string
                URL              string
                HealthCheckURL   string
                Status           string
                FailedHealthCount int
        }

        for rows.Next() </span><span class="cov0" title="0">{
                var svc struct {
                        ID               string
                        Name             string
                        Type             string
                        URL              string
                        HealthCheckURL   string
                        Status           string
                        FailedHealthCount int
                }

                err := rows.Scan(&amp;svc.ID, &amp;svc.Name, &amp;svc.Type, &amp;svc.URL, &amp;svc.HealthCheckURL,
                        &amp;svc.Status, &amp;svc.FailedHealthCount)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to scan service row", zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">services = append(services, svc)</span>
        }

        // Check each service in parallel
        <span class="cov0" title="0">var wg sync.WaitGroup
        for _, svc := range services </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(s struct {
                        ID               string
                        Name             string
                        Type             string
                        URL              string
                        HealthCheckURL   string
                        Status           string
                        FailedHealthCount int
                }) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        h.checkService(s.ID, s.Name, s.HealthCheckURL, s.FailedHealthCount)
                }</span>(svc)
        }

        <span class="cov0" title="0">wg.Wait()</span>
}

// checkService performs a health check on a single service
func (h *HealthChecker) checkService(serviceID, serviceName, healthCheckURL string, currentFailures int) <span class="cov0" title="0">{
        ctx := context.Background()
        startTime := time.Now()

        logger.Debug("Checking service health",
                zap.String("service_id", serviceID),
                zap.String("service_name", serviceName),
                zap.String("url", healthCheckURL),
        )

        // Create context with timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, h.checkTimeout)
        defer cancel()

        // Perform HTTP health check
        req, err := http.NewRequestWithContext(timeoutCtx, http.MethodGet, healthCheckURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.recordHealthCheck(serviceID, false, 0, 0, fmt.Sprintf("Failed to create request: %v", err), currentFailures+1)
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.httpClient.Do(req)
        responseTime := time.Since(startTime).Milliseconds()

        if err != nil </span><span class="cov0" title="0">{
                h.recordHealthCheck(serviceID, false, responseTime, 0, fmt.Sprintf("Request failed: %v", err), currentFailures+1)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Consider 2xx and 3xx status codes as healthy
        healthy := resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400

        var failureCount int
        if healthy </span><span class="cov0" title="0">{
                failureCount = 0 // Reset failure count on success
        }</span> else<span class="cov0" title="0"> {
                failureCount = currentFailures + 1
        }</span>

        <span class="cov0" title="0">errorMsg := ""
        if !healthy </span><span class="cov0" title="0">{
                errorMsg = fmt.Sprintf("Unhealthy status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">h.recordHealthCheck(serviceID, healthy, responseTime, resp.StatusCode, errorMsg, failureCount)</span>
}

// recordHealthCheck records the result of a health check
func (h *HealthChecker) recordHealthCheck(
        serviceID string,
        healthy bool,
        responseTime int64,
        statusCode int,
        errorMessage string,
        failureCount int,
) <span class="cov0" title="0">{
        ctx := context.Background()
        now := time.Now()

        // Determine new status
        var newStatus models.ServiceStatus
        if healthy </span><span class="cov0" title="0">{
                newStatus = models.ServiceStatusHealthy
        }</span> else<span class="cov0" title="0"> {
                if failureCount &gt;= h.failureThreshold </span><span class="cov0" title="0">{
                        newStatus = models.ServiceStatusUnhealthy
                }</span> else<span class="cov0" title="0"> {
                        // Keep current status if below threshold
                        var currentStatus string
                        err := h.db.QueryRow(ctx, "SELECT status FROM service_registry WHERE id = ?", serviceID).Scan(&amp;currentStatus)
                        if err == nil </span><span class="cov0" title="0">{
                                newStatus = models.ServiceStatus(currentStatus)
                        }</span> else<span class="cov0" title="0"> {
                                newStatus = models.ServiceStatusHealthy // Default
                        }</span>
                }
        }

        // Update service registry
        <span class="cov0" title="0">updateQuery := `
                UPDATE service_registry
                SET status = ?,
                    last_health_check = ?,
                    health_check_count = health_check_count + 1,
                    failed_health_count = ?
                WHERE id = ?
        `

        _, err := h.db.Exec(ctx, updateQuery, newStatus, now.Unix(), failureCount, serviceID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update service health status",
                        zap.String("service_id", serviceID),
                        zap.Error(err),
                )
                return
        }</span>

        // Check if failover is needed (automatic failover/failback)
        <span class="cov0" title="0">if err := h.failoverManager.CheckFailoverNeeded(serviceID, healthy, newStatus); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failover check failed",
                        zap.String("service_id", serviceID),
                        zap.Error(err),
                )
                // Don't return - continue with health check recording even if failover fails
        }</span>

        // Insert health check record
        <span class="cov0" title="0">insertQuery := `
                INSERT INTO service_health_check (id, service_id, timestamp, status, response_time, status_code, error_message, checked_by)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        checkID := fmt.Sprintf("hc_%s_%d", serviceID[:8], now.Unix())
        _, err = h.db.Exec(ctx, insertQuery,
                checkID,
                serviceID,
                now.Unix(),
                newStatus,
                responseTime,
                statusCode,
                errorMessage,
                "system",
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to insert health check record",
                        zap.String("service_id", serviceID),
                        zap.Error(err),
                )
                return
        }</span>

        // Log the result
        <span class="cov0" title="0">if healthy </span><span class="cov0" title="0">{
                logger.Debug("Service health check passed",
                        zap.String("service_id", serviceID),
                        zap.Int64("response_time_ms", responseTime),
                        zap.Int("status_code", statusCode),
                )
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Service health check failed",
                        zap.String("service_id", serviceID),
                        zap.Int("failure_count", failureCount),
                        zap.String("status", string(newStatus)),
                        zap.String("error", errorMessage),
                )
        }</span>
}

// CheckServiceNow performs an immediate health check on a specific service
func (h *HealthChecker) CheckServiceNow(serviceID string) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Get service details
        query := `
                SELECT name, health_check_url, failed_health_count
                FROM service_registry
                WHERE id = ? AND deleted = 0
        `

        var name, healthCheckURL string
        var failedHealthCount int

        err := h.db.QueryRow(ctx, query, serviceID).Scan(&amp;name, &amp;healthCheckURL, &amp;failedHealthCount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("service not found: %w", err)
        }</span>

        // Perform check
        <span class="cov0" title="0">h.checkService(serviceID, name, healthCheckURL, failedHealthCount)

        return nil</span>
}

// GetServiceHealthHistory returns recent health check history for a service
func (h *HealthChecker) GetServiceHealthHistory(serviceID string, limit int) ([]models.ServiceHealthCheck, error) <span class="cov1" title="1">{
        ctx := context.Background()

        query := `
                SELECT id, service_id, timestamp, status, response_time, status_code, error_message, checked_by
                FROM service_health_check
                WHERE service_id = ?
                ORDER BY timestamp DESC
                LIMIT ?
        `

        rows, err := h.db.Query(ctx, query, serviceID, limit)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to query health check history: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var checks []models.ServiceHealthCheck

        for rows.Next() </span><span class="cov0" title="0">{
                var check models.ServiceHealthCheck
                var timestamp int64

                err := rows.Scan(
                        &amp;check.ID,
                        &amp;check.ServiceID,
                        &amp;timestamp,
                        &amp;check.Status,
                        &amp;check.ResponseTime,
                        &amp;check.StatusCode,
                        &amp;check.ErrorMessage,
                        &amp;check.CheckedBy,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan health check row: %w", err)
                }</span>

                <span class="cov0" title="0">check.Timestamp = time.Unix(timestamp, 0)
                checks = append(checks, check)</span>
        }

        <span class="cov0" title="0">return checks, nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package services

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "helixtrack.ru/core/internal/models"
)

// JWTService handles JWT token generation and validation
type JWTService struct {
        secretKey string
        issuer    string
        expiry    time.Duration
}

// NewJWTService creates a new JWT service
func NewJWTService(secretKey, issuer string, expiryHours int) *JWTService <span class="cov0" title="0">{
        if secretKey == "" </span><span class="cov0" title="0">{
                secretKey = "helix-track-default-secret-key-change-in-production"
        }</span>
        <span class="cov0" title="0">if issuer == "" </span><span class="cov0" title="0">{
                issuer = "helixtrack-core"
        }</span>
        <span class="cov0" title="0">if expiryHours == 0 </span><span class="cov0" title="0">{
                expiryHours = 24 // Default 24 hours
        }</span>

        <span class="cov0" title="0">return &amp;JWTService{
                secretKey: secretKey,
                issuer:    issuer,
                expiry:    time.Duration(expiryHours) * time.Hour,
        }</span>
}

// GenerateToken generates a JWT token for a user
func (s *JWTService) GenerateToken(username, email, name, role string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiresAt := now.Add(s.expiry)

        claims := &amp;models.JWTClaims{
                Username: username,
                Email:    email,
                Name:     name,
                Role:     role,
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   username,
                        Issuer:    s.issuer,
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        NotBefore: jwt.NewNumericDate(now),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(s.secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign token: %w", err)
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// ValidateToken validates a JWT token and returns the claims
func (s *JWTService) ValidateToken(tokenString string) (*models.JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;models.JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(s.secretKey), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*models.JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token claims")</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package services

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "helixtrack.ru/core/internal/models"
)

// PermissionService defines the interface for permission checking operations
type PermissionService interface {
        // CheckPermission checks if a user has required permission for a context
        CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error)

        // GetUserPermissions retrieves all permissions for a user
        GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error)

        // IsEnabled returns whether the permission service is enabled
        IsEnabled() bool
}

// httpPermissionService is the HTTP-based implementation of PermissionService
type httpPermissionService struct {
        baseURL    string
        httpClient *http.Client
        enabled    bool
}

// NewPermissionService creates a new permission service client
func NewPermissionService(baseURL string, timeout int, enabled bool) PermissionService <span class="cov9" title="17">{
        return &amp;httpPermissionService{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: time.Duration(timeout) * time.Second,
                },
                enabled: enabled,
        }
}</span>

// PermissionCheckRequest represents a permission check request
type PermissionCheckRequest struct {
        Username          string                  `json:"username"`
        Context           string                  `json:"context"`
        RequiredLevel     models.PermissionLevel  `json:"required_level"`
}

// PermissionCheckResponse represents a permission check response
type PermissionCheckResponse struct {
        Allowed bool   `json:"allowed"`
        Reason  string `json:"reason,omitempty"`
}

// UserPermissionsResponse represents a user permissions response
type UserPermissionsResponse struct {
        Permissions []models.Permission `json:"permissions"`
}

// CheckPermission checks if a user has required permission for a context
func (s *httpPermissionService) CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error) <span class="cov7" title="9">{
        if !s.enabled </span><span class="cov3" title="2">{
                // If permission service is disabled, allow all operations (development mode)
                return true, nil
        }</span>

        <span class="cov7" title="7">reqBody := PermissionCheckRequest{
                Username:      username,
                Context:       permissionContext,
                RequiredLevel: requiredLevel,
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov7" title="7">req, err := http.NewRequestWithContext(ctx, http.MethodPost, s.baseURL+"/check", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov7" title="7">req.Header.Set("Content-Type", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov7" title="7">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov4" title="3">{
                body, _ := io.ReadAll(resp.Body)
                return false, fmt.Errorf("permission check failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov5" title="4">var checkResp PermissionCheckResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;checkResp); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov5" title="4">return checkResp.Allowed, nil</span>
}

// GetUserPermissions retrieves all permissions for a user
func (s *httpPermissionService) GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error) <span class="cov6" title="5">{
        if !s.enabled </span><span class="cov3" title="2">{
                // If permission service is disabled, return empty permissions
                return []models.Permission{}, nil
        }</span>

        <span class="cov4" title="3">req, err := http.NewRequestWithContext(ctx, http.MethodGet, s.baseURL+"/permissions/"+username, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov4" title="3">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov4" title="3">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("get permissions failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov3" title="2">var permResp UserPermissionsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;permResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov3" title="2">return permResp.Permissions, nil</span>
}

// IsEnabled returns whether the permission service is enabled
func (s *httpPermissionService) IsEnabled() bool <span class="cov6" title="5">{
        return s.enabled
}</span>

// localPermissionService is a local/in-memory implementation of PermissionService
// This can be used as a free/open-source alternative to proprietary implementations
type localPermissionService struct {
        permissions map[string][]models.Permission // username -&gt; permissions
        enabled     bool
}

// NewLocalPermissionService creates a new local permission service
func NewLocalPermissionService(enabled bool) PermissionService <span class="cov9" title="14">{
        return &amp;localPermissionService{
                permissions: make(map[string][]models.Permission),
                enabled:     enabled,
        }
}</span>

// AddUserPermission adds a permission for a user (for testing/setup)
func (s *localPermissionService) AddUserPermission(username string, permission models.Permission) <span class="cov8" title="12">{
        if s.permissions[username] == nil </span><span class="cov7" title="7">{
                s.permissions[username] = []models.Permission{}
        }</span>
        <span class="cov8" title="12">s.permissions[username] = append(s.permissions[username], permission)</span>
}

// CheckPermission checks if a user has required permission for a context
func (s *localPermissionService) CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error) <span class="cov9" title="15">{
        if !s.enabled </span><span class="cov1" title="1">{
                // If permission service is disabled, allow all operations
                return true, nil
        }</span>

        <span class="cov9" title="14">userPerms, exists := s.permissions[username]
        if !exists </span><span class="cov1" title="1">{
                return false, nil // User has no permissions
        }</span>

        // Check for exact context match or parent context match
        <span class="cov8" title="13">for _, perm := range userPerms </span><span class="cov10" title="18">{
                if perm.Deleted </span><span class="cov1" title="1">{
                        continue</span>
                }

                // Check if permission context matches or is a parent
                <span class="cov9" title="17">if perm.Context == permissionContext || models.IsParentContext(perm.Context, permissionContext) </span><span class="cov8" title="12">{
                        // Check if permission level is sufficient
                        if perm.Level.HasPermission(requiredLevel) </span><span class="cov7" title="8">{
                                return true, nil
                        }</span>
                }
        }

        <span class="cov6" title="5">return false, nil</span>
}

// GetUserPermissions retrieves all permissions for a user
func (s *localPermissionService) GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error) <span class="cov5" title="4">{
        if !s.enabled </span><span class="cov1" title="1">{
                return []models.Permission{}, nil
        }</span>

        <span class="cov4" title="3">userPerms, exists := s.permissions[username]
        if !exists </span><span class="cov1" title="1">{
                return []models.Permission{}, nil
        }</span>

        // Filter out deleted permissions
        <span class="cov3" title="2">activePerms := []models.Permission{}
        for _, perm := range userPerms </span><span class="cov6" title="5">{
                if !perm.Deleted </span><span class="cov5" title="4">{
                        activePerms = append(activePerms, perm)
                }</span>
        }

        <span class="cov3" title="2">return activePerms, nil</span>
}

// IsEnabled returns whether the permission service is enabled
func (s *localPermissionService) IsEnabled() bool <span class="cov4" title="3">{
        return s.enabled
}</span>

// MockPermissionService is a mock implementation for testing
type MockPermissionService struct {
        CheckPermissionFunc    func(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error)
        GetUserPermissionsFunc func(ctx context.Context, username string) ([]models.Permission, error)
        IsEnabledFunc          func() bool
}

func (m *MockPermissionService) CheckPermission(ctx context.Context, username, permissionContext string, requiredLevel models.PermissionLevel) (bool, error) <span class="cov4" title="3">{
        if m.CheckPermissionFunc != nil </span><span class="cov3" title="2">{
                return m.CheckPermissionFunc(ctx, username, permissionContext, requiredLevel)
        }</span>
        <span class="cov1" title="1">return true, nil</span> // Default to allowing
}

func (m *MockPermissionService) GetUserPermissions(ctx context.Context, username string) ([]models.Permission, error) <span class="cov4" title="3">{
        if m.GetUserPermissionsFunc != nil </span><span class="cov3" title="2">{
                return m.GetUserPermissionsFunc(ctx, username)
        }</span>
        <span class="cov1" title="1">return []models.Permission{}, nil</span>
}

func (m *MockPermissionService) IsEnabled() bool <span class="cov3" title="2">{
        if m.IsEnabledFunc != nil </span><span class="cov1" title="1">{
                return m.IsEnabledFunc()
        }</span>
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package websocket

import (
        "time"

        "helixtrack.ru/core/internal/config"
        "helixtrack.ru/core/internal/models"
)

// ConfigToModel converts config.WebSocketConfig to models.WebSocketConfig
func ConfigToModel(cfg config.WebSocketConfig) models.WebSocketConfig <span class="cov0" title="0">{
        return models.WebSocketConfig{
                Enabled:           cfg.Enabled,
                Path:              cfg.Path,
                ReadBufferSize:    cfg.ReadBufferSize,
                WriteBufferSize:   cfg.WriteBufferSize,
                MaxMessageSize:    cfg.MaxMessageSize,
                WriteWait:         time.Duration(cfg.WriteWaitSeconds) * time.Second,
                PongWait:          time.Duration(cfg.PongWaitSeconds) * time.Second,
                PingPeriod:        time.Duration(cfg.PingPeriodSeconds) * time.Second,
                MaxClients:        cfg.MaxClients,
                RequireAuth:       cfg.RequireAuth,
                AllowOrigins:      cfg.AllowOrigins,
                EnableCompression: cfg.EnableCompression,
                HandshakeTimeout:  time.Duration(cfg.HandshakeTimeout) * time.Second,
        }
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package websocket

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/middleware"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// Handler handles WebSocket connections
type Handler struct {
        manager     *Manager
        authService services.AuthService
        config      models.WebSocketConfig
}

// NewHandler creates a new WebSocket handler
func NewHandler(manager *Manager, authService services.AuthService, config models.WebSocketConfig) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                manager:     manager,
                authService: authService,
                config:      config,
        }
}</span>

// HandleConnection handles WebSocket connection upgrades
func (h *Handler) HandleConnection(c *gin.Context) <span class="cov0" title="0">{
        // Check if WebSocket is enabled
        if !h.config.Enabled </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, models.NewErrorResponse(
                        models.ErrorCodeServiceUnavailable,
                        "WebSocket service is not enabled",
                        "",
                ))
                return
        }</span>

        // Get JWT token from query parameter or header
        <span class="cov0" title="0">var jwtToken string

        // Check query parameter first (ws://host/ws?token=xxx)
        jwtToken = c.Query("token")

        // Fall back to Authorization header
        if jwtToken == "" </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                        jwtToken = authHeader[7:]
                }</span>
        }

        // Fall back to Sec-WebSocket-Protocol header (common for WebSocket auth)
        <span class="cov0" title="0">if jwtToken == "" </span><span class="cov0" title="0">{
                jwtToken = c.GetHeader("Sec-WebSocket-Protocol")
        }</span>

        // Check if authentication is required
        <span class="cov0" title="0">if h.config.RequireAuth &amp;&amp; jwtToken == "" </span><span class="cov0" title="0">{
                logger.Warn("WebSocket connection attempt without JWT token",
                        zap.String("remoteAddr", c.Request.RemoteAddr),
                )
                c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                        models.ErrorCodeMissingJWT,
                        "JWT token is required for WebSocket connection",
                        "",
                ))
                return
        }</span>

        <span class="cov0" title="0">var claims *models.JWTClaims
        var username string

        // Validate JWT token if provided
        if jwtToken != "" </span><span class="cov0" title="0">{
                jwtMiddleware := middleware.NewJWTMiddleware(h.authService, "")
                validatedClaims, err := jwtMiddleware.ValidateToken(c.Request.Context(), jwtToken)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Invalid JWT token for WebSocket",
                                zap.Error(err),
                                zap.String("remoteAddr", c.Request.RemoteAddr),
                        )
                        c.JSON(http.StatusUnauthorized, models.NewErrorResponse(
                                models.ErrorCodeInvalidJWT,
                                "Invalid or expired JWT token",
                                "",
                        ))
                        return
                }</span>
                <span class="cov0" title="0">claims = validatedClaims
                username = claims.Username</span>
        } else<span class="cov0" title="0"> {
                // If auth is not required and no token provided, use anonymous connection
                username = "anonymous"
                claims = nil
        }</span>

        // Upgrade connection to WebSocket
        <span class="cov0" title="0">upgrader := h.manager.GetUpgrader()
        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to upgrade to WebSocket",
                        zap.Error(err),
                        zap.String("username", username),
                        zap.String("remoteAddr", c.Request.RemoteAddr),
                )
                return
        }</span>

        // Create client
        <span class="cov0" title="0">client := h.manager.CreateClient(conn, username, claims)

        // Register client with manager
        if err := h.manager.RegisterClient(client); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to register WebSocket client",
                        zap.Error(err),
                        zap.String("clientId", client.ID),
                        zap.String("username", username),
                )
                client.Close()
                return
        }</span>

        <span class="cov0" title="0">logger.Info("WebSocket connection established",
                zap.String("clientId", client.ID),
                zap.String("username", username),
                zap.String("remoteAddr", c.Request.RemoteAddr),
        )</span>
}

// HandleStats returns WebSocket manager statistics
func (h *Handler) HandleStats(c *gin.Context) <span class="cov0" title="0">{
        stats := h.manager.GetStats()

        c.JSON(http.StatusOK, models.NewSuccessResponse(map[string]interface{}{
                "totalConnections":  stats.TotalConnections,
                "activeConnections": stats.ActiveConnections,
                "totalEvents":       stats.TotalEvents,
                "totalErrors":       stats.TotalErrors,
                "startTime":         stats.StartTime,
                "lastEventTime":     stats.LastEventTime,
                "uptime":            stats.LastEventTime.Sub(stats.StartTime).String(),
        }))
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package websocket

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/gorilla/websocket"
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
        "helixtrack.ru/core/internal/services"
)

// Manager manages WebSocket connections and event broadcasting
type Manager struct {
        clients         map[string]*models.Client   // Registered clients by ID
        clientsByUser   map[string][]*models.Client // Clients indexed by username
        register        chan *models.Client         // Channel for registering clients
        unregister      chan *models.Client         // Channel for unregistering clients
        broadcast       chan *models.Event          // Channel for broadcasting events
        config          models.WebSocketConfig      // WebSocket configuration
        upgrader        websocket.Upgrader          // WebSocket upgrader
        permService     services.PermissionService  // Permission service for authorization
        mu              sync.RWMutex                // Mutex for thread-safe operations
        ctx             context.Context             // Context for cancellation
        cancel          context.CancelFunc          // Cancel function
        wg              sync.WaitGroup              // Wait group for graceful shutdown
        running         bool                        // Whether the manager is running
        stats           ManagerStats                // Manager statistics
}

// ManagerStats contains statistics about the WebSocket manager
type ManagerStats struct {
        TotalConnections    int64     // Total connections since start
        ActiveConnections   int       // Current active connections
        TotalEvents         int64     // Total events broadcasted
        TotalErrors         int64     // Total errors encountered
        StartTime           time.Time // Manager start time
        LastEventTime       time.Time // Last event broadcast time
        mu                  sync.RWMutex
}

// NewManager creates a new WebSocket manager
func NewManager(config models.WebSocketConfig, permService services.PermissionService) *Manager <span class="cov6" title="4">{
        ctx, cancel := context.WithCancel(context.Background())

        // Configure WebSocket upgrader
        upgrader := websocket.Upgrader{
                ReadBufferSize:   config.ReadBufferSize,
                WriteBufferSize:  config.WriteBufferSize,
                CheckOrigin:      createOriginChecker(config.AllowOrigins),
                HandshakeTimeout: config.HandshakeTimeout,
        }

        if config.EnableCompression </span><span class="cov0" title="0">{
                upgrader.EnableCompression = true
        }</span>

        <span class="cov6" title="4">return &amp;Manager{
                clients:       make(map[string]*models.Client),
                clientsByUser: make(map[string][]*models.Client),
                register:      make(chan *models.Client, 10),
                unregister:    make(chan *models.Client, 10),
                broadcast:     make(chan *models.Event, 256),
                config:        config,
                upgrader:      upgrader,
                permService:   permService,
                ctx:           ctx,
                cancel:        cancel,
                stats: ManagerStats{
                        StartTime: time.Now(),
                },
        }</span>
}

// Start starts the WebSocket manager
func (m *Manager) Start() error <span class="cov6" title="4">{
        m.mu.Lock()
        if m.running </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return fmt.Errorf("manager already running")
        }</span>
        <span class="cov6" title="4">m.running = true
        m.mu.Unlock()

        logger.Info("Starting WebSocket manager",
                zap.Int("maxClients", m.config.MaxClients),
                zap.String("path", m.config.Path),
        )

        m.wg.Add(1)
        go m.run()

        return nil</span>
}

// Stop stops the WebSocket manager gracefully
func (m *Manager) Stop() error <span class="cov6" title="4">{
        m.mu.Lock()
        if !m.running </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return nil
        }</span>
        <span class="cov6" title="4">m.running = false
        m.mu.Unlock()

        logger.Info("Stopping WebSocket manager")

        // Cancel context to stop all goroutines
        m.cancel()

        // Close all channels
        close(m.register)
        close(m.unregister)
        close(m.broadcast)

        // Wait for all goroutines to finish
        m.wg.Wait()

        // Close all client connections
        m.mu.Lock()
        for _, client := range m.clients </span><span class="cov0" title="0">{
                client.Close()
        }</span>
        <span class="cov6" title="4">m.clients = make(map[string]*models.Client)
        m.clientsByUser = make(map[string][]*models.Client)
        m.mu.Unlock()

        logger.Info("WebSocket manager stopped")
        return nil</span>
}

// run is the main event loop for the manager
func (m *Manager) run() <span class="cov6" title="4">{
        defer m.wg.Done()

        ticker := time.NewTicker(10 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov10" title="12">{
                select </span>{
                case &lt;-m.ctx.Done():<span class="cov6" title="4">
                        return</span>

                case client := &lt;-m.register:<span class="cov6" title="4">
                        m.registerClient(client)</span>

                case client := &lt;-m.unregister:<span class="cov6" title="4">
                        m.unregisterClient(client)</span>

                case event := &lt;-m.broadcast:<span class="cov0" title="0">
                        m.broadcastEvent(event)</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.cleanupStaleConnections()</span>
                }
        }
}

// RegisterClient registers a new WebSocket client
func (m *Manager) RegisterClient(client *models.Client) error <span class="cov6" title="4">{
        // Check max clients limit
        m.mu.RLock()
        currentCount := len(m.clients)
        m.mu.RUnlock()

        if currentCount &gt;= m.config.MaxClients </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum client limit reached")
        }</span>

        <span class="cov6" title="4">select </span>{
        case m.register &lt;- client:<span class="cov6" title="4">
                return nil</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("timeout registering client")</span>
        }
}

// registerClient handles client registration (internal)
func (m *Manager) registerClient(client *models.Client) <span class="cov6" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Add to clients map
        m.clients[client.ID] = client

        // Add to user index
        if _, exists := m.clientsByUser[client.Username]; !exists </span><span class="cov6" title="4">{
                m.clientsByUser[client.Username] = make([]*models.Client, 0)
        }</span>
        <span class="cov6" title="4">m.clientsByUser[client.Username] = append(m.clientsByUser[client.Username], client)

        // Update stats
        m.stats.mu.Lock()
        m.stats.TotalConnections++
        m.stats.ActiveConnections = len(m.clients)
        m.stats.mu.Unlock()

        logger.Info("Client registered",
                zap.String("clientId", client.ID),
                zap.String("username", client.Username),
                zap.Int("activeClients", len(m.clients)),
        )

        // Send connection established event
        connectionEvent := models.NewEvent(
                models.EventConnectionEstablished,
                "connect",
                "connection",
                client.ID,
                client.Username,
                map[string]interface{}{
                        "clientId": client.ID,
                        "time":     time.Now().UTC(),
                },
        )
        m.sendToClient(client, connectionEvent)

        // Start client read/write pumps
        go m.readPump(client)
        go m.writePump(client)</span>
}

// UnregisterClient unregisters a WebSocket client
func (m *Manager) UnregisterClient(client *models.Client) <span class="cov6" title="4">{
        select </span>{
        case m.unregister &lt;- client:<span class="cov6" title="4"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                logger.Error("Timeout unregistering client", zap.String("clientId", client.ID))</span>
        }
}

// unregisterClient handles client unregistration (internal)
func (m *Manager) unregisterClient(client *models.Client) <span class="cov6" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Remove from clients map
        if _, exists := m.clients[client.ID]; exists </span><span class="cov6" title="4">{
                delete(m.clients, client.ID)

                // Remove from user index
                if userClients, exists := m.clientsByUser[client.Username]; exists </span><span class="cov6" title="4">{
                        for i, c := range userClients </span><span class="cov6" title="4">{
                                if c.ID == client.ID </span><span class="cov6" title="4">{
                                        m.clientsByUser[client.Username] = append(userClients[:i], userClients[i+1:]...)
                                        break</span>
                                }
                        }
                        // Remove user entry if no more clients
                        <span class="cov6" title="4">if len(m.clientsByUser[client.Username]) == 0 </span><span class="cov6" title="4">{
                                delete(m.clientsByUser, client.Username)
                        }</span>
                }

                // Close client connection
                <span class="cov6" title="4">client.Close()

                // Update stats
                m.stats.mu.Lock()
                m.stats.ActiveConnections = len(m.clients)
                m.stats.mu.Unlock()

                logger.Info("Client unregistered",
                        zap.String("clientId", client.ID),
                        zap.String("username", client.Username),
                        zap.Int("activeClients", len(m.clients)),
                )</span>
        }
}

// BroadcastEvent broadcasts an event to all subscribed clients
func (m *Manager) BroadcastEvent(event *models.Event) <span class="cov0" title="0">{
        select </span>{
        case m.broadcast &lt;- event:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                logger.Error("Timeout broadcasting event", zap.String("eventId", event.ID))
                m.stats.mu.Lock()
                m.stats.TotalErrors++
                m.stats.mu.Unlock()</span>
        }
}

// broadcastEvent handles event broadcasting (internal)
func (m *Manager) broadcastEvent(event *models.Event) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Update stats
        m.stats.mu.Lock()
        m.stats.TotalEvents++
        m.stats.LastEventTime = time.Now()
        m.stats.mu.Unlock()

        logger.Debug("Broadcasting event",
                zap.String("eventId", event.ID),
                zap.String("type", string(event.Type)),
                zap.String("object", event.Object),
                zap.String("entityId", event.EntityID),
        )

        // Send event to all matching clients
        for _, client := range m.clients </span><span class="cov0" title="0">{
                // Check if client is subscribed to this event
                subscription := client.GetSubscription()
                if !event.MatchesSubscription(subscription) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if client has permission to see this event
                <span class="cov0" title="0">if !m.canClientReceiveEvent(client, event) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Send event to client
                <span class="cov0" title="0">m.sendToClient(client, event)</span>
        }
}

// canClientReceiveEvent checks if a client has permission to receive an event
func (m *Manager) canClientReceiveEvent(client *models.Client, event *models.Event) bool <span class="cov0" title="0">{
        // If no permission context, allow
        if len(event.Context.Permissions) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if client has required permissions
        <span class="cov0" title="0">for _, requiredPerm := range event.Context.Permissions </span><span class="cov0" title="0">{
                permLevel := models.ParsePermissionLevel(requiredPerm)
                if !client.HasPermission(int(permLevel)) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // If permission service is enabled, check with service
        <span class="cov0" title="0">if m.permService != nil &amp;&amp; m.permService.IsEnabled() </span><span class="cov0" title="0">{
                allowed, err := m.permService.CheckPermission(
                        m.ctx,
                        client.Username,
                        event.Object,
                        models.PermissionRead,
                )
                if err != nil || !allowed </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// sendToClient sends an event to a specific client
func (m *Manager) sendToClient(client *models.Client, event *models.Event) <span class="cov6" title="4">{
        // Create WebSocket message
        message := models.NewEventMessage(event)
        data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal event",
                        zap.Error(err),
                        zap.String("eventId", event.ID),
                )
                return
        }</span>

        // Send to client's send channel
        <span class="cov6" title="4">select </span>{
        case client.Send &lt;- data:<span class="cov6" title="4"></span>
        default:<span class="cov0" title="0">
                // Client buffer is full, disconnect
                logger.Warn("Client send buffer full, disconnecting",
                        zap.String("clientId", client.ID),
                        zap.String("username", client.Username),
                )
                m.UnregisterClient(client)</span>
        }
}

// readPump reads messages from the WebSocket connection
func (m *Manager) readPump(client *models.Client) <span class="cov6" title="4">{
        defer func() </span><span class="cov6" title="4">{
                m.UnregisterClient(client)
        }</span>()

        <span class="cov6" title="4">client.Conn.SetReadLimit(m.config.MaxMessageSize)
        client.Conn.SetReadDeadline(time.Now().Add(m.config.PongWait))
        client.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                client.UpdatePing()
                client.Conn.SetReadDeadline(time.Now().Add(m.config.PongWait))
                return nil
        }</span>)

        <span class="cov6" title="4">for </span><span class="cov6" title="5">{
                _, messageData, err := client.Conn.ReadMessage()
                if err != nil </span><span class="cov6" title="4">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                logger.Error("WebSocket read error",
                                        zap.Error(err),
                                        zap.String("clientId", client.ID),
                                )
                        }</span>
                        <span class="cov6" title="4">break</span>
                }

                <span class="cov1" title="1">client.UpdateActivity()

                // Parse message
                var message models.WebSocketMessage
                if err := json.Unmarshal(messageData, &amp;message); err != nil </span><span class="cov1" title="1">{
                        logger.Error("Failed to unmarshal WebSocket message",
                                zap.Error(err),
                                zap.String("clientId", client.ID),
                        )
                        m.sendError(client, "Invalid message format")
                        continue</span>
                }

                // Handle message
                <span class="cov0" title="0">m.handleClientMessage(client, &amp;message)</span>
        }
}

// writePump writes messages to the WebSocket connection
func (m *Manager) writePump(client *models.Client) <span class="cov6" title="4">{
        ticker := time.NewTicker(m.config.PingPeriod)
        defer func() </span><span class="cov6" title="4">{
                ticker.Stop()
                client.Conn.Close()
        }</span>()

        <span class="cov6" title="4">for </span><span class="cov8" title="9">{
                select </span>{
                case message, ok := &lt;-client.Send:<span class="cov8" title="9">
                        client.Conn.SetWriteDeadline(time.Now().Add(m.config.WriteWait))
                        if !ok </span><span class="cov6" title="4">{
                                // Channel closed
                                client.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov6" title="5">w, err := client.Conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov6" title="5">w.Write(message)

                        // Add queued messages to the current websocket message
                        n := len(client.Send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-client.Send)
                        }</span>

                        <span class="cov6" title="5">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        client.Conn.SetWriteDeadline(time.Now().Add(m.config.WriteWait))
                        if err := client.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// handleClientMessage handles incoming messages from clients
func (m *Manager) handleClientMessage(client *models.Client, message *models.WebSocketMessage) <span class="cov0" title="0">{
        switch message.Type </span>{
        case models.WSMessageTypeSubscribe:<span class="cov0" title="0">
                m.handleSubscribe(client, message)</span>
        case models.WSMessageTypeUnsubscribe:<span class="cov0" title="0">
                m.handleUnsubscribe(client, message)</span>
        case models.WSMessageTypePing:<span class="cov0" title="0">
                m.handlePing(client)</span>
        default:<span class="cov0" title="0">
                logger.Warn("Unknown message type",
                        zap.String("type", message.Type),
                        zap.String("clientId", client.ID),
                )
                m.sendError(client, "Unknown message type")</span>
        }
}

// handleSubscribe handles subscription requests
func (m *Manager) handleSubscribe(client *models.Client, message *models.WebSocketMessage) <span class="cov0" title="0">{
        // Parse subscription from message data
        subscriptionData, err := json.Marshal(message.Data)
        if err != nil </span><span class="cov0" title="0">{
                m.sendError(client, "Invalid subscription data")
                return
        }</span>

        <span class="cov0" title="0">var subscription models.Subscription
        if err := json.Unmarshal(subscriptionData, &amp;subscription); err != nil </span><span class="cov0" title="0">{
                m.sendError(client, "Invalid subscription format")
                return
        }</span>

        // Update client subscription
        <span class="cov0" title="0">client.UpdateSubscription(&amp;subscription)

        logger.Info("Client subscribed",
                zap.String("clientId", client.ID),
                zap.String("username", client.Username),
                zap.Int("eventTypes", len(subscription.EventTypes)),
                zap.Int("entityTypes", len(subscription.EntityTypes)),
        )

        // Send acknowledgment
        ack := models.NewWebSocketMessage(models.WSMessageTypeAck, "subscribe", map[string]interface{}{
                "success": true,
                "message": "Subscription updated",
        })
        ackData, _ := json.Marshal(ack)
        select </span>{
        case client.Send &lt;- ackData:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// handleUnsubscribe handles unsubscription requests
func (m *Manager) handleUnsubscribe(client *models.Client, message *models.WebSocketMessage) <span class="cov0" title="0">{
        // Reset subscription
        client.UpdateSubscription(&amp;models.Subscription{
                EventTypes:   []models.EventType{},
                EntityTypes:  []string{},
                EntityIDs:    []string{},
                Filters:      make(map[string]string),
                IncludeReads: false,
        })

        logger.Info("Client unsubscribed",
                zap.String("clientId", client.ID),
                zap.String("username", client.Username),
        )

        // Send acknowledgment
        ack := models.NewWebSocketMessage(models.WSMessageTypeAck, "unsubscribe", map[string]interface{}{
                "success": true,
                "message": "Unsubscribed",
        })
        ackData, _ := json.Marshal(ack)
        select </span>{
        case client.Send &lt;- ackData:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// handlePing handles ping messages
func (m *Manager) handlePing(client *models.Client) <span class="cov0" title="0">{
        client.UpdatePing()

        // Send pong response
        pong := models.NewWebSocketMessage(models.WSMessageTypePong, "pong", map[string]interface{}{
                "time": time.Now().UTC(),
        })
        pongData, _ := json.Marshal(pong)
        select </span>{
        case client.Send &lt;- pongData:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// sendError sends an error message to a client
func (m *Manager) sendError(client *models.Client, errorMsg string) <span class="cov1" title="1">{
        errorMessage := models.NewErrorMessage(errorMsg)
        data, _ := json.Marshal(errorMessage)
        select </span>{
        case client.Send &lt;- data:<span class="cov1" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// cleanupStaleConnections removes stale connections
func (m *Manager) cleanupStaleConnections() <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        now := time.Now()
        timeout := 2 * m.config.PongWait

        for _, client := range m.clients </span><span class="cov0" title="0">{
                lastPing := client.GetLastPing()
                if now.Sub(lastPing) &gt; timeout </span><span class="cov0" title="0">{
                        logger.Warn("Removing stale connection",
                                zap.String("clientId", client.ID),
                                zap.String("username", client.Username),
                                zap.Duration("lastPing", now.Sub(lastPing)),
                        )
                        m.UnregisterClient(client)
                }</span>
        }
}

// GetStats returns current manager statistics
func (m *Manager) GetStats() ManagerStats <span class="cov6" title="5">{
        m.stats.mu.RLock()
        defer m.stats.mu.RUnlock()
        return m.stats
}</span>

// GetUpgrader returns the WebSocket upgrader
func (m *Manager) GetUpgrader() *websocket.Upgrader <span class="cov6" title="4">{
        return &amp;m.upgrader
}</span>

// CreateClient creates a new client instance
func (m *Manager) CreateClient(conn *websocket.Conn, username string, claims *models.JWTClaims) *models.Client <span class="cov6" title="4">{
        clientID := uuid.New().String()
        return models.NewClient(clientID, conn, username, claims, m)
}</span>

// createOriginChecker creates an origin checker function for the upgrader
func createOriginChecker(allowedOrigins []string) func(r *http.Request) bool <span class="cov6" title="4">{
        return func(r *http.Request) bool </span><span class="cov6" title="4">{
                // If no origins specified or * is specified, allow all
                if len(allowedOrigins) == 0 || contains(allowedOrigins, "*") </span><span class="cov6" title="4">{
                        return true
                }</span>

                <span class="cov0" title="0">origin := r.Header.Get("Origin")
                return contains(allowedOrigins, origin)</span>
        }
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov6" title="4">{
        for _, s := range slice </span><span class="cov6" title="4">{
                if s == item </span><span class="cov6" title="4">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package websocket

import (
        "go.uber.org/zap"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/models"
)

// EventBroadcaster is an interface for broadcasting events to clients
type EventBroadcaster interface {
        BroadcastEvent(event *models.Event)
}

// EventPublisher is an interface for publishing events
type EventPublisher interface {
        // PublishEvent publishes an event to all subscribed clients
        PublishEvent(event *models.Event)

        // PublishEntityEvent publishes an event for entity operations (CRUD)
        PublishEntityEvent(action, object, entityID, username string, data map[string]interface{}, context models.EventContext)

        // IsEnabled returns whether event publishing is enabled
        IsEnabled() bool
}

// Publisher implements the EventPublisher interface
type Publisher struct {
        manager EventBroadcaster
        enabled bool
}

// NewPublisher creates a new event publisher
func NewPublisher(manager EventBroadcaster, enabled bool) EventPublisher <span class="cov5" title="11">{
        return &amp;Publisher{
                manager: manager,
                enabled: enabled,
        }
}</span>

// PublishEvent publishes an event to all subscribed clients
func (p *Publisher) PublishEvent(event *models.Event) <span class="cov10" title="107">{
        if !p.enabled || p.manager == nil </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov9" title="105">logger.Debug("Publishing event",
                zap.String("eventId", event.ID),
                zap.String("type", string(event.Type)),
                zap.String("action", event.Action),
                zap.String("object", event.Object),
                zap.String("entityId", event.EntityID),
                zap.String("username", event.Username),
        )

        p.manager.BroadcastEvent(event)</span>
}

// PublishEntityEvent publishes an event for entity operations (CRUD)
func (p *Publisher) PublishEntityEvent(action, object, entityID, username string, data map[string]interface{}, context models.EventContext) <span class="cov2" title="2">{
        if !p.enabled || p.manager == nil </span><span class="cov1" title="1">{
                return
        }</span>

        // Determine event type based on action and object
        <span class="cov1" title="1">eventType := models.GetEventTypeFromAction(action, object)

        // Create event
        event := models.NewEvent(eventType, action, object, entityID, username, data)
        event.Context = context

        // Publish event
        p.PublishEvent(event)</span>
}

// IsEnabled returns whether event publishing is enabled
func (p *Publisher) IsEnabled() bool <span class="cov3" title="4">{
        return p.enabled
}</span>

// NoOpPublisher is a no-op implementation of EventPublisher
type NoOpPublisher struct{}

// NewNoOpPublisher creates a no-op publisher (for when WebSocket is disabled)
func NewNoOpPublisher() EventPublisher <span class="cov3" title="3">{
        return &amp;NoOpPublisher{}
}</span>

// PublishEvent does nothing
func (n *NoOpPublisher) PublishEvent(event *models.Event) {<span class="cov1" title="1">}</span>

// PublishEntityEvent does nothing
func (n *NoOpPublisher) PublishEntityEvent(action, object, entityID, username string, data map[string]interface{}, context models.EventContext) {<span class="cov1" title="1">}</span>

// IsEnabled returns false
func (n *NoOpPublisher) IsEnabled() bool <span class="cov1" title="1">{
        return false
}</span>

// Helper functions for creating common event contexts

// NewProjectContext creates an event context for project-related events
func NewProjectContext(projectID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                ProjectID:   projectID,
                Permissions: permissions,
        }
}</span>

// NewOrganizationContext creates an event context for organization-related events
func NewOrganizationContext(organizationID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                OrganizationID: organizationID,
                Permissions:    permissions,
        }
}</span>

// NewTeamContext creates an event context for team-related events
func NewTeamContext(teamID, organizationID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                TeamID:         teamID,
                OrganizationID: organizationID,
                Permissions:    permissions,
        }
}</span>

// NewAccountContext creates an event context for account-related events
func NewAccountContext(accountID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                AccountID:   accountID,
                Permissions: permissions,
        }
}</span>

// NewFullContext creates an event context with all fields
func NewFullContext(projectID, organizationID, teamID, accountID string, permissions []string) models.EventContext <span class="cov1" title="1">{
        return models.EventContext{
                ProjectID:      projectID,
                OrganizationID: organizationID,
                TeamID:         teamID,
                AccountID:      accountID,
                Permissions:    permissions,
        }
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "helixtrack.ru/core/internal/config"
        "helixtrack.ru/core/internal/logger"
        "helixtrack.ru/core/internal/server"
)

const (
        defaultConfigPath = "Configurations/default.json"
        version           = "1.0.0"
)

func main() <span class="cov0" title="0">{
        // Parse command line flags
        configPath := flag.String("config", defaultConfigPath, "Path to configuration file")
        showVersion := flag.Bool("version", false, "Show version and exit")
        flag.Parse()

        // Show version and exit
        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("Helix Track Core v%s\n", version)
                os.Exit(0)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to load configuration: %v\n", err)
                os.Exit(1)
        }</span>

        // Set version
        <span class="cov0" title="0">cfg.Version = version

        // Initialize logger
        if err := logger.Initialize(cfg.Log); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logger.Sync()

        logger.Infof("Starting Helix Track Core v%s", version)
        logger.Infof("Configuration loaded from: %s", *configPath)

        // Create server
        srv, err := server.NewServer(cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to create server: %v", err)
        }</span>

        // Start server in a goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := srv.Start(); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("Server error: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        logger.Info("Shutting down server...")

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Server forced to shutdown: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("Server exited successfully")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
