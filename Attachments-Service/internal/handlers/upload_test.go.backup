package handlers

import (
	"bytes"
	"context"
	"errors"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/helixtrack/attachments-service/internal/models"
	"github.com/helixtrack/attachments-service/internal/security/scanner"
	"github.com/helixtrack/attachments-service/internal/security/validation"
	"github.com/helixtrack/attachments-service/internal/storage/deduplication"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"go.uber.org/zap"
)

// Mock implementations

type MockDeduplicationEngine struct {
	mock.Mock
}

func (m *MockDeduplicationEngine) ProcessUpload(ctx context.Context, reader io.Reader, metadata *deduplication.UploadMetadata) (*deduplication.UploadResult, error) {
	args := m.Called(ctx, reader, metadata)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*deduplication.UploadResult), args.Error(1)
}

func (m *MockDeduplicationEngine) ProcessUploadFromPath(ctx context.Context, filePath string, metadata *deduplication.UploadMetadata) (*deduplication.UploadResult, error) {
	args := m.Called(ctx, filePath, metadata)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*deduplication.UploadResult), args.Error(1)
}

func (m *MockDeduplicationEngine) DownloadFile(ctx context.Context, referenceID string) (io.ReadCloser, *models.AttachmentReference, *models.AttachmentFile, error) {
	args := m.Called(ctx, referenceID)
	if args.Get(0) == nil {
		return nil, nil, nil, args.Error(3)
	}
	return args.Get(0).(io.ReadCloser), args.Get(1).(*models.AttachmentReference), args.Get(2).(*models.AttachmentFile), args.Error(3)
}

func (m *MockDeduplicationEngine) DeleteReference(ctx context.Context, referenceID string) error {
	args := m.Called(ctx, referenceID)
	return args.Error(0)
}

func (m *MockDeduplicationEngine) CheckDeduplication(ctx context.Context, hash string) (bool, *models.AttachmentFile, error) {
	args := m.Called(ctx, hash)
	if args.Get(1) == nil {
		return args.Bool(0), nil, args.Error(2)
	}
	return args.Bool(0), args.Get(1).(*models.AttachmentFile), args.Error(2)
}

func (m *MockDeduplicationEngine) GetDeduplicationStats(ctx context.Context) (*deduplication.DeduplicationStats, error) {
	args := m.Called(ctx)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*deduplication.DeduplicationStats), args.Error(1)
}

type MockSecurityScanner struct {
	mock.Mock
}

func (m *MockSecurityScanner) Scan(ctx context.Context, reader io.Reader, filename string) (*scanner.ScanResult, error) {
	args := m.Called(ctx, reader, filename)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*scanner.ScanResult), args.Error(1)
}

func (m *MockSecurityScanner) ScanFile(ctx context.Context, filePath string) (*scanner.ScanResult, error) {
	args := m.Called(ctx, filePath)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*scanner.ScanResult), args.Error(1)
}

func (m *MockSecurityScanner) IsEnabled() bool {
	args := m.Called()
	return args.Bool(0)
}

func (m *MockSecurityScanner) Ping(ctx context.Context) error {
	args := m.Called(ctx)
	return args.Error(0)
}

type MockValidator struct {
	mock.Mock
}

func (m *MockValidator) ValidateFilename(filename string) (string, error) {
	args := m.Called(filename)
	return args.String(0), args.Error(1)
}

func (m *MockValidator) ValidateEntityType(entityType string) error {
	args := m.Called(entityType)
	return args.Error(0)
}

func (m *MockValidator) ValidateEntityID(entityID string) error {
	args := m.Called(entityID)
	return args.Error(0)
}

func (m *MockValidator) ValidateDescription(description string) error {
	args := m.Called(description)
	return args.Error(0)
}

func (m *MockValidator) SanitizeTags(tags []string) []string {
	args := m.Called(tags)
	return args.Get(0).([]string)
}

type MockPrometheusMetrics struct {
	mock.Mock
}

func (m *MockPrometheusMetrics) RecordUpload(status, mimeType string, size int64, duration time.Duration) {
	m.Called(status, mimeType, size, duration)
}

func (m *MockPrometheusMetrics) RecordDownload(status string, size int64, duration time.Duration, cacheHit bool) {
	m.Called(status, size, duration, cacheHit)
}

func (m *MockPrometheusMetrics) RecordDelete(status string) {
	m.Called(status)
}

func (m *MockPrometheusMetrics) RecordDeduplication(deduplicated bool, savedBytes int64) {
	m.Called(deduplicated, savedBytes)
}

func (m *MockPrometheusMetrics) RecordVirusScan(status string) {
	m.Called(status)
}

func (m *MockPrometheusMetrics) RecordError(errorType string, operation string) {
	m.Called(errorType, operation)
}

func (m *MockPrometheusMetrics) RecordSecurityEvent(eventType, details string) {
	m.Called(eventType, details)
}

// Helper functions

func createTestHandler() (*UploadHandler, *MockDeduplicationEngine, *MockSecurityScanner, *MockValidator, *MockPrometheusMetrics) {
	mockEngine := &MockDeduplicationEngine{}
	mockScanner := &MockSecurityScanner{}
	mockValidator := &MockValidator{}
	mockMetrics := &MockPrometheusMetrics{}
	logger := zap.NewNop()

	config := &UploadConfig{
		MaxFileSize:      10 * 1024 * 1024, // 10 MB
		RequireAuth:      true,
		EnableVirusScan:  true,
	}

	// Create a real validator for tests (validation is tested separately in validation package)
	validatorConfig := &validation.ValidationConfig{
		MaxFilenameLength:    255,
		MaxDescriptionLength: 1000,
		MaxTagLength:         50,
		MaxTags:              10,
	}
	realValidator := validation.NewValidator(validatorConfig)

	handler := NewUploadHandler(mockEngine, mockScanner, realValidator, mockMetrics, logger, config)

	return handler, mockEngine, mockScanner, mockValidator, mockMetrics
}

func createMultipartRequest(filename, content, entityType, entityID string) (*http.Request, error) {
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// Add file
	part, err := writer.CreateFormFile("file", filename)
	if err != nil {
		return nil, err
	}
	part.Write([]byte(content))

	// Add form fields
	writer.WriteField("entity_type", entityType)
	writer.WriteField("entity_id", entityID)

	writer.Close()

	req, err := http.NewRequest("POST", "/upload", body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())

	return req, nil
}

// Tests

func TestNewUploadHandler(t *testing.T) {
	t.Run("with nil config uses defaults", func(t *testing.T) {
		mockEngine := &MockDeduplicationEngine{}
		mockScanner := &MockSecurityScanner{}
		mockMetrics := &MockPrometheusMetrics{}
		logger := zap.NewNop()

		handler := NewUploadHandler(mockEngine, mockScanner, nil, mockMetrics, logger, nil)

		assert.NotNil(t, handler)
		assert.NotNil(t, handler.config)
		assert.Equal(t, int64(100*1024*1024), handler.config.MaxFileSize)
	})

	t.Run("with custom config", func(t *testing.T) {
		mockEngine := &MockDeduplicationEngine{}
		mockScanner := &MockSecurityScanner{}
		mockMetrics := &MockPrometheusMetrics{}
		logger := zap.NewNop()

		config := &UploadConfig{
			MaxFileSize: 50 * 1024 * 1024,
			RequireAuth: false,
		}

		handler := NewUploadHandler(mockEngine, mockScanner, nil, mockMetrics, logger, config)

		assert.Equal(t, int64(50*1024*1024), handler.config.MaxFileSize)
		assert.False(t, handler.config.RequireAuth)
	})
}

func TestUploadHandler_Handle_Success(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, mockMetrics := createTestHandler()

	// Setup mocks
	mockValidator.On("ValidateFilename", "test.pdf").Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "TICKET-123").Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "test.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
		SizeBytes: 1024,
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.Anything).Return(&deduplication.UploadResult{
		ReferenceID:  "ref-123",
		FileHash:     "abc123",
		SizeBytes:    1024,
		Deduplicated: false,
		SavedBytes:   0,
	}, nil)

	mockMetrics.On("RecordUpload", "success", "application/pdf", int64(1024), mock.Anything).Return()

	// Create request
	req, err := createMultipartRequest("test.pdf", "PDF content here", "ticket", "TICKET-123")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "ref-123")
	assert.Contains(t, w.Body.String(), "abc123")
	mockValidator.AssertExpectations(t)
	mockScanner.AssertExpectations(t)
	mockEngine.AssertExpectations(t)
	mockMetrics.AssertExpectations(t)
}

func TestUploadHandler_Handle_Deduplication(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, mockMetrics := createTestHandler()

	// Setup mocks
	mockValidator.On("ValidateFilename", "duplicate.pdf").Return("duplicate.pdf", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "TICKET-456").Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "duplicate.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
		SizeBytes: 2048,
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.Anything).Return(&deduplication.UploadResult{
		ReferenceID:  "ref-456",
		FileHash:     "def456",
		SizeBytes:    2048,
		Deduplicated: true,
		SavedBytes:   2048,
	}, nil)

	mockMetrics.On("RecordUpload", "success", "application/pdf", int64(2048), mock.Anything).Return()
	mockMetrics.On("RecordDeduplication", true, int64(2048)).Return()

	// Create request
	req, err := createMultipartRequest("duplicate.pdf", "Same PDF content", "ticket", "TICKET-456")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "\"deduplicated\":true")
	assert.Contains(t, w.Body.String(), "\"saved_bytes\":2048")
	mockMetrics.AssertExpectations(t)
}

func TestUploadHandler_Handle_MissingAuth(t *testing.T) {
	handler, _, _, _, _ := createTestHandler()

	// Create request
	req, err := createMultipartRequest("test.pdf", "Content", "ticket", "TICKET-123")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	// Don't set user_id

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusUnauthorized, w.Code)
	assert.Contains(t, w.Body.String(), "authentication required")
}

func TestUploadHandler_Handle_NoAuthRequired(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, _ := createTestHandler()
	handler.config.RequireAuth = false

	// Setup mocks
	mockValidator.On("ValidateFilename", "test.pdf").Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "TICKET-123").Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "test.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
		SizeBytes: 1024,
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.Anything).Return(&deduplication.UploadResult{
		ReferenceID: "ref-789",
		FileHash:    "ghi789",
		SizeBytes:   1024,
	}, nil)

	// Create request
	req, err := createMultipartRequest("test.pdf", "Content", "ticket", "TICKET-123")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	// Don't set user_id

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusOK, w.Code)
}

func TestUploadHandler_Handle_MissingFile(t *testing.T) {
	handler, _, _, _, _ := createTestHandler()

	// Create request without file
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	writer.WriteField("entity_type", "ticket")
	writer.WriteField("entity_id", "TICKET-123")
	writer.Close()

	req, err := http.NewRequest("POST", "/upload", body)
	assert.NoError(t, err)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "file is required")
}

func TestUploadHandler_Handle_InvalidFilename(t *testing.T) {
	handler, _, _, mockValidator, _ := createTestHandler()

	mockValidator.On("ValidateFilename", "../../etc/passwd").Return("", errors.New("path traversal detected"))

	// Create request
	req, err := createMultipartRequest("../../etc/passwd", "Malicious", "ticket", "TICKET-123")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "invalid filename")
	mockValidator.AssertExpectations(t)
}

func TestUploadHandler_Handle_InvalidEntityType(t *testing.T) {
	handler, _, _, mockValidator, _ := createTestHandler()

	mockValidator.On("ValidateFilename", "test.pdf").Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", "invalid@type").Return(errors.New("invalid entity type"))

	// Create request
	req, err := createMultipartRequest("test.pdf", "Content", "invalid@type", "TICKET-123")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "invalid entity type")
	mockValidator.AssertExpectations(t)
}

func TestUploadHandler_Handle_InvalidEntityID(t *testing.T) {
	handler, _, _, mockValidator, _ := createTestHandler()

	mockValidator.On("ValidateFilename", "test.pdf").Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "INVALID\\x00ID").Return(errors.New("null byte detected"))

	// Create request
	req, err := createMultipartRequest("test.pdf", "Content", "ticket", "INVALID\\x00ID")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "invalid entity ID")
	mockValidator.AssertExpectations(t)
}

func TestUploadHandler_Handle_SecurityScanFailed(t *testing.T) {
	handler, _, mockScanner, mockValidator, mockMetrics := createTestHandler()

	mockValidator.On("ValidateFilename", "virus.exe").Return("virus.exe", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "TICKET-123").Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "virus.exe").Return(&scanner.ScanResult{
		Safe:          false,
		VirusDetected: true,
		VirusName:     "EICAR-Test-File",
		Errors:        []string{"virus detected"},
	}, nil)

	mockMetrics.On("RecordSecurityEvent", "upload_blocked", "EICAR-Test-File").Return()

	// Create request
	req, err := createMultipartRequest("virus.exe", "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR", "ticket", "TICKET-123")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "virus detected")
	mockMetrics.AssertExpectations(t)
}

func TestUploadHandler_Handle_DeduplicationFailed(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, _ := createTestHandler()

	mockValidator.On("ValidateFilename", "test.pdf").Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "TICKET-123").Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "test.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.Anything).Return(nil, errors.New("storage failed"))

	// Create request
	req, err := createMultipartRequest("test.pdf", "Content", "ticket", "TICKET-123")
	assert.NoError(t, err)

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusInternalServerError, w.Code)
	assert.Contains(t, w.Body.String(), "failed to process upload")
}

func TestUploadHandler_HandleMultiple_Success(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, _ := createTestHandler()

	// Setup mocks for both files
	mockValidator.On("ValidateFilename", "file1.pdf").Return("file1.pdf", nil)
	mockValidator.On("ValidateFilename", "file2.pdf").Return("file2.pdf", nil)
	mockValidator.On("ValidateEntityType", "project").Return(nil)
	mockValidator.On("ValidateEntityID", "PROJECT-1").Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "file1.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
		SizeBytes: 1024,
	}, nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "file2.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
		SizeBytes: 2048,
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.MatchedBy(func(m *deduplication.UploadMetadata) bool {
		return m.Filename == "file1.pdf"
	})).Return(&deduplication.UploadResult{
		ReferenceID: "ref-1",
		FileHash:    "hash1",
		SizeBytes:   1024,
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.MatchedBy(func(m *deduplication.UploadMetadata) bool {
		return m.Filename == "file2.pdf"
	})).Return(&deduplication.UploadResult{
		ReferenceID: "ref-2",
		FileHash:    "hash2",
		SizeBytes:   2048,
	}, nil)

	// Create multi-file request
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// Add first file
	part1, _ := writer.CreateFormFile("files", "file1.pdf")
	part1.Write([]byte("PDF 1 content"))

	// Add second file
	part2, _ := writer.CreateFormFile("files", "file2.pdf")
	part2.Write([]byte("PDF 2 content here"))

	// Add form fields
	writer.WriteField("entity_type", "project")
	writer.WriteField("entity_id", "PROJECT-1")
	writer.Close()

	req, _ := http.NewRequest("POST", "/upload/multiple", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.HandleMultiple(ctx)

	// Assert
	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "ref-1")
	assert.Contains(t, w.Body.String(), "ref-2")
	assert.Contains(t, w.Body.String(), `"successful":2`)
	assert.Contains(t, w.Body.String(), `"failed":0`)
}

func TestUploadHandler_HandleMultiple_NoFiles(t *testing.T) {
	handler, _, _, _, _ := createTestHandler()

	// Create request without files
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	writer.WriteField("entity_type", "project")
	writer.WriteField("entity_id", "PROJECT-1")
	writer.Close()

	req, _ := http.NewRequest("POST", "/upload/multiple", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.HandleMultiple(ctx)

	// Assert
	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "no files provided")
}

func TestUploadHandler_HandleMultiple_TooManyFiles(t *testing.T) {
	handler, _, _, _, _ := createTestHandler()

	// Create request with 11 files (exceeds limit of 10)
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	for i := 0; i < 11; i++ {
		part, _ := writer.CreateFormFile("files", "file"+string(rune(i))+".pdf")
		part.Write([]byte("content"))
	}

	writer.WriteField("entity_type", "project")
	writer.WriteField("entity_id", "PROJECT-1")
	writer.Close()

	req, _ := http.NewRequest("POST", "/upload/multiple", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.HandleMultiple(ctx)

	// Assert
	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "too many files")
}

func TestUploadHandler_HandleMultiple_PartialFailure(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, _ := createTestHandler()

	// Setup mocks - first file succeeds, second fails validation
	mockValidator.On("ValidateFilename", "valid.pdf").Return("valid.pdf", nil)
	mockValidator.On("ValidateFilename", "../../invalid.pdf").Return("", errors.New("invalid filename"))
	mockValidator.On("ValidateEntityType", "project").Return(nil)
	mockValidator.On("ValidateEntityID", "PROJECT-1").Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "valid.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
		SizeBytes: 1024,
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.Anything).Return(&deduplication.UploadResult{
		ReferenceID: "ref-1",
		FileHash:    "hash1",
		SizeBytes:   1024,
	}, nil)

	// Create multi-file request
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// Add valid file
	part1, _ := writer.CreateFormFile("files", "valid.pdf")
	part1.Write([]byte("Valid content"))

	// Add invalid file
	part2, _ := writer.CreateFormFile("files", "../../invalid.pdf")
	part2.Write([]byte("Invalid"))

	writer.WriteField("entity_type", "project")
	writer.WriteField("entity_id", "PROJECT-1")
	writer.Close()

	req, _ := http.NewRequest("POST", "/upload/multiple", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.HandleMultiple(ctx)

	// Assert
	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), `"successful":1`)
	assert.Contains(t, w.Body.String(), `"failed":1`)
	assert.Contains(t, w.Body.String(), "invalid filename")
}

func TestUploadHandler_Handle_WithDescription(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, _ := createTestHandler()

	description := "Test document description"

	mockValidator.On("ValidateFilename", "test.pdf").Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "TICKET-123").Return(nil)
	mockValidator.On("ValidateDescription", description).Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "test.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.MatchedBy(func(m *deduplication.UploadMetadata) bool {
		return m.Description == description
	})).Return(&deduplication.UploadResult{
		ReferenceID: "ref-123",
		FileHash:    "abc123",
		SizeBytes:   1024,
	}, nil)

	// Create request with description
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	part, _ := writer.CreateFormFile("file", "test.pdf")
	part.Write([]byte("PDF content"))

	writer.WriteField("entity_type", "ticket")
	writer.WriteField("entity_id", "TICKET-123")
	writer.WriteField("description", description)
	writer.Close()

	req, _ := http.NewRequest("POST", "/upload", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusOK, w.Code)
	mockValidator.AssertExpectations(t)
	mockEngine.AssertExpectations(t)
}

func TestUploadHandler_Handle_WithTags(t *testing.T) {
	handler, mockEngine, mockScanner, mockValidator, _ := createTestHandler()

	tags := []string{"important", "review"}
	sanitizedTags := []string{"important", "review"}

	mockValidator.On("ValidateFilename", "test.pdf").Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", "ticket").Return(nil)
	mockValidator.On("ValidateEntityID", "TICKET-123").Return(nil)
	mockValidator.On("SanitizeTags", mock.Anything).Return(sanitizedTags)

	mockScanner.On("Scan", mock.Anything, mock.Anything, "test.pdf").Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.MatchedBy(func(m *deduplication.UploadMetadata) bool {
		return len(m.Tags) == 2
	})).Return(&deduplication.UploadResult{
		ReferenceID: "ref-123",
		FileHash:    "abc123",
		SizeBytes:   1024,
	}, nil)

	// Create request with tags
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	part, _ := writer.CreateFormFile("file", "test.pdf")
	part.Write([]byte("PDF content"))

	writer.WriteField("entity_type", "ticket")
	writer.WriteField("entity_id", "TICKET-123")
	for _, tag := range tags {
		writer.WriteField("tags", tag)
	}
	writer.Close()

	req, _ := http.NewRequest("POST", "/upload", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Create response recorder
	w := httptest.NewRecorder()
	ctx, _ := gin.CreateTestContext(w)
	ctx.Request = req
	ctx.Set("user_id", "user123")

	// Execute
	handler.Handle(ctx)

	// Assert
	assert.Equal(t, http.StatusOK, w.Code)
	mockValidator.AssertExpectations(t)
}

func TestDefaultUploadConfig(t *testing.T) {
	config := DefaultUploadConfig()

	assert.NotNil(t, config)
	assert.Equal(t, int64(100*1024*1024), config.MaxFileSize)
	assert.True(t, config.RequireAuth)
	assert.True(t, config.EnableVirusScan)
	assert.NotEmpty(t, config.AllowedMimeTypes)
	assert.NotEmpty(t, config.AllowedExtensions)
}

func BenchmarkUploadHandler_Handle(b *testing.B) {
	handler, mockEngine, mockScanner, mockValidator, _ := createTestHandler()

	mockValidator.On("ValidateFilename", mock.Anything).Return("test.pdf", nil)
	mockValidator.On("ValidateEntityType", mock.Anything).Return(nil)
	mockValidator.On("ValidateEntityID", mock.Anything).Return(nil)

	mockScanner.On("Scan", mock.Anything, mock.Anything, mock.Anything).Return(&scanner.ScanResult{
		Safe:      true,
		MimeType:  "application/pdf",
		Extension: ".pdf",
		SizeBytes: 1024,
	}, nil)

	mockEngine.On("ProcessUpload", mock.Anything, mock.Anything, mock.Anything).Return(&deduplication.UploadResult{
		ReferenceID: "ref-123",
		FileHash:    "abc123",
		SizeBytes:   1024,
	}, nil)

	content := strings.Repeat("A", 1024)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		req, _ := createMultipartRequest("test.pdf", content, "ticket", "TICKET-123")
		w := httptest.NewRecorder()
		ctx, _ := gin.CreateTestContext(w)
		ctx.Request = req
		ctx.Set("user_id", "user123")

		handler.Handle(ctx)
	}
}
